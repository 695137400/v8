{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9190195e_c78de9a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1535927
      },
      "writtenOn": "2022-11-02T17:20:21Z",
      "side": 1,
      "message": "Some context around those functions, which could be useful to determine if it\u0027s worth optimizing them: in JetStream2 (arguably not the best benchmark, and it\u0027s possible that this doesn\u0027t reflect real-world benchmarks, but still better than nothing), here is the number of times that those functions are called:\n  - DoubleToInt32: 10,200,000 times\n  - DoubleToInteger: 11,000,000 times\n  - IsInt32Double: 1,400,000 times\n  - the other functions are not called.\nI would say that this sounds like large-ish numbers, so maybe it\u0027s worth optimizing those functions.\n\nHowever, in my benchmarks (on a Comet Lake), your SSE versions of DoubleToInteger and IsInt32Double are 2.5 times slower than the scalar versions (I didn\u0027t benchmark DoubleToInt32, but I expect similar results). Could you please share the performance numbers you measured on your side, how you measured them, and on which architecture?",
      "revId": "6e68396f2c07d9fbd7101c9983f5da263551cdb1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06366cd9_19cce327",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1559914
      },
      "writtenOn": "2022-11-18T14:42:05Z",
      "side": 1,
      "message": "I was running the benchmarks on an AWS EC2 instance that had an Intel(R) Xeon(R) Platinum 8175M CPU @ 2.50GHz (which is a Skylake-SP CPU).\n\nI also wrote my benchmark programs using the Google Benchmark library, and I was running the benchmarks against random double-precision floating-point values (that cover the entire range of double-precision floating point values, and not just those within the range of a 32-bit signed integer).\n\nI also ran some benchmarks on a Windows 10 PC with an older Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz (which is an Ivy Bridge CPU), and my SSE2-optimized routines outperformed the current implementations in src/numbers/conversions-inl.h on an older Ivy Bridge PC.\n\nHere are the results of running my benchmarks on an AWS EC2 instance with an Intel Xeon Platinum 8175M CPU on Ubuntu 22.04 (with the original conversion routines in \nsrc/numbers/conversions-inl.h indicated by an asterisk):\nRunning ./x86_64_js_double_conv_benchmark_111822_3\nRun on (2 X 2500 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x1)\n  L1 Instruction 32 KiB (x1)\n  L2 Unified 1024 KiB (x1)\n  L3 Unified 33792 KiB (x1)\nLoad Average: 0.25, 0.21, 0.09\n----------------------------------------------------------------------\nBenchmark                            Time             CPU   Iterations\n----------------------------------------------------------------------\nBM_FastD2UI*                      2160 ns         2159 ns       306074\nBM_FastD2UI_SSE2                  2003 ns         2002 ns       331903\nBM_DoubleToInteger*               6803 ns         6800 ns        96549\nBM_DoubleToInteger_SSE2           3576 ns         3574 ns       193626\nBM_DoubleToInt32*                 3482 ns         3481 ns       202990\nBM_DoubleToInt32_SSE2             3428 ns         3426 ns       201454\nBM_DoubleToWebIDLInt64*           3437 ns         3436 ns       201024\nBM_DoubleToWebIDLInt64_SSE2       2583 ns         2579 ns       266584\nBM_IsInt32Double*                 4133 ns         4132 ns       170275\nBM_IsInt32Double_SSE2             3100 ns         3099 ns       224044\nBM_IsUint32Double*                6802 ns         6801 ns        95994\nBM_IsUint32Double_SSE2            3504 ns         3492 ns       198604\n\nRunning ./x86_64_js_double_conv_benchmark_111822_3_clang\nRun on (2 X 2500 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x1)\n  L1 Instruction 32 KiB (x1)\n  L2 Unified 1024 KiB (x1)\n  L3 Unified 33792 KiB (x1)\nLoad Average: 0.31, 0.23, 0.10\n----------------------------------------------------------------------\nBenchmark                            Time             CPU   Iterations\n----------------------------------------------------------------------\nBM_FastD2UI*                      5368 ns         5364 ns       100000\nBM_FastD2UI_SSE2                  2232 ns         2232 ns       272831\nBM_DoubleToInteger*              24167 ns        24159 ns        30415\nBM_DoubleToInteger_SSE2           3542 ns         3541 ns       195279\nBM_DoubleToInt32*                 2745 ns         2745 ns       251693\nBM_DoubleToInt32_SSE2             2632 ns         2631 ns       261675\nBM_DoubleToWebIDLInt64*           3633 ns         3631 ns       191743\nBM_DoubleToWebIDLInt64_SSE2       2622 ns         2621 ns       261987\nBM_IsInt32Double*                 3307 ns         3306 ns       209892\nBM_IsInt32Double_SSE2             3142 ns         3141 ns       220686\nBM_IsUint32Double*                7207 ns         7204 ns        91427\nBM_IsUint32Double_SSE2            3492 ns         3491 ns       198129\n\nHere are the results of running my benchmarks on an Windows 10 PC with an Intel Core i5-3470 CPU (with the original conversion routines in \nsrc/numbers/conversions-inl.h indicated by an asterisk):\nRunning C:\\Users\\John\\Documents\\programming\\x86_64_js_double_conv_benchmark_111822_2_mingw_ucrt64_clang.exe\nRun on (4 X 3234.12 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x4)\n  L1 Instruction 32 KiB (x4)\n  L2 Unified 256 KiB (x4)\n  L3 Unified 6144 KiB (x1)\n----------------------------------------------------------------------\nBenchmark                            Time             CPU   Iterations\n----------------------------------------------------------------------\nBM_FastD2UI*                      4554 ns         4577 ns       617931\nBM_FastD2UI_SSE2                  3000 ns         3015 ns       943158\nBM_DoubleToInteger*              13576 ns        13504 ns       203636\nBM_DoubleToInteger_SSE2           3519 ns         3530 ns       814545\nBM_DoubleToInt32*                 3134 ns         3131 ns       943158\nBM_DoubleToInt32_SSE2             2773 ns         2727 ns      1054118\nBM_DoubleToWebIDLInt64*           3681 ns         3599 ns       746667\nBM_DoubleToWebIDLInt64_SSE2       2939 ns         2762 ns       995556\nBM_IsInt32Double*                 4739 ns         4492 ns       640000\nBM_IsInt32Double_SSE2             3531 ns         3489 ns       779130\nBM_IsUint32Double*                7715 ns         7690 ns       365714\nBM_IsUint32Double_SSE2            3785 ns         3690 ns       779130\n\nRunning C:\\Users\\John\\Documents\\programming\\x86_64_js_double_conv_benchmark_111822_2_mingw_ucrt64.exe\nRun on (4 X 3218.99 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x4)\n  L1 Instruction 32 KiB (x4)\n  L2 Unified 256 KiB (x4)\n  L3 Unified 6144 KiB (x1)\n----------------------------------------------------------------------\nBenchmark                            Time             CPU   Iterations\n----------------------------------------------------------------------\nBM_FastD2UI*                      2320 ns         2354 ns       298667\nBM_FastD2UI_SSE2                  3001 ns         2982 ns       235789\nBM_DoubleToInteger*               8216 ns         8196 ns        89600\nBM_DoubleToInteger_SSE2           3534 ns         3606 ns       203636\nBM_DoubleToInt32*                 3575 ns         3530 ns       194783\nBM_DoubleToInt32_SSE2             2727 ns         2668 ns       263529\nBM_DoubleToWebIDLInt64*           3597 ns         3610 ns       194783\nBM_DoubleToWebIDLInt64_SSE2       4801 ns         2787 ns       263529\nBM_IsInt32Double*                 4481 ns         4450 ns       154483\nBM_IsInt32Double_SSE2             3122 ns         3139 ns       224000\nBM_IsUint32Double*                5807 ns         5720 ns       112000\nBM_IsUint32Double_SSE2            4029 ns         4102 ns       186667\n\nThe above benchmarks were ran against a test file that included 3132 random double values (covering the full range of finite double-precision floating point values).\n\nThe benchmark functions were implemented using the below code in my benchmarking programs (and a macro was used to minimize repetition):\nstatic const double* MemoryMappedDoubleData;\nstatic std::size_t MemoryMappedDoubleElementLength;\n\n#define DEFINE_CONV_FUNC_BENCHMARK(convFunc) \\\nstatic void BM_##convFunc(benchmark::State\u0026 state) { \\\n  const std::size_t dataLen \u003d MemoryMappedDoubleElementLength; \\\n  const double* const dataStartPtr \u003d MemoryMappedDoubleData; \\\n  const double* const dataEndPtr \u003d dataStartPtr + dataLen; \\\n  \\\n  for (auto _ : state) { \\\n    for(const double* currPtr \u003d dataStartPtr; currPtr !\u003d dataEndPtr; currPtr++) \\\n      benchmark::DoNotOptimize(convroutines::convFunc(*currPtr)); \\\n  } \\\n} \\\nBENCHMARK(BM_##convFunc);",
      "parentUuid": "9190195e_c78de9a7",
      "revId": "6e68396f2c07d9fbd7101c9983f5da263551cdb1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50f65395_84cfeb34",
        "filename": "src/numbers/conversions-inl.h",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1535927
      },
      "writtenOn": "2022-11-02T16:44:56Z",
      "side": 1,
      "message": "It looks like your implementation is truncating its input, whereas the older implementations rounds it. I haven\u0027t looked at the use-cases in details, but I would expect that this could be an issue. It might be worth adding a DCHECK to make sure that this implementation returns the same result as the older one.\n\nAlso, on which architecture have you benchmarked your code? On my Comet Lake, the old scalar implementation is 1.2x faster that your new implementation.\n\nRegardless, I share Clemens\u0027 concern that the added complexity of this SSE version might not be worth the potential performance improvements, but I\u0027ll let Tobias be the judge of that :)",
      "range": {
        "startLine": 35,
        "startChar": 20,
        "endLine": 35,
        "endChar": 38
      },
      "revId": "6e68396f2c07d9fbd7101c9983f5da263551cdb1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}