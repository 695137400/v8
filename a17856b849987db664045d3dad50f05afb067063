{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2b43cd92_e2c6047a",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 24,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2023-11-16T22:54:32Z",
      "side": 1,
      "message": "It might be time to address this TODO since I want to create a result object in `js-atomics-synchronization.cc`",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 60
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "458c6b3d_c6d7f308",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 24,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2023-12-08T18:46:16Z",
      "side": 1,
      "message": "Sounds like a good idea to me.",
      "parentUuid": "2b43cd92_e2c6047a",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 60
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7fc6f3c6_e2375bfe",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 24,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-03-13T22:49:56Z",
      "side": 1,
      "message": "Looked a little more into this, storing a canonical map in the native context for this result object seems like a little excessive for the MVP. Mostly because we are not using it in torque code or any kind of optimizing compiler code, I think we can leave this TODO open for now.",
      "parentUuid": "458c6b3d_c6d7f308",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 60
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "38c9eb20_88bfdd21",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 24,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-30T23:59:25Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "7fc6f3c6_e2375bfe",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 60
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5543bd08_e2ed9b96",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 220,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2023-11-16T22:54:32Z",
      "side": 1,
      "message": "Is this really necessary? This may throw when running multiple unrelated calls to `asyncLock` in the same thread, which sounds like a terrible bug. I\u0027d prefer risking the program to block an asychronous task forever due to a recursive call rather than the almost impossible organization of tasks to guarantee that this won\u0027t throw.\n\nNote that in our current implementation, calling an `asyncLock` inside a sync `lock` will not block the thread in any way, the sync lock will exit successfully and then the async lock would be able to take the mutex.",
      "range": {
        "startLine": 215,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8641b478_86a91d8d",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 220,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2023-12-08T18:46:16Z",
      "side": 1,
      "message": "To make sure I understand, you\u0027re saying there\u0027s a use case where you\u0027re on a thread with the lock already held, but you\u0027d like to queue up some more promises on the same lock to be resolved after you release the lock, for when it\u0027s locked next time?",
      "parentUuid": "5543bd08_e2ed9b96",
      "range": {
        "startLine": 215,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "54d85c01_416140a2",
        "filename": "src/builtins/builtins-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 220,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-02-02T17:31:41Z",
      "side": 1,
      "message": "Thanks for explaining this to me on the call. To recap the issue is that an interleaving of tasks could cause an unrelated task\u0027s call to asyncLock to throw, which would be very surprising. \n\nI\u0027m convinced we should remove this throw.",
      "parentUuid": "8641b478_86a91d8d",
      "range": {
        "startLine": 215,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d36cd2a_bfe78f94",
        "filename": "src/execution/isolate.cc",
        "patchSetId": 24
      },
      "lineNbr": 6542,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2023-11-16T22:54:32Z",
      "side": 1,
      "message": "I\u0027m not familiar with `ExternalPointerHandle`s but I think it should be fine to create them on demand for async waiters instead of reusing the one stored in the isolate for the sync waiters.",
      "range": {
        "startLine": 6536,
        "startChar": 0,
        "endLine": 6542,
        "endChar": 1
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "068e3342_1940e6b9",
        "filename": "src/execution/isolate.cc",
        "patchSetId": 24
      },
      "lineNbr": 6542,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2023-12-08T18:46:16Z",
      "side": 1,
      "message": "With the V8 sandboxing effort, there is an invariant that V8 heap objects (which `JSSynchronizationPrimitive`s are) should not directly point to things outside of the heap sandbox. `WaiterQueueNode`s before this CL are always allocated on the C stack, which is outside of the heap sandbox, and so must be indirected through an external pointer table when stored as the `state` field in a mutex or condvar. Moreover, external pointers in the table are GCed: they must be marked like other GC things, and unmarked entries are removed during GC.\n\nBefore this CL, a `WaiterQueueNode` is in at most one `state` field of a mutex or condvar, and there is exactly one per isolate, so its external pointer is unconditionally marked when marking the isolate.\n\nThis CL changes that, so we need to think more carefully how to proceed.\n\n- There is still exactly 1 synchronous `WaiterQueueNode` per isolate.\n- Each `JSSynchronizationPrimitive` may have an async waiter list head now, so there is at most 1 external pointer needed _per_ `JSSynchronizationPrimitive`.\n- Marking of the external pointer needs to be implemented as well to avoid it being swept. The liveness of the state is the same as the liveness of the owner `JSSynchronizationPrimitive`.\n\nThis makes me think this CL should implement having an external pointer per `JSSynchronizationPrimitive` that is marked (like a normal external reference) instead of the current, more fixed scheme.",
      "parentUuid": "1d36cd2a_bfe78f94",
      "range": {
        "startLine": 6536,
        "startChar": 0,
        "endLine": 6542,
        "endChar": 1
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e98cb301_1921c4e9",
        "filename": "src/execution/isolate.cc",
        "patchSetId": 24
      },
      "lineNbr": 6542,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-30T23:59:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "068e3342_1940e6b9",
      "range": {
        "startLine": 6536,
        "startChar": 0,
        "endLine": 6542,
        "endChar": 1
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff7b9211_570420b0",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 903,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2023-11-16T22:54:32Z",
      "side": 1,
      "message": "I\u0027m not sure it there was a better way to recreate this logic rather than this trick with builtins and promises, WDYT?",
      "range": {
        "startLine": 903,
        "startChar": 0,
        "endLine": 903,
        "endChar": 77
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e4654ae_44bc35be",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 903,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2023-12-08T18:46:16Z",
      "side": 1,
      "message": "The usual way to do this in V8 is to create a context with slots to hold internal state needed by the handlers (lock and unlockPromise in this case), and then the then handler functions would have that special context as their function context. Various Promise combinators do this, though their Torque code is kind of hard to read. E.g. https://source.chromium.org/chromium/chromium/src/+/main:v8/src/builtins/promise-all.tq;l\u003d17;drc\u003dec53113a6d7d95cf8b255aec7fc91b17acd33d80",
      "parentUuid": "ff7b9211_570420b0",
      "range": {
        "startLine": 903,
        "startChar": 0,
        "endLine": 903,
        "endChar": 77
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ae9da23_8157e3a8",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 903,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-02-29T20:13:39Z",
      "side": 1,
      "message": "IIUC what is done for Promise.all is creating a context that all the calls to Promise.all will use, it is not garbage collected and it can get away with having an empty ScopeInfo. The same happens with [Factory::NewBuiltinContext](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/factory.cc;bpv\u003d1;bpt\u003d1;l\u003d1441?q\u003dNewBuiltinContext\u0026gsn\u003dNewBuiltinContext\u0026gs\u003dKYTHE%3A%2F%2FKq4CCpQBa3l0aGU6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2NvZGVzZWFyY2gvY2hyb21pdW0vc3JjLy9tYWluP2xhbmc9YyUyQiUyQj9wYXRoPXY4L3NyYy9oZWFwL2ZhY3RvcnkuY2MjS3RTVWRUTnVLaGp2Y1Z2bFNad3Z3VUxKTU9mNURONWU3ZnFSUWdaUzYyMAqUAWt5dGhlOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jb2Rlc2VhcmNoL2Nocm9taXVtL3NyYy8vbWFpbj9sYW5nPWMlMkIlMkI_cGF0aD12OC9zcmMvaGVhcC9mYWN0b3J5LmNjI1pJQkgxM19QTXlrT3pxb045QjlzLVJiREFFeUNCcF96MnRRWTQwalZKblU%3D) which I tried to use below but failed the verify heap step in GC and Isolate teardown (because of no scope info). I don\u0027t see a proper way to generate a ScopeInfo at this point [ScopeInfo::CreateForEmptyFunction](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/scope-info.h?q\u003dsymbol%3A%5Cbv8%3A%3Ainternal%3A%3AScopeInfo%3A%3ACreateForEmptyFunction%5Cb%20case%3Ayes) exists but only works for read only properties.\n\nDid I miss something? Do you know of another way to create these contexts on demand?",
      "parentUuid": "7e4654ae_44bc35be",
      "range": {
        "startLine": 903,
        "startChar": 0,
        "endLine": 903,
        "endChar": 77
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd6278b4_bf154b4b",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 903,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-03-11T23:58:00Z",
      "side": 1,
      "message": "The synthetic context for `Promise.all` _is_ garbage collected. You should be able to use the empty scope info (`RootIndex::kEmptyScopeInfo`).\n\nLooking through the codebase, it seems like there\u0027s no way in C++ to do this. It basically involves porting the Torque `AllocateSyntheticFunctionContext` macro [1] to C++. That macro allocates a synthetic context (i.e. not tied to an actual JS function with source) with a number of extra slots to hold internal state.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/contexts.tq;l\u003d46-58;drc\u003d8fcd3f809ba5c71f7a29bc6623c1f93a9eac72fe",
      "parentUuid": "9ae9da23_8157e3a8",
      "range": {
        "startLine": 903,
        "startChar": 0,
        "endLine": 903,
        "endChar": 77
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "168f27c8_f0621434",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 903,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-03-13T22:49:56Z",
      "side": 1,
      "message": "Got it, my problem wasn\u0027t the empty scope info, but that I was using the wrong context slots, now it starts with `Context::MIN_CONTEXT_SLOTS`, which is what intl does in https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/intl-objects.h;drc\u003d064b9a7903b793734b6c03a86ee53a2dc85f0f80;l\u003d55.",
      "parentUuid": "cd6278b4_bf154b4b",
      "range": {
        "startLine": 903,
        "startChar": 0,
        "endLine": 903,
        "endChar": 77
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd856bcd_9f024b10",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 903,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-03-19T00:11:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "168f27c8_f0621434",
      "range": {
        "startLine": 903,
        "startChar": 0,
        "endLine": 903,
        "endChar": 77
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "162b61eb_d6d7ff5f",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 1287,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2023-11-16T22:54:32Z",
      "side": 1,
      "message": "I know we discussed about not allocating in the heap in this code, but I\u0027m not sure how we would store this node in other case.\n\nThe `shared_ptr` logic is a little convoluted here, but I wanted to avoid any explicit `delete`.",
      "range": {
        "startLine": 1287,
        "startChar": 21,
        "endLine": 1287,
        "endChar": 62
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0bfda123_94adb987",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 24
      },
      "lineNbr": 1287,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-30T23:59:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "162b61eb_d6d7ff5f",
      "range": {
        "startLine": 1287,
        "startChar": 21,
        "endLine": 1287,
        "endChar": 62
      },
      "revId": "a17856b849987db664045d3dad50f05afb067063",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}