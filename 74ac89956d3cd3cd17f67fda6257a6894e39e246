{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d800e277_302ebaf8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2021-04-20T00:16:07Z",
      "side": 1,
      "message": "Hi Toon.\n\nI uploaded a fix for  bug chromium:1156498 and included some comments and insights of what I think is happening. Could you  review the change and confirm if what I am saying is correct?.\n\nThe original report had a large script as a test. I made a minimal repro that is included as the regress test. The problem was caused by a \"pause on exception\" called on a static initializer inside a class inside a function that needed context. As I comment in the description, my fix changes some behavior of the scope chain for this scenario, so I had to modify the expected output of one of the inspector tests.\n\nThanks,\nLuis Fernando Pardo Sixtos",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be7278c1_1cd126f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-23T14:54:10Z",
      "side": 1,
      "message": "Thanks Luis! Sorry for the delay in reviewing. I have a question though",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b6d3c4f_582ebe83",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-23T14:54:10Z",
      "side": 1,
      "message": "Are we certain that context_-\u003escope_info() as scope_info as a parent scope_info? I\u0027d guess context_ could also be an outer class of a function that doesn\u0027t have a context itself? Something like\n\nclass {\n  static var1 \u003d (function() { unreferenced })();\n}\n\nIf that sets ignore_nested_scopes, that would possibly break nested scope support if unreferenced is nested somewhere?",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9a84a33_8677dcd6",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2021-04-23T20:06:57Z",
      "side": 1,
      "message": "Yes, that sets the ignore_nested_scopes flag, but since the function doesn\u0027t need context, context_ is not updated on line 310. If the functions does need context, I think that context_-\u003escope_info().scope_type() would be a function scope, which would not set the ignore_nested_scopes flag.",
      "parentUuid": "9b6d3c4f_582ebe83",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7186eb6c_a6d72e6e",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-26T09:27:37Z",
      "side": 1,
      "message": "You are right that it won\u0027t run line 310, but it will run 303 and 304. This resets where variable lookup starts to the closure scope (both current_scope and start_scope are set to closure_scope), and may hence skip stack-allocated variables that are supposed to mask outer context-allocated variables. I\u0027m thinking of something like:\n\n class {\n   static var \u003d (function () {\n     let x \u003d 10; // will be observable\n     if (true) {\n       let x \u003d 20; // will be skipped since we ignore nested scopes\n       unreferenced;\n     }\n   })();\n }",
      "parentUuid": "e9a84a33_8677dcd6",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70c1fe0a_f469cf38",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2021-04-28T00:30:45Z",
      "side": 1,
      "message": "I\u0027ve been exploring this and other cases. I believe that the initial solution is just not good and I\u0027m having some trouble figuring out a new one, so I would appreciate some feedback on the following insights.\n\n1) The problem arises from the static variable declaration failing on a class inside a scope that needs context, not only function scopes. In the case of block scopes, the code will pass the first DCHECK because the context type is BLOCK, but will fail when trying to retrieve a variable\u0027s value from the context.\n\n2) In this particular case, the value of context_ doesn\u0027t match the scope chain (which starts with an outer scope than context_\u0027s), and we could step to a parent context without updating the current and start scopes.\n\n3) As you pointed out, the initial solution catches more cases that intended, including those were the context_ value is actually useful for the scope chain.\n\n4) By comparing the position information from context_.scope_info, and the start position of start_scope_, we should be able to determine if we need to move to an outer context, however, the position information is not available for scope_info of type CLASS.\n\nDo you think it is feasible to add position information for the CLASS contexts?",
      "parentUuid": "7186eb6c_a6d72e6e",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2dc86ced_505d7d3a",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-28T12:21:54Z",
      "side": 1,
      "message": "Afaict class scopes have position information too, see --print-scopes. I\u0027m guessing there\u0027s a bug in the ScopeChainRetriever, causing it to find an outer scope to the class scope.",
      "parentUuid": "70c1fe0a_f469cf38",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da5c21e7_89a3bb78",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-28T15:37:52Z",
      "side": 1,
      "message": "Had a quick look at the test. GetSourcePosition points at the constructor\u0027s source range rather than the initializer function; so I guess the actual bug is in how the frame-inspector gets the source position.",
      "parentUuid": "2dc86ced_505d7d3a",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "884657a1_e3d39a7a",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-28T16:29:27Z",
      "side": 1,
      "message": "Actually no, the initializer works fine. It\u0027s complaining while looking at the (empty/default) class constructor one frame up the stack. Its source position is set to the \"class\" keyword I believe; and the \"GetSourcePosition()\" for that frame returns 230, while the class scope itself starts later (235 to 278). The scope walker won\u0027t walk into the class scope to find the scope for the initializer, and hence it won\u0027t know how to interpret the context chain.\n\n  class { // (0x5650c50e0058) (235, 278)\n    // strict mode scope\n    // 2 heap slots\n\n    function () { // (0x5650c50e0588) (230, 230)\n      // strict mode scope\n      // \u003d\u003d\u003d PROBLEM HERE \u003d\u003d\u003d\n      // We won\u0027t be able to find this function\u0027s scope while walking the scope\n      // chain inwards\n    }\n\n    function () { // (0x5650c50e02b0) (244, 271)\n      // strict mode scope\n      // will be compiled\n    }\n  }",
      "parentUuid": "2dc86ced_505d7d3a",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf581664_f3a1709e",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2021-04-28T17:11:00Z",
      "side": 1,
      "message": "Yes. Looks like when the static initializer fails, the next source position is set to the word class, hence, the start_scope for that frame is and outer scope for the class context. That is why I believe that a hacky solution like identifying this case and stepping to an outer context could work. Would it be worth to try and change either the source position or the initial context for this frame?",
      "parentUuid": "884657a1_e3d39a7a",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4b2eb78_ef6fa889",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2021-04-28T18:47:04Z",
      "side": 1,
      "message": "Regarding the class scope positional info. While the class scopes do have positional information, we can\u0027t access the actual scope from context_, but only its scope_info, which doesn\u0027t contain positional information for CLASS and BLOCK scopes:\n\nbool ScopeInfo::HasPositionInfo() const {\n  if (IsEmpty()) return false;\n  return NeedsPositionInfo(scope_type());\n}\n\n// static\nbool ScopeInfo::NeedsPositionInfo(ScopeType type) {\n  return type \u003d\u003d FUNCTION_SCOPE || type \u003d\u003d SCRIPT_SCOPE || type \u003d\u003d EVAL_SCOPE ||\n         type \u003d\u003d MODULE_SCOPE;\n}\n\nHaving this information available for the class context would make it easier to decide if skip to an outer context. \n\nI need to do more research on how this information is assigned to the context in order to decide if it would be better to add this positional info, or maybe modify something about the source position, start scope, or context for this frame.",
      "parentUuid": "cf581664_f3a1709e",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22e23593_d77e0cbd",
        "filename": "src/debug/debug-scopes.cc",
        "patchSetId": 6
      },
      "lineNbr": 300,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-04-29T07:48:50Z",
      "side": 1,
      "message": "I have an alternative proposed fix based on what I mentioned above: https://chromium-review.googlesource.com/c/v8/v8/+/2857957\n\nTo answer your question: We don\u0027t need to include positions in scope_info for scopes that we\u0027ll find by reparsing. We need source positions for functions because we start parsing on function boundaries.",
      "parentUuid": "f4b2eb78_ef6fa889",
      "revId": "74ac89956d3cd3cd17f67fda6257a6894e39e246",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}