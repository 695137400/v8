{
  "comments": [
    {
      "key": {
        "uuid": "1508c4ee_cc4c632e",
        "filename": "src/ast/ast.h",
        "patchSetId": 3
      },
      "lineNbr": 791,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-06-20T14:43:17Z",
      "side": 1,
      "message": "How much does this increase the AST size (or was this kind of thing already a part of the previous measurements you sent around? I guess not?)?",
      "range": {
        "startLine": 791,
        "startChar": 10,
        "endLine": 791,
        "endChar": 27
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72c1d0fe_132dd6d8",
        "filename": "src/ast/ast.h",
        "patchSetId": 3
      },
      "lineNbr": 791,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2017-06-20T18:09:01Z",
      "side": 1,
      "message": "It was actually, the prototype instrumented IterationStatement, JumpStatement, CaseClause, IfStatement. See https://docs.google.com/document/d/1e4HUA6kvmVDXhIoBYawxRetY-vuewDh9GxQepYyX5CI/edit#",
      "parentUuid": "1508c4ee_cc4c632e",
      "range": {
        "startLine": 791,
        "startChar": 10,
        "endLine": 791,
        "endChar": 27
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2c6893a_1afa9c7f",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1256,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2017-06-20T13:52:56Z",
      "side": 1,
      "message": "Where do these get incremented? I thought it would make sense to deal with this in the BreakableControlFlowBuilder (for break) / LoopBuilder (for continue). WDYT?",
      "range": {
        "startLine": 1255,
        "startChar": 2,
        "endLine": 1256,
        "endChar": 53
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3807e9fb_3c0a63e9",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1256,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2017-06-20T14:08:14Z",
      "side": 1,
      "message": "Re 1: I mentioned this in the CL message: \u0027Jumps just allocate a counter, but don\u0027t generate bytecode - code after an unconditional jump is never reached.\u0027\n\nRe 2: Do you mean passing in the continuation range to \n\nexecution_control()-\u003eBreak(stmt-\u003etarget());\n\n(and then possibly all the way down to BreakableControlFlowBuilder::Break)? I\u0027m not sure the code would become cleaner as we\u0027d need to pass the range around, but if you prefer let\u0027s do it that way.",
      "parentUuid": "b2c6893a_1afa9c7f",
      "range": {
        "startLine": 1255,
        "startChar": 2,
        "endLine": 1256,
        "endChar": 53
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "affaea74_15b8f16e",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1256,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2017-06-20T14:56:35Z",
      "side": 1,
      "message": "Re 1: yeah I realized that, but I don\u0027t think we can get a sense of where the allocation should happen without also knowing where the incrementing will happen. Is there any reason you want to land the allocating without the incrementing?\n\nRe 2: I mean doing something similar to the LoopBuilder where the BreakableControlFlowBuilder is in control of allocating slots and incrementing them at the appropriate point, but thinking about this a bit more I don\u0027t think this would work. The main question I have is where the counters get incremented - are they incremented when you hit the Break/Continue? If so can\u0027t we just do that right here alongside the allocation?",
      "parentUuid": "3807e9fb_3c0a63e9",
      "range": {
        "startLine": 1255,
        "startChar": 2,
        "endLine": 1256,
        "endChar": 53
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "337fc144_ee06fc11",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1256,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2017-06-20T18:09:01Z",
      "side": 1,
      "message": "Re 1: The slots for jump statements are not intended to be incremented at all. They show the execution count for the continuation after the jump statement:\n\nif (true) {\n  f();\n  return;\n  g();  // return slot covers this line, count is always 0.\n}\n\nRe 2: Since we\u0027re only allocating, wdyt about keeping the current solution?",
      "parentUuid": "affaea74_15b8f16e",
      "range": {
        "startLine": 1255,
        "startChar": 2,
        "endLine": 1256,
        "endChar": 53
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46e8f98a_b1cecbb2",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1256,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2017-06-21T10:19:58Z",
      "side": 1,
      "message": "The issue that I have with this is that it adds memory overhead and complexity to break/continue/return statement AST nodes:\n - to track something that we know will always be zero\n - that could be determined statically by looking at the source\n - and that shouldn\u0027t really occur in real-world code.\n\nThe last point is the most important to me - do we have any evidence that this will have any benefit to users? Are they shipping code that is dead by definition by being after break/continue/return?",
      "parentUuid": "337fc144_ee06fc11",
      "range": {
        "startLine": 1255,
        "startChar": 2,
        "endLine": 1256,
        "endChar": 53
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b3663bc_9233f70c",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1256,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2017-06-21T11:25:42Z",
      "side": 1,
      "message": "IMHO we should definitely be able to detect and display dead code through block coverage - coverage should be as precise as possible. As a user I\u0027d be very surprised if in the above code example (2 comments up), the call to g() was displayed as having coverage. Safari\u0027s coverage implementation also detects and displays dead code.\n\nRegarding memory overhead: I investigated AST size increases a while ago and the overhead was miniscule on real-world programs (think 0.001%). Slots are only generated when block coverage is enabled through the debugger.\n\nWe could, of course, determine dead source ranges statically, but we either need to store dead ranges somewhere at parse-time (which is basically what the current solution does), or reparse when generating coverage information. I think that reparsing would add a ton of complexity without a clear benefit.",
      "parentUuid": "46e8f98a_b1cecbb2",
      "range": {
        "startLine": 1255,
        "startChar": 2,
        "endLine": 1256,
        "endChar": 53
      },
      "revId": "5f114711665d6dcddbb277c8ee180274e88fbee8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}