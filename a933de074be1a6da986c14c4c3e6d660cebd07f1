{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1fdf446d_85d54f54",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-10T09:02:52Z",
      "side": 1,
      "message": "Could you please have a review?",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ba1e8caa_2fe6fbb2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1118373
      },
      "writtenOn": "2021-03-10T09:08:01Z",
      "side": 1,
      "message": "Wouldn\u0027t this simply break the semantics of structured clone for large object graphs?",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19ca3ad0_602fbe80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2021-03-10T09:24:41Z",
      "side": 1,
      "message": "I would expect it to, plus it could easily blow up the size of the serialized graph if there\u0027s a different microbenchmark with a lot of object duplication.\n\nIdentityMap is a hashtable, so I\u0027m surprised its performance has a dependency on its size?",
      "parentUuid": "ba1e8caa_2fe6fbb2",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c2f3c43_d6854efe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1118373
      },
      "writtenOn": "2021-03-10T09:27:57Z",
      "side": 1,
      "message": "I would have expected that, for large object graphs, creating and keeping a Handle for every graph node is going to cause issues. But this CL doesn\u0027t address that issue.",
      "parentUuid": "19ca3ad0_602fbe80",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d953dc28_61f2a992",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2021-03-10T09:31:01Z",
      "side": 1,
      "message": "there\u0027s HandleScopes scattered around the value serializer, and IdentityMap uses raw object ptrs + synchronisation with GC rather than Handles, so I think that particular concern is fine.",
      "parentUuid": "6c2f3c43_d6854efe",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fccd005_ba7872ae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1118373
      },
      "writtenOn": "2021-03-10T09:41:35Z",
      "side": 1,
      "message": "Might be a bad hash function? The hash function seems to be base::hash. If I\u0027m not reading that wrong, then it just casts the address into an unsigned int, which may not work well for aligned pointers?",
      "parentUuid": "d953dc28_61f2a992",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c50df9f8_46719e70",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2021-03-10T15:08:14Z",
      "side": 1,
      "message": "in principle this also shouldn\u0027t matter, the unsigned int is hashed with a semi-decent hash function after the cast. Hard to say though. Tao Pan, can you share the benchmark?",
      "parentUuid": "6fccd005_ba7872ae",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e1421747_577e07bf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-11T01:29:32Z",
      "side": 1,
      "message": "Thanks for your review comments!",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8db2e7ed_daeb6a2f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-11T01:30:47Z",
      "side": 1,
      "message": "I tested below micro case, in console, \"touch worker.js\" for creating an empty worker.js is necessary, I found ~30% for test 1, ~16% for test 2, ~0% for test 3 improvement with my patch.\n\nfunction PostMessage(x) {\n  var start \u003d performance.now();\n  for (var i \u003d 0; i \u003c 100; i++) {\n    worker.postMessage(x);\n  }\n  console.log(performance.now() - start);\n}\n\nvar array1 \u003d new Array(256*64);\nfor (var i \u003d 0; i \u003c 256 * 64; i++) {\n  array1[i] \u003d {\"a\":1};\n}\n\nvar worker \u003d new Worker(\"worker.js\");\n\n// test 1: 0~63 insert into id map, 64~256*64-1 miss id map\nPostMessage(array1);\n\nvar array2 \u003d new Array(256);\nfor (var i \u003d 0; i \u003c 256; i++) {\n  array2[i] \u003d {\"a\":1};\n}\n\nfor (var i \u003d 0; i \u003c 128; i++) {\n  for (var j \u003d 0; j \u003c 64; j++) {\n    array1[i*64+j] \u003d array2[j];\n  }\n}\n\n// test 2: 0~63 insert into id map, 64~128*64-1 hit id map, 128*64~256*64-1 miss id map\nPostMessage(array1);\n\nfor (var i \u003d 128; i \u003c 256; i++) {\n  for (var j \u003d 0; j \u003c 64; j++) {\n    array1[i*64+j] \u003d array2[j];\n  }\n}\n\n// test 3: 0~63 insert into id map, 64~256*64-1 hit id map\nPostMessage(array1);",
      "parentUuid": "e1421747_577e07bf",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27dcf89b_e602ca88",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-11T02:25:39Z",
      "side": 1,
      "message": "Hash table performance dependency on size is less than linked list and array, but the dependency is existed.\nWhatever hash function, it\u0027s possible two different objects get same hash value, the collision resolution is additional cost, more size increases possibility of collision.",
      "parentUuid": "c50df9f8_46719e70",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cce6b7ce_7495240b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-11T02:29:24Z",
      "side": 1,
      "message": "I think the semantics of structured clone for large object graphs won\u0027t be broken, could you please make a broken example?",
      "parentUuid": "27dcf89b_e602ca88",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6d1ec66_07d405fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-11T02:42:03Z",
      "side": 1,
      "message": "Yes, it could easily blow up the size of the serialized graph if there\u0027s a different microbenchmark with a lot of object duplication. But I think a lot of object duplication is not usual case, my micro case test 2 shows limiting size of id map is faster even half duplicated objects.",
      "parentUuid": "27dcf89b_e602ca88",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f2c2072_e852d303",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2021-03-11T09:13:30Z",
      "side": 1,
      "message": "Sure, broken example:\n\n    // main.js\n    const x \u003d {};\n    const array \u003d [];\n    for (var i \u003d 0; i \u003c 64; i++) {\n      array.push({\"a\":1});\n    }\n    array.push(x);\n    array.push(x);\n    var worker \u003d new Worker(\"worker.js\");\n    worker.postMessage(array);\n\n    // worker.js\n    onmessage \u003d function(array) {\n      console.log(array[64] \u003d\u003d array[65]);\n    }\n\nThis prints true when done correctly, false with your patch.",
      "parentUuid": "a6d1ec66_07d405fd",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8bcac023_506ac6ec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2021-03-12T04:57:09Z",
      "side": 1,
      "message": "Thanks for pointing out the broken example! I understood. I may try to use other method to optimize id map operation.",
      "parentUuid": "8f2c2072_e852d303",
      "revId": "a933de074be1a6da986c14c4c3e6d660cebd07f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}