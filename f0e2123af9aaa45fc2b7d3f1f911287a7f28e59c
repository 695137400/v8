{
  "comments": [
    {
      "key": {
        "uuid": "60aeeb06_41331f4d",
        "filename": "src/heap/cppgc/marker.cc",
        "patchSetId": 11
      },
      "lineNbr": 209,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-15T21:46:44Z",
      "side": 1,
      "message": "Not fully constructed objects are not necessarily still reachable from stack. I\u0027m not sure it\u0027s right to use a StackMarkingVisitor for them.",
      "range": {
        "startLine": 209,
        "startChar": 24,
        "endLine": 209,
        "endChar": 36
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a825f903_d7a5e7c4",
        "filename": "src/heap/cppgc/marker.cc",
        "patchSetId": 11
      },
      "lineNbr": 209,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T13:58:16Z",
      "side": 1,
      "message": "Done: Using marking_visitor_ again.",
      "parentUuid": "60aeeb06_41331f4d",
      "range": {
        "startLine": 209,
        "startChar": 24,
        "endLine": 209,
        "endChar": 36
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4e26d2aa_199b3666",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 27,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-15T21:46:44Z",
      "side": 1,
      "message": "step 2 needs to be implicit only if we don\u0027t have tasks (i.e. we need to manually drain the worklists)",
      "range": {
        "startLine": 27,
        "startChar": 6,
        "endLine": 27,
        "endChar": 32
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99676256_44952c46",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 27,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T13:58:16Z",
      "side": 1,
      "message": "I don\u0027t understand: It\u0027s an optional step which we will have when marking incrementally or concurrently. The statement does not say anything about tasks.",
      "parentUuid": "4e26d2aa_199b3666",
      "range": {
        "startLine": 27,
        "startChar": 6,
        "endLine": 27,
        "endChar": 32
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5e7c6c1_91bb9cba",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 27,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-16T14:52:53Z",
      "side": 1,
      "message": "(downgraded to nit)\nWhat I meant is that I wanted it to be clear to users that if they have tasks they don\u0027t *need* step 2 and can skip it.\nI\u0027m mostly thinking about the standalone library usecase.",
      "parentUuid": "99676256_44952c46",
      "range": {
        "startLine": 27,
        "startChar": 6,
        "endLine": 27,
        "endChar": 32
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "daa9b099_1eac3689",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 27,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T15:05:43Z",
      "side": 1,
      "message": "Added \"[Optional, depending on environment.]\"",
      "parentUuid": "a5e7c6c1_91bb9cba",
      "range": {
        "startLine": 27,
        "startChar": 6,
        "endLine": 27,
        "endChar": 32
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "02074325_5d258440",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-15T21:46:44Z",
      "side": 1,
      "message": "I think steps 3 and 4 can be implicit when calling step 5 (similar to how it currently is with gc finalization in oilpan).\nThis will also make FinishMarkingForTesting redundant.",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c28fa24_db427f0a",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-16T11:31:32Z",
      "side": 1,
      "message": "Looking at the next CL in your chain, I understand why you split FinishMarking to multiple methods.\n\nWhat I recommend is:\n1) Rename FinishMarking to FinishAtomicPause.\n2) FinishMarkingForTesting (now renamed to simply to FinishMarking) will call EnterAtomicPause, AdvanceMarkingWithDeadline, FinishAtomicPause.\n3) EnterAtomicPause, AdvanceMarkingWithDeadline, FinishAtomicPause will be protected methods.\n\nThat way you we still have a simple api for the standalone library and the UnifiedHeapMarker can expose the relevant steps to v8.",
      "parentUuid": "02074325_5d258440",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bfa8f8f2_2f5361a3",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T13:58:16Z",
      "side": 1,
      "message": "\u003e 1) Rename FinishMarking to FinishAtomicPause.\n\nGood point. I did a rename to LeaveAtomicPause, so we have Enter/Leave pairs.\n\n\u003e That way you we still have a simple api for the standalone library and the UnifiedHeapMarker can expose the relevant steps to v8.\n\nThat API does not work as soon as we have incremental marking. Also, for just atomic marking we can have a MarkTransitiveClosure() call that combines StartMarking + FinishMarking.\n\nI kept the methods public to allow combining them freely.\n\nAlternatively, we can make everything protected and have\n- AtomicMarker\n- TestingMarker\n\nand only expose what we need there. AtomicMarker will soon be obsolete though which is why I didn\u0027t use this approach.",
      "parentUuid": "0c28fa24_db427f0a",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb6fa9a5_8ee33514",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T14:43:46Z",
      "side": 1,
      "message": "Actually, the API should work for incremental marking as well. I will ping after changing.",
      "parentUuid": "bfa8f8f2_2f5361a3",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff298499_04002ba0",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-16T14:47:44Z",
      "side": 1,
      "message": "Why wouldn\u0027t it work for incremental marking? If you support tasks, StartMarking should schedule a task and marking will run incrementally until you call FinishMarking.\n\nAtomicMarker will be obsolete for chrome and unified heap, but not necessarily for the standalone library usecase.",
      "parentUuid": "bfa8f8f2_2f5361a3",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b571831_eb82bc75",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T14:47:54Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cb6fa9a5_8ee33514",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56bc8454_709a841d",
        "filename": "src/heap/cppgc/marker.h",
        "patchSetId": 11
      },
      "lineNbr": 28,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-16T14:52:53Z",
      "side": 1,
      "message": "Thanks",
      "parentUuid": "7b571831_eb82bc75",
      "range": {
        "startLine": 28,
        "startChar": 6,
        "endLine": 28,
        "endChar": 22
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "54b82bc4_30372965",
        "filename": "src/heap/cppgc/marking-visitor.h",
        "patchSetId": 11
      },
      "lineNbr": 74,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-15T21:46:44Z",
      "side": 1,
      "message": "I don\u0027t understand why MarkingVisitor and StackMarkingVisitor need to be separate classes.\n(They\u0027re also the same class in oilpan currently)",
      "range": {
        "startLine": 74,
        "startChar": 24,
        "endLine": 74,
        "endChar": 43
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6268793_09574487",
        "filename": "src/heap/cppgc/marking-visitor.h",
        "patchSetId": 11
      },
      "lineNbr": 74,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-06-16T13:58:16Z",
      "side": 1,
      "message": "tl;dr: Redid the visitor trace abstraction.\n\nBlink\u0027s version is far from ideal. It has always bothered me that we cannot get an abstraction for conservative tracing without marking. E.g., it is still not possible to have marking verification for in-construction object and heap snapshots for in-construction objects in Blink.\n\nI initially split into StackMarkingVisitor and MarkingVisitor to get closer into a direction where we split concerns. The split was not what we needed though.\n\nWith the proper TraceConservativelyIfNeeded() method the split now becomes obsolete.",
      "parentUuid": "54b82bc4_30372965",
      "range": {
        "startLine": 74,
        "startChar": 24,
        "endLine": 74,
        "endChar": 43
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "503c721a_538b85b7",
        "filename": "src/heap/cppgc/marking-visitor.h",
        "patchSetId": 11
      },
      "lineNbr": 74,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-06-16T14:47:44Z",
      "side": 1,
      "message": "This is not relevant to this CL, but couldn\u0027t we use the object_start_bitmap to get the object start and relevant TraceDescriptor for in-construction objects and use that for marking verification?",
      "parentUuid": "e6268793_09574487",
      "range": {
        "startLine": 74,
        "startChar": 24,
        "endLine": 74,
        "endChar": 43
      },
      "revId": "f0e2123af9aaa45fc2b7d3f1f911287a7f28e59c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}