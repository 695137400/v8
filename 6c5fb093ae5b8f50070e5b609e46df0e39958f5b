{
  "comments": [
    {
      "key": {
        "uuid": "cf0b4a81_6e2309e2",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3094,
      "author": {
        "id": 1310973
      },
      "writtenOn": "2020-06-30T09:57:42Z",
      "side": 1,
      "message": "We will spill all ranges before the optimal spilling pos later, hence range covering loop start should also cover the direct predecessor, but not necessary others. If pos is within loop header block, shall we simply check whether this range covers loop start? Or would it be simpler to just search from range-\u003eTopLevel()?",
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e094332b_bdeb2eda",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3094,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2020-06-30T16:59:19Z",
      "side": 1,
      "message": "\u003e range covering loop start should also cover the direct predecessor, but not necessarily others\n\nSorry, I don\u0027t think I understand some necessary background information. Do we have a guarantee that the block immediately preceding a loop header block in the RPO is a predecessor of that block?\n\n\u003e If pos is within loop header block, shall we simply check whether this range covers loop start?\n\nI tried this and it doesn\u0027t find the covering range in every case. A range might already have been split within the loop header block. Here is an example in-progress register allocation:\n\n  [-B89--][-B90----------][-B91--------------][-B][-B][-B][-B95--][-B]\n    |r11\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d|unassigned\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nBlock B91 is a loop header. This particular value was originally assigned to r11 at its definition in block B89, but its live range is already split because of a fixed register assignment (there is a call in B91). So the current range (the unassigned part) is not the range covering the loop start (the r11 part).\n\n\u003e Or would it be simpler to just search from range-\u003eTopLevel()?\n\nAbsolutely! I\u0027m not sure if it might also be slower though. I\u0027d be happy to replace all of this with a single call to range-\u003eTopLevel()-\u003eGetChildCovers(loop_start) if everybody thinks it\u0027s okay to; I was assuming that GetChildCovers is too slow here, based on the simple fact that we weren\u0027t already using it ðŸ˜Š. Sigurd, what do you recommend?",
      "parentUuid": "cf0b4a81_6e2309e2",
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3ffaeb5_a666de52",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3094,
      "author": {
        "id": 1345975
      },
      "writtenOn": "2020-07-01T08:58:43Z",
      "side": 1,
      "message": "\u003e I was assuming that GetChildCovers is too slow here, based on the simple fact that we weren\u0027t already using it\nIndeed, I wrote this with performance in mind because the spill state appears to stay small in general compared to the live range chains, but I did not measure the performance impact since both approaches were simple enough.\nBut now that this approach is getting more complex I would be willing to try the \"GetChildCovers\" approach instead, and check that this does not introduce noticeable regressions.",
      "parentUuid": "e094332b_bdeb2eda",
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "009c4b4c_1d7e3735",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3094,
      "author": {
        "id": 1310973
      },
      "writtenOn": "2020-07-01T13:12:54Z",
      "side": 1,
      "message": "\u003e Do we have a guarantee that the block immediately preceding a loop header block in the RPO is a predecessor of that block?\nSorry, there\u0027s no such a garantee. I should mean \"the block immediately preceding a loop header\", not necessary a \"direct predecessor\" actually. :)",
      "parentUuid": "f3ffaeb5_a666de52",
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "951c79d2_8fd1c1fd",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3094,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-01T14:51:08Z",
      "side": 1,
      "message": "As far as performance is concerned, I\u0027m with Thibaud here, it is best to measure.\n\nYou are right Yolanda, as there is no such guarantee. A diamond structure in the CFG, where both middle nodes are loops is an example.\n\nIf I remember correctly, we make an effort to keep loop bodies somewhat consecutive in the RPO (see ComputeAndInsertSpecialRPO).",
      "parentUuid": "009c4b4c_1d7e3735",
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "669034c5_1b51cb6c",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3094,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2020-07-01T16:23:29Z",
      "side": 1,
      "message": "Sounds good, thanks everyone! Updated to use GetChildCovers.",
      "parentUuid": "951c79d2_8fd1c1fd",
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6987844d_72e09a51",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3111,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-01T14:51:08Z",
      "side": 1,
      "message": "Is this saying that if we enter the loop at least once, range_at_loop_start will not be nullptr?",
      "range": {
        "startLine": 3111,
        "startChar": 10,
        "endLine": 3111,
        "endChar": 50
      },
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af688457_cf4e3fca",
        "filename": "src/compiler/backend/register-allocator.cc",
        "patchSetId": 1
      },
      "lineNbr": 3111,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2020-07-01T16:23:29Z",
      "side": 1,
      "message": "Right; I believe this to be guaranteed because LiveRanges are contiguous (even if they might have gaps between the use intervals contained within), and we know that the value is live until at least `pos`. However, this check is not useful; no bad behavior would result if it failed. Marking as resolved because a subsequent patchset removed this code. Thanks!",
      "parentUuid": "6987844d_72e09a51",
      "range": {
        "startLine": 3111,
        "startChar": 10,
        "endLine": 3111,
        "endChar": 50
      },
      "revId": "6c5fb093ae5b8f50070e5b609e46df0e39958f5b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}