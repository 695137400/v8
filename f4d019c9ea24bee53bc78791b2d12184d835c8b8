{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "53b9b379_d605997a",
        "filename": "test/unittests/numbers/conversions-unittest.cc",
        "patchSetId": 19
      },
      "lineNbr": 112,
      "author": {
        "id": 1132654
      },
      "writtenOn": "2021-06-15T13:54:32Z",
      "side": 1,
      "message": "There is also https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER which would be quite interesting.\n\nSee also: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/diagnostics/objects-printer.cc;l\u003d2487;bpv\u003d1;bpt\u003d1?q\u003dkMinSafeInteger",
      "range": {
        "startLine": 112,
        "startChar": 43,
        "endLine": 112,
        "endChar": 64
      },
      "revId": "f4d019c9ea24bee53bc78791b2d12184d835c8b8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20d468b3_26e6e5b5",
        "filename": "test/unittests/numbers/conversions-unittest.cc",
        "patchSetId": 19
      },
      "lineNbr": 112,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2021-06-15T14:33:15Z",
      "side": 1,
      "message": "Good point, thanks! Added such a test.",
      "parentUuid": "53b9b379_d605997a",
      "range": {
        "startLine": 112,
        "startChar": 43,
        "endLine": 112,
        "endChar": 64
      },
      "revId": "f4d019c9ea24bee53bc78791b2d12184d835c8b8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73a32171_8033ab21",
        "filename": "test/unittests/numbers/conversions-unittest.cc",
        "patchSetId": 19
      },
      "lineNbr": 117,
      "author": {
        "id": 1132654
      },
      "writtenOn": "2021-06-15T13:54:32Z",
      "side": 1,
      "message": "this seems a bit odd, I\u0027d expect no overflows when converting, no?",
      "range": {
        "startLine": 116,
        "startChar": 4,
        "endLine": 117,
        "endChar": 40
      },
      "revId": "f4d019c9ea24bee53bc78791b2d12184d835c8b8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "457fecb9_e61a9c00",
        "filename": "test/unittests/numbers/conversions-unittest.cc",
        "patchSetId": 19
      },
      "lineNbr": 117,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2021-06-15T14:33:15Z",
      "side": 1,
      "message": "Indeed, max int64 is not representable as a double, the closest is max int64 + 1 (2^63), which overflows to min int64. I wonder if I should implement a workaround for this in the conversion, e.g. after computing `bits_int64` do something like:\n\n    if (bits_int64 \u003c bits) {   // We have an overflow.\n      return std::numeric_limits\u003cint64_t\u003e::max();\n    }",
      "parentUuid": "73a32171_8033ab21",
      "range": {
        "startLine": 116,
        "startChar": 4,
        "endLine": 117,
        "endChar": 40
      },
      "revId": "f4d019c9ea24bee53bc78791b2d12184d835c8b8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6da97c79_8a497c66",
        "filename": "test/unittests/numbers/conversions-unittest.cc",
        "patchSetId": 19
      },
      "lineNbr": 117,
      "author": {
        "id": 1132654
      },
      "writtenOn": "2021-06-22T07:33:44Z",
      "side": 1,
      "message": "I guess we should keep the behavior the same as ToInt32 in the spec https://tc39.es/ecma262/#sec-toint32 (see comment above)",
      "parentUuid": "457fecb9_e61a9c00",
      "range": {
        "startLine": 116,
        "startChar": 4,
        "endLine": 117,
        "endChar": 40
      },
      "revId": "f4d019c9ea24bee53bc78791b2d12184d835c8b8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}