{
  "comments": [
    {
      "key": {
        "uuid": "b006daa6_61395774",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1158954
      },
      "writtenOn": "2019-04-23T03:58:16Z",
      "side": 1,
      "message": "Why do we need an initializer scope for private methods/accessors?",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2add4b07_b6526b4d",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2019-04-23T10:48:07Z",
      "side": 1,
      "message": "The private fields also share this scope in the initializer, when parsing properties we do not know whether there will be private fields later, so I think we might as well just create one for the initializer function? (Or otherwise the instance initializer scope would be different depending on whether all the private members are methods/accessors, I am not sure if that is safe).",
      "parentUuid": "b006daa6_61395774",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a7fb286_e9846802",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1158954
      },
      "writtenOn": "2019-04-23T22:03:18Z",
      "side": 1,
      "message": "But the field isn\u0027t parsed in this scope, only the initializer is. We start this initializer scope only after the `\u003d` at which point we know if it\u0027s a field or not.\n\n\u003e Or otherwise the instance initializer scope would be different depending on whether all the private members are methods/accessors, I am not sure if that is safe\n\nWhy isn\u0027t this safe?",
      "parentUuid": "2add4b07_b6526b4d",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86e9e1b4_cc1ce813",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2019-04-23T23:12:26Z",
      "side": 1,
      "message": "\u003e Why isn\u0027t this safe?\n\nParser::RewriteClassLiteral() currently expects that `class_info-\u003ehas_instance_members` implies `class_info-\u003einstance_members_scope !\u003d nullptr`:\n\nhttps://cs.chromium.org/chromium/src/v8/src/parsing/parser.cc?q\u003dRewriteClassLiteral\u0026sq\u003dpackage:chromium\u0026g\u003d0\u0026l\u003d2916\nhttps://cs.chromium.org/chromium/src/v8/src/parsing/parser.cc?q\u003dRewriteClassLiteral\u0026sq\u003dpackage:chromium\u0026g\u003d0\u0026l\u003d2865\n\nIf it is a nullptr, e.g. for `class A { #fn(){} }`, what should the scope for the initializer function?\n\nI think the word initializer is ambiguous here, it\u0027s not the initializer of a single field (the part after \u003d), but the instance_members_initializer that initializes all the fields as well as the brand?",
      "parentUuid": "2a7fb286_e9846802",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cdc97234_b62ab628",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1158954
      },
      "writtenOn": "2019-04-24T04:53:45Z",
      "side": 1,
      "message": "(a) Why do we need an initializer function for `class A { #fn() {} }`? I think we should not create an initializer function here at all. You can just install the brand directly in VisitCallSuper and GenerateBytecodeBody. Maybe Ross has thoughts on this? \n\n\n(b) Why do we need to pass in ClassScope to InitializeClassMembersStatement? Isn\u0027t current_scope()-\u003eGetClassScope() enough?",
      "parentUuid": "86e9e1b4_cc1ce813",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "114b8d88_5e9d3050",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2019-04-24T07:47:52Z",
      "side": 1,
      "message": "\u003e Why do we need an initializer function for `class A { #fn() {} }`? I think we should not create an initializer function here at all. You can just install the brand directly in VisitCallSuper and GenerateBytecodeBody.\n\nYeah, we probably don\u0027t need to do this in the initializer function but can instead just inline this in the constructor. We should be able to just add something in BuildInstanceMemberInitialization() before loading and calling the initializer function.",
      "parentUuid": "cdc97234_b62ab628",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbe25500_cb2e2f92",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 18
      },
      "lineNbr": 2247,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2019-04-29T09:02:54Z",
      "side": 1,
      "message": "The AddPrivateBrand calls are now done in the constructor, and I\u0027ve removed the class scope in InitializeClassMembersStatement",
      "parentUuid": "114b8d88_5e9d3050",
      "revId": "d1f5a7e0c03688def02e5ae401eb15f8ddc390f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}