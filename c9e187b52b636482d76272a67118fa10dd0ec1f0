{
  "comments": [
    {
      "key": {
        "uuid": "da470f47_d228f579",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2019-01-22T16:09:25Z",
      "side": 1,
      "message": "Why not use a standard stringstream and return an std::string instead, wdyt?",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad0b8659_69b2496e",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1324852
      },
      "writtenOn": "2019-01-22T17:52:29Z",
      "side": 1,
      "message": "The reason is simply to avoid the expense of extra allocation (which you mentioned in the bug description). Here we get the best tradeoff out of correctness and performance - for short format outputs (\u003c 128 bytes) we use stack space (as before), for long ones we reallocate data on the heap.",
      "parentUuid": "da470f47_d228f579",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b60dfcb5_dd9c85e3",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2019-01-23T15:50:47Z",
      "side": 1,
      "message": "Without benchmarks to show the perf benefit of this, I don\u0027t think it makes sense to add the complexity of the SSOAllocator + DateBuffer. \n\nDo you have any measurements that show this is worthwhile? Otherwise I think we should go with a simple stringstream solution first.",
      "parentUuid": "ad0b8659_69b2496e",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "826f6cd0_c121c59b",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1324852
      },
      "writtenOn": "2019-01-23T20:17:33Z",
      "side": 1,
      "message": "Jakob, thanks for the comment.\nI don\u0027t generally agree with the complexity introduced by SSOAllocator (due to the well-designed DI nature of StringStream-\u003eStringAllocator). I tend to find the concept quite useful and see potential for it to be used in other places as well (e.g. in object printers).\nNevertheless, I respect the idea of not trusting the internal voice and benchmarking own assumptions. For this particular problem I decided to not use some fancy perf-things, but just use perf stat (or, equally, time util). Here are the results of the measurements: goo.gl/JYmW9v (sorry, don\u0027t know what is preferred way to post links to code).\nI\u0027ve run the tests multiple times and the numbers are pretty much stable. So for short strings (\u003c128 bytes) the gain is over 1.7x, for longer strings the results are very close.\nOne of the reasons why std::stringstream might be slow is that there is no standard way to preallocate data in the underlying stringbuf (as opposed to, for example, boost::asio::streambuf). I think this idea might be a good candidate to go to a proposal for LWG. Another optimization that might be proposed is a separate ref-qualifed overload for xvalue stringstream objects, i.e.:\n std::basic_string\u003cCharT,Traits,Allocator\u003e str() \u0026\u0026 noexcept;\nthat would be able to move the underlying string, leaving the stringstream in unspecified state.",
      "parentUuid": "b60dfcb5_dd9c85e3",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e69430a_069b861b",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2019-01-24T10:25:24Z",
      "side": 1,
      "message": "Ack, thanks for checking. I ran your microbenchmark locally:\n\nmaster: 894.719500 +- 15.149839 (lower is better)\nwith small vector: 1387.142000 +- 28.657007\nstringstream: 2218.576500 +- 53.225148\n\nInteresting that these changes have such visible impact. Do we know why your current solution is so much slower than the stack-allocated char array + SNPrintF?\n\nI don\u0027t doubt the perf benefit, my concern was mainly code complexity vs. actual benefit here. My impression was that date builtins aren\u0027t particularly perf-critical and thus I\u0027d usually prioritize simplicity over performance. But given that both Jakob and Clemens like this, Clemens mentioned possible reuses of this mechanism in wasm, plus the perf results above, I\u0027m convinced :)",
      "parentUuid": "826f6cd0_c121c59b",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c63e342f_dfc70a21",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2019-01-24T10:41:20Z",
      "side": 1,
      "message": "Regarding the performance impact: StringStream is implemented very poorly. {StringStream::Add} calls {StringStream::Put} for each single character, hence does a bounds check for each single character. It also calls {Add} recursively. We could probably optimize this a bit if performance really matters (not in this CL of course).",
      "parentUuid": "4e69430a_069b861b",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f77ac5d2_4c554277",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 156,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2019-01-24T10:02:20Z",
      "side": 1,
      "message": "I think we should truncate the buffer here, such that it really only contains the string. Currently it contains the null-terminated string plus additional uninitialized bytes.\nThis would also avoid the need to use \"CStrVector\" below. Just use \"VectorOf\".",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ebaee626_39bc8b0d",
        "filename": "src/builtins/builtins-date.cc",
        "patchSetId": 1
      },
      "lineNbr": 156,
      "author": {
        "id": 1324852
      },
      "writtenOn": "2019-01-24T15:26:19Z",
      "side": 1,
      "message": "Thanks for the suggestion. If I understood you correctly, to use VectorOf we would have to truncate the buffer on all escape paths by calling\n buffer.resize(StrLength(buffer.data()))\nwhich I\u0027m not sure is the better alternative. On the other hand I don\u0027t like meaningless .size() function either..",
      "parentUuid": "f77ac5d2_4c554277",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1fab57d8_5a3e9c92",
        "filename": "src/string-stream.h",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2019-01-24T10:25:24Z",
      "side": 1,
      "message": "nit: SmallStringOptimizedAllocator, and then we can remove the comment above.",
      "revId": "c9e187b52b636482d76272a67118fa10dd0ec1f0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}