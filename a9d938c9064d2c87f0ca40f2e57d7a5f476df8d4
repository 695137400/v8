{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0bd07259_04ad76a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-04-22T13:30:44Z",
      "side": 1,
      "message": "ptal",
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1739652e_864d3972",
        "filename": "src/heap/cppgc-js/cpp-heap.cc",
        "patchSetId": 2
      },
      "lineNbr": 601,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-04-22T14:26:06Z",
      "side": 1,
      "message": "I assume this was meant for restarting parallel marking, and I\u0027m not sure it will work.\nIf concurrent marker are not running currently, it means they ran out of work. Calling this method should eventually trigger the jobs api to call `ConcurrentMarkingTask::GetMaxConcurrency` to query how many tasks it can support. Since there is no work left, `GetMaxConcurrency` will return 0.\nWe need to seed the worklists with some work before we start concurrent markers.\nEither we assume (\u003dhope) they are still running since we started them at the start of the atomic pause after scanning roots and stack, or we need to periodically restart them within `AdvanceMarkingWithLimits` (since that one will run until it\u0027s out of work as well).",
      "range": {
        "startLine": 601,
        "startChar": 13,
        "endLine": 601,
        "endChar": 50
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86927c47_92cdde0c",
        "filename": "src/heap/cppgc-js/cpp-heap.cc",
        "patchSetId": 2
      },
      "lineNbr": 601,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-04-22T14:50:54Z",
      "side": 1,
      "message": "`AdvanceTracing()` is called repeatedly by V8 after processing objects on the JS side. I have verified locally that this sometimes finds non-empty worklists and then notifies concurrent markers.\n\nNote that concurrent markers are not really restarted (as they never were `Join()ed` but we rather set a new `GetMaxConcurrency()` and wake them up.",
      "parentUuid": "1739652e_864d3972",
      "range": {
        "startLine": 601,
        "startChar": 13,
        "endLine": 601,
        "endChar": 50
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ddf1de0_7cb82c38",
        "filename": "src/heap/cppgc-js/cpp-heap.cc",
        "patchSetId": 2
      },
      "lineNbr": 601,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-04-22T15:13:07Z",
      "side": 1,
      "message": "Ack.\n\nAfter each call to `AdvanceTracing`, Oilpan\u0027s worklists would be empty. HWe may find non-empty worklists here, but only if V8 found new references to Oilpan objects. I wonder how many such references we actually have (I assume not many by the time we reach the atomic pause).",
      "parentUuid": "86927c47_92cdde0c",
      "range": {
        "startLine": 601,
        "startChar": 13,
        "endLine": 601,
        "endChar": 50
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3a7bbf9_47be24c9",
        "filename": "src/heap/cppgc-js/cpp-heap.cc",
        "patchSetId": 2
      },
      "lineNbr": 601,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-04-22T15:21:05Z",
      "side": 1,
      "message": "The better concurrent marking was working (and did have enough time), the less likely it is that we find anything useful.\n\nOn my tries with a custom Chrome build it mostly hit once per atomic pause but not more. Even when we notified the markers, the main thread was most of the time fast enough.",
      "parentUuid": "0ddf1de0_7cb82c38",
      "range": {
        "startLine": 601,
        "startChar": 13,
        "endLine": 601,
        "endChar": 50
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ebe732c4_12f4b74f",
        "filename": "src/heap/cppgc/concurrent-marker.cc",
        "patchSetId": 2
      },
      "lineNbr": 243,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-04-22T14:26:06Z",
      "side": 1,
      "message": "Are we assuming the current priority is `kBestEffort`?\nIf that\u0027s the case then this assumption doesn\u0027t hold. We initialize tasks to `kUserVisible` and increase to `kUserBlocking` in `ConcurrentMarkerBase::IncreaseMarkingPriorityIfNeeded` if not enough progress has been made.\n\nIf this branch was meant as a fast bailout in case there is nothing to update, I think we need to keep track of the current priority and compare against that.",
      "range": {
        "startLine": 243,
        "startChar": 20,
        "endLine": 243,
        "endChar": 52
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1707c56f_245c0b8a",
        "filename": "src/heap/cppgc/concurrent-marker.cc",
        "patchSetId": 2
      },
      "lineNbr": 243,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-04-22T15:21:05Z",
      "side": 1,
      "message": "\u003e If this branch was meant as a fast bailout in case there is nothing to update, I think we need to keep track of the current priority and compare against that.\n\nI wanted a bailout but didn\u0027t really consider the default value. I think it\u0027s okay to just override no matter what.",
      "parentUuid": "ebe732c4_12f4b74f",
      "range": {
        "startLine": 243,
        "startChar": 20,
        "endLine": 243,
        "endChar": 52
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "efe3b75e_d7857841",
        "filename": "src/heap/cppgc/concurrent-marker.cc",
        "patchSetId": 2
      },
      "lineNbr": 243,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-04-22T15:48:19Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "1707c56f_245c0b8a",
      "range": {
        "startLine": 243,
        "startChar": 20,
        "endLine": 243,
        "endChar": 52
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f658644_8445c02c",
        "filename": "src/heap/mark-compact.cc",
        "patchSetId": 2
      },
      "lineNbr": 2397,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-04-22T14:26:06Z",
      "side": 1,
      "message": "`ProcessEphemeronMarking` implicitly triggers wrapper tracing and drains the worklist, which I found confusing. Can we rename this method to something like `PerformTransitiveClosure` or something like that?\nAt the very least, I think we need to better document what\u0027s going on here (e.g. `ProcessEphemeronMarking` calls  `ProcessEphemeronsUntilFixpoint` which calls `PerformWrapperTracing` for Oilpan tracing, but then calls `ProcessEphemerons` which delegates to `ProcessMarkingWorklist` for V8 marking; It\u0027s quite convoluted).\n\n(btw, is `DrainMarkingWorklist` still used? `ProcessEphemeronMarking` calls `ProcessMarkingWorklist(0)` explicitly)",
      "range": {
        "startLine": 2397,
        "startChar": 4,
        "endLine": 2397,
        "endChar": 27
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "052fbea9_6eeb6199",
        "filename": "src/heap/mark-compact.cc",
        "patchSetId": 2
      },
      "lineNbr": 2397,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-04-22T14:50:54Z",
      "side": 1,
      "message": "It\u0027s really processing the whole transitive closure and I already had a rename in place but reverted and wanted to ask on the CL here :) \n\nDominik, wdyt about `PerformTransitiveClosure` or `MarkTransitiveClosure()`?",
      "parentUuid": "8f658644_8445c02c",
      "range": {
        "startLine": 2397,
        "startChar": 4,
        "endLine": 2397,
        "endChar": 27
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2bffb08_b120111f",
        "filename": "src/heap/mark-compact.cc",
        "patchSetId": 2
      },
      "lineNbr": 2397,
      "author": {
        "id": 1357035
      },
      "writtenOn": "2022-04-25T14:43:34Z",
      "side": 1,
      "message": "Both sound good to me. I mean the parallel phase might not get the \"full\" transitive closure but I guess it\u0027s still the best way to describe what\u0027s happening.\n\n`ProcessEphemerons` seems like the most confusing method indeed. I guess we could rename it somehow but it would be cool if we could refactor it to perform something like this on the high-level in its loop:\n\n```\nPerformWrapperTracing();\nApplyEphemeronSemantics();\nDrainMarkingWorklist();\n```\n\nObviously not something to do for this CL, I am not even sure whether this is correct.",
      "parentUuid": "052fbea9_6eeb6199",
      "range": {
        "startLine": 2397,
        "startChar": 4,
        "endLine": 2397,
        "endChar": 27
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "524e82de_3351883b",
        "filename": "src/heap/mark-compact.cc",
        "patchSetId": 2
      },
      "lineNbr": 2397,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-04-28T09:11:02Z",
      "side": 1,
      "message": "I renamed:\n- `ProcessEphemeronMarking` -\u003e `MarkTransitiveClosure`\n- `ProcessEphemeronsLinear` -\u003e `MarkTransitiveClosureLinear`\n- `ProcessEphemeronsUntilFixpoint` -\u003e `MarkTransitiveClosureUntilFixpoint`\n\nAs Dominik noticed, there\u0027s still inconsistencies on the lower level (`ProcessEphemerons`) left to refactor.",
      "parentUuid": "d2bffb08_b120111f",
      "range": {
        "startLine": 2397,
        "startChar": 4,
        "endLine": 2397,
        "endChar": 27
      },
      "revId": "a9d938c9064d2c87f0ca40f2e57d7a5f476df8d4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}