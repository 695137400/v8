{
  "comments": [
    {
      "key": {
        "uuid": "878b03bf_5afd2b07",
        "filename": "src/compiler/backend/arm64/instruction-selector-arm64.cc",
        "patchSetId": 4
      },
      "lineNbr": 163,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2020-02-18T10:34:16Z",
      "side": 1,
      "message": "Do we also need to make sure the immediate is in range of the width in the non-zero case? If the SIMD semantics for shifts is to wrap around, I guess we can do a `modulo width` as well. \n\nOtherwise we might hit one of those assertions: https://source.chromium.org/chromium/v8/v8.git/+/0439220c36237e894cbadc61948d051813d9f2db:src/codegen/arm64/assembler-arm64.cc;l\u003d1586",
      "revId": "b45a1064411c4a5aeb8a5658879eb549ec6e5e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da101981_6123b545",
        "filename": "src/compiler/backend/arm64/instruction-selector-arm64.cc",
        "patchSetId": 4
      },
      "lineNbr": 163,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2020-02-18T10:52:28Z",
      "side": 1,
      "message": "Looking into this a little more, it might be good to extend the tests to cover out-of-range immediate shifts to check that the backend generates code that wraps around: https://source.chromium.org/chromium/v8/v8.git/+/0439220c36237e894cbadc61948d051813d9f2db:test/cctest/wasm/test-run-wasm-simd.cc;l\u003d1945",
      "parentUuid": "878b03bf_5afd2b07",
      "revId": "b45a1064411c4a5aeb8a5658879eb549ec6e5e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c93b673_305a2c0e",
        "filename": "src/compiler/backend/arm64/instruction-selector-arm64.cc",
        "patchSetId": 4
      },
      "lineNbr": 163,
      "author": {
        "id": 1249724
      },
      "writtenOn": "2020-02-18T15:23:02Z",
      "side": 1,
      "message": "We made sure that the immediate is in the rage of the width in the code-gen, by using `i.InputInt##width(1)`, where width matches the lane sizes, so 64x2 has width 6, 32x4 has width 5, etc..., so the shift value is taken modulo width.\n\nThe test code does check out of range immediate shift, e.g. for 32x4 it shifts by 32, which should be a no-op. Perhaps we add 1 more to the test shift value. Good suggestion, I can make this change in a follow-up.",
      "parentUuid": "da101981_6123b545",
      "revId": "b45a1064411c4a5aeb8a5658879eb549ec6e5e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab3034b0_af0b25a7",
        "filename": "src/compiler/backend/arm64/instruction-selector-arm64.cc",
        "patchSetId": 4
      },
      "lineNbr": 163,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2020-02-18T15:47:22Z",
      "side": 1,
      "message": "\u003e We made sure that the immediate is in the rage of the width in the code-gen, by using `i.InputInt##width(1)`, where width matches the lane sizes, so 64x2 has width 6, 32x4 has width 5, etc..., so the shift value is taken modulo width.\n\nAh I missed that, sorry! Perfect then :-)",
      "parentUuid": "5c93b673_305a2c0e",
      "revId": "b45a1064411c4a5aeb8a5658879eb549ec6e5e25",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}