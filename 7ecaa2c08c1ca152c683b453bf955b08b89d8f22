{
  "comments": [
    {
      "key": {
        "uuid": "ce3626cf_c3323781",
        "filename": "src/arm64/cpu-arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2019-02-28T11:27:12Z",
      "side": 1,
      "message": "Isn\u0027t this redundant with `V8_HOST_ARCH_ARM64`? As in that if the host is not Arm64 (windows or linux) then `USE_SIMULATOR` should be on anyway. Did you consider adding the `V8_OS_WIN` condition inside `V8_HOST_ARCH_ARM64`?\n\nAs in:\n\n#if defined(V8_HOST_ARCH_ARM64)\n#if defined(V8_OS_WIN)\n  ::FlushInstructionCache(GetCurrentProcess(), address, length);\n#else\n  // The code below assumes user space cache operations are allowed. The goal\n  // of this routine is to make sure the code generated is visible to the I\n  // side of the CPU.\n  \n  ...\n#endif\n#endif\n\n\nThen we wouldn\u0027t need to check the `USE_SIMULATOR` macro.",
      "revId": "7ecaa2c08c1ca152c683b453bf955b08b89d8f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f84e0d50_f093814d",
        "filename": "src/arm64/cpu-arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1307249
      },
      "writtenOn": "2019-02-28T18:27:18Z",
      "side": 1,
      "message": "Thanks for the catch, Pierre. Yes, `!USE_SIMULATOR` and `V8_HOST_ARCH_ARM64` look the same.\n\nTo remove the redundant check, would use `!USE_SIMULATOR` be more consistent as it is used in above `CacheLineSizes` class and also in other V8 backend (arm, mips). Furthermore, `!USE_SIMULATOR` could potentially enable the scenario to test V8 with arm64 simulator even running on arm64.",
      "parentUuid": "ce3626cf_c3323781",
      "revId": "7ecaa2c08c1ca152c683b453bf955b08b89d8f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "398cc81b_d51444f8",
        "filename": "src/arm64/cpu-arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2019-02-28T19:18:44Z",
      "side": 1,
      "message": "That\u0027s a good point, I think we may want to do this in the future since the Arm64 simulator is really helpful for debugging. It can generate traces of all code that it\u0027s executing, record register changes, give you a shell if it sees a break instruction, ...etc. So somebody working on V8 using an Arm64 workstation might want to use the simulator anyway.\n\nHowever, the more I think about this method the more I think it shouldn\u0027t be simulator specific, it should only depend on the host architecture. And when looking closer, `CpuFeatures::FlushICache()` isn\u0027t actually called to flush code objects when you have a simulator build, see https://cs.chromium.org/chromium/src/v8/src/flush-instruction-cache.cc?sq\u003dpackage:chromium\u0026g\u003d0\u0026l\u003d18, so I think it makes more sense to use `V8_HOST_ARCH_ARM64` here instead.\n\nWhat do you think?",
      "parentUuid": "f84e0d50_f093814d",
      "revId": "7ecaa2c08c1ca152c683b453bf955b08b89d8f22",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}