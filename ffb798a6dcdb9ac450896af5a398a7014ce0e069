{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e13cfdaa_1c0dde82",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-08-08T11:19:30Z",
      "side": 1,
      "message": "How do you know the global value hasn\u0027t changed?",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e37a3899_338efa0e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-08-08T15:14:03Z",
      "side": 1,
      "message": "I\u0027m not very clear about which case you mean here, do you mean that like this:\n```\nLdarGlobal [1]\nStar0\nMov r0 [someting]\nLdarGlobal [1]\nStar1\nAdd r1\n```\nIn this case, IIUC, I suppose we can just modify the pointer in local scope, or modify the content which this pointer point to, but not the pointer outside of this scope.\nIn other side, I build the map between Variable* and accumulator, so we just do the bytecode elidation for the same Variable*, is my understand correct?",
      "parentUuid": "e13cfdaa_1c0dde82",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b9e1a5e_d7ce8406",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-08-09T09:10:08Z",
      "side": 1,
      "message": "What I mean is something like \n\n```\nLdarGlobal [1]\nStar0\n[call something with side effects that mutate the global]\nLdarGlobal [1]\nStar0\nAdd r0\n```",
      "parentUuid": "e37a3899_338efa0e",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4683493a_a0c2cf10",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-08-09T09:17:15Z",
      "side": 1,
      "message": "Or worse, a global property with side-effects, like:\n\n```\nObject.defineProperty(globalThis, \u0027foo\u0027, {\n  get() {\n    console.log(\u0027get foo()\u0027)\n    return 5;\n  }\n});\n\n(function bar() {\n  foo;\n  foo;\n})();\n```",
      "parentUuid": "4b9e1a5e_d7ce8406",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b213a88_bd13f922",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-08-09T11:08:33Z",
      "side": 1,
      "message": "Thanks for your reminder! You are exactly right, in that case we can\u0027t elide this LdaGlobal, but I suppose we could limit this optimization just for context load, like `LdaImmutableCurrentContextSlot`, they may not bring side effect, is it correct?",
      "parentUuid": "4683493a_a0c2cf10",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca8407a7_f10b413e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-08-09T11:14:56Z",
      "side": 1,
      "message": "I believe this is correct, yes, context loads can\u0027t have side effects and immutable context slots can\u0027t be mutated by side effects.",
      "parentUuid": "1b213a88_bd13f922",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33e6ccf9_6e2daa67",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-08-09T11:45:08Z",
      "side": 1,
      "message": "I limit this optimization just working for elide redundant load context bytecode now, PTAL, thanks!",
      "parentUuid": "ca8407a7_f10b413e",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6776fe9_5ce2cc6d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 18,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-08-13T01:08:31Z",
      "side": 1,
      "message": "I believe `LdaImmutableCurrentContextSlot` loads can be elided because immutable slots are never assigned to, and thus immutable. Why are mutable context loads correct to elide?\n\nHow do you know a side effect hasn\u0027t mutated the value of a mutable context slot? Is it because anything that would assign to a context slot would clobber the equivalence id of the accumulator?",
      "parentUuid": "33e6ccf9_6e2daa67",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 18,
        "endChar": 53
      },
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "089fc9a3_b4caa566",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-08-08T11:14:52Z",
      "side": 1,
      "message": "Hi Leszek,\nWe found there are some load redundant bytecodes in some case, now we add a  mechanism to build a map relation between accumulator and Variale , which can help us to identify whether there is a really requirements to load a variable in accumulator and allocate a new register for it.\nIn Web Tooling, I found there is about 400 funtions have this pattern in this CL, and I add a JS code case in previous comment, PTAL, thanks!",
      "revId": "ffb798a6dcdb9ac450896af5a398a7014ce0e069",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}