{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f5ffd180_81014036",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115935
      },
      "writtenOn": "2022-07-01T17:29:12Z",
      "side": 1,
      "message": "LGTM.\n\nMy only question would be whether there really is a requirement to store a different error message for each `Context`; otherwise you could also store a single `std::string` somewhere off-heap (e.g. on the `Isolate`), which would make things easier.\nBut for consistency with `ErrorMessageForCodeGenerationFromStrings` alone this is OK as-is.",
      "revId": "17af7f421e24c6ef23909ad34b859ab51dceca89",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c79708b9_ddd9b547",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2022-07-04T08:48:23Z",
      "side": 1,
      "message": "+1 on this. Couldn\u0027t we dynamically ask the embedder to provide us the reason rather than creating the string up-front? If eval/compilation is disallowed, it will likely not happen, so string creation is simply memory / load-time overhead?\n\nFor this CL this seems fine as it follows what we already do for JS, but the API doesn\u0027t seem ideal.",
      "parentUuid": "f5ffd180_81014036",
      "revId": "17af7f421e24c6ef23909ad34b859ab51dceca89",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa5404ae_fc6039ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1547432
      },
      "writtenOn": "2022-07-04T13:26:14Z",
      "side": 1,
      "message": "I am actually surprised that `wasm` implementation for CSP checking is different than the JS implementation. It seems that ultimately, the `wasm` part is making a call to `CSP` every time it needs to make the check, whereas the JS implementation ultimately stores a boolean dynamically.\n\nWhat this means is that it seems that we\u0027re eventually paying the cost you\u0027re mentioning not only when code generation is not allowed, but every time we need to know whether it is or not. I am not sure how much performance matters here, but I am wondering if we\u0027d better unify the implementations here?",
      "parentUuid": "c79708b9_ddd9b547",
      "revId": "17af7f421e24c6ef23909ad34b859ab51dceca89",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "65564ca3_58cddb26",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2022-07-04T13:30:47Z",
      "side": 1,
      "message": "The performance of checking for JS iirc was crucial due to eval-heavy benchmarks (looking at you, sunspider). I\u0027m not sure we have the same problem with wasm. But unifying sounds good to me.\n\nThe initial cost of computing the string isn\u0027t measured by those benchmarks though, but imposes a small cost on context startup. If you\u0027re going to look into doing all of this a little better, it would be nice if we could avoid that.",
      "parentUuid": "aa5404ae_fc6039ff",
      "revId": "17af7f421e24c6ef23909ad34b859ab51dceca89",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}