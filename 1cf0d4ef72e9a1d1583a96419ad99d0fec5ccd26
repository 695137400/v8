{
  "comments": [
    {
      "key": {
        "uuid": "e8e95f7e_5974c0f4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-10-01T11:17:33Z",
      "side": 1,
      "message": "Georg PTAL. This is a case similar to what we had with CallHandlerInfo (https://chromium-review.googlesource.com/c/v8/v8/+/2435096).\n\nPS: TSAN bot is already red on ToT. No new failures.",
      "revId": "1cf0d4ef72e9a1d1583a96419ad99d0fec5ccd26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "976e417b_d72a583a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-10-01T11:27:37Z",
      "side": 1,
      "message": "Hi Santiago,\n\nI think this doesn\u0027t work because the field is mutable. Concretely what could happen is that the import_meta field might still be the-hole when serializing, but while we are compiling in the background it gets set to some JSObject and then we might see that JSObject in JSContextSpecialization.",
      "revId": "1cf0d4ef72e9a1d1583a96419ad99d0fec5ccd26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ff3f56d_0ee9f2ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-10-01T11:54:30Z",
      "side": 1,
      "message": "Ack. Abandoning.\nOut of curiosity, what would happen if we serialized it with the_hole and then it is changed to a JSObject in the background. Could we finish compiling?",
      "parentUuid": "976e417b_d72a583a",
      "revId": "1cf0d4ef72e9a1d1583a96419ad99d0fec5ccd26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1e6ca76e_eee7c6dc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-10-01T14:17:17Z",
      "side": 1,
      "message": "We would fail a CHECK when trying to create the Ref for that Object.\n\nWe could theoretically change the code to skip the optimization instead of aborting in that case.",
      "parentUuid": "6ff3f56d_0ee9f2ab",
      "revId": "1cf0d4ef72e9a1d1583a96419ad99d0fec5ccd26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8796a731_a0e0e9d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-10-01T15:22:49Z",
      "side": 1,
      "message": "Let me rephrase the question: What would happen right now on tip of tree if we serialized it with the_hole and then it is changed to a JSObject in the background? Could we finish compiling even when the serialized import_meta is not reflective of the actual import_meta?",
      "parentUuid": "1e6ca76e_eee7c6dc",
      "revId": "1cf0d4ef72e9a1d1583a96419ad99d0fec5ccd26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6781af73_d083fd1c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-10-01T15:26:53Z",
      "side": 1,
      "message": "On tip of tree with concurrent inlining on we would finish compiling but would not perform the optimization, i.e. the generated code would call into the runtime to load the import-meta object.",
      "parentUuid": "8796a731_a0e0e9d1",
      "revId": "1cf0d4ef72e9a1d1583a96419ad99d0fec5ccd26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}