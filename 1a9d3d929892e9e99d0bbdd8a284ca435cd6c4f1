{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0f307b2f_7e86fe80",
        "filename": "src/common/code-memory-access.h",
        "patchSetId": 29
      },
      "lineNbr": 49,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-07-19T11:49:35Z",
      "side": 1,
      "message": "For RwxMemoryWriteScopeForTesting default constructor.",
      "range": {
        "startLine": 49,
        "startChar": 21,
        "endLine": 49,
        "endChar": 39
      },
      "revId": "1a9d3d929892e9e99d0bbdd8a284ca435cd6c4f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b0faf56_4b720ce1",
        "filename": "src/wasm/wasm-code-manager.cc",
        "patchSetId": 29
      },
      "lineNbr": 1946,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-07-19T11:49:35Z",
      "side": 1,
      "message": "We have to use base::MemoryProtectionKey::SetPermissionsAndKey() here, because I suppose it may not be a very good way to add such a wrapped API in RwxMemoryWriteScope to bind PKU to a chunck of memory. \nWe could bind PKU in the follow up PKU CL for v8 heap in PageAllocator::AllocatePages() in src/base/page-allocator.cc by checking the memory permission with kNoAccessWillJitLater, MAP_JIT for Apple Silicon also did this in similar way.",
      "range": {
        "startLine": 1946,
        "startChar": 13,
        "endLine": 1946,
        "endChar": 61
      },
      "revId": "1a9d3d929892e9e99d0bbdd8a284ca435cd6c4f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f43f2ab_a50a8b4c",
        "filename": "src/wasm/wasm-code-manager.cc",
        "patchSetId": 29
      },
      "lineNbr": 2174,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-07-19T11:49:35Z",
      "side": 1,
      "message": "We could use PageAllocator::kNoAccessWillJitLater in follow up CL, which can bind PKU to this chunck of memory.",
      "range": {
        "startLine": 2174,
        "startChar": 33,
        "endLine": 2174,
        "endChar": 57
      },
      "revId": "1a9d3d929892e9e99d0bbdd8a284ca435cd6c4f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbd1e60f_bd4c2ad7",
        "filename": "src/wasm/wasm-code-manager.cc",
        "patchSetId": 29
      },
      "lineNbr": 2188,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-07-19T11:49:35Z",
      "side": 1,
      "message": "If we use PageAllocator::kNoAccessWillJitLater permission in above AllocatePages() invoke(bin PKU), here we could use base::OS::SetPermissions() to set permission as kReadWrite. Follow this control flow, we could bind PKU to the memory first, then we could withdraw execution permission.",
      "range": {
        "startLine": 2186,
        "startChar": 10,
        "endLine": 2188,
        "endChar": 53
      },
      "revId": "1a9d3d929892e9e99d0bbdd8a284ca435cd6c4f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}