{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e8b0c30f_d2365f0d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 37
      },
      "lineNbr": 0,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T18:06:30Z",
      "side": 1,
      "message": "Added the code to deal with Isolate and realm termination (thinking about iframes), please take a look.",
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc137267_72ee5a5d",
        "filename": "src/heap/heap.cc",
        "patchSetId": 37
      },
      "lineNbr": 1988,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T18:06:30Z",
      "side": 1,
      "message": "Can you confirm that this is the right place to do this?",
      "range": {
        "startLine": 1986,
        "startChar": 4,
        "endLine": 1988,
        "endChar": 5
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d65d0460_9c99c64a",
        "filename": "src/heap/heap.cc",
        "patchSetId": 37
      },
      "lineNbr": 1988,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-18T22:20:33Z",
      "side": 1,
      "message": "I\u0027d remove this and mirror what futex-emulation does and not eagerly clean up on context disposal. Since async waiter nodes\u0027 `native_context_` is already a weak pointer, it\u0027s memory safe to not eagerly dispose. When processing those async waiter nodes, you can lazily delete them if it turns out their context was already disposed.\n\nIsolates, by contrast, are not GC things so we have to eagerly clean up the list.",
      "parentUuid": "cc137267_72ee5a5d",
      "range": {
        "startLine": 1986,
        "startChar": 4,
        "endLine": 1988,
        "endChar": 5
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da5d19f7_b6572acf",
        "filename": "src/heap/heap.cc",
        "patchSetId": 37
      },
      "lineNbr": 1988,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T23:04:16Z",
      "side": 1,
      "message": "That would work for the regular case. But if a there is a `lockAsync` call in this context that is currently holding the lock while waiting for other promise to resolve, we still need to access the primitive and release the lock, right? Otherwise the queue might stall.",
      "parentUuid": "d65d0460_9c99c64a",
      "range": {
        "startLine": 1986,
        "startChar": 4,
        "endLine": 1988,
        "endChar": 5
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d99c20f_8a70bd32",
        "filename": "src/heap/heap.cc",
        "patchSetId": 37
      },
      "lineNbr": 1988,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-22T23:38:30Z",
      "side": 1,
      "message": "That behavior exists today for Atomics.waitAsync on page navigation. If user code was depending on the navigated-away realm to do the unlocking, there\u0027s no specced behavior to do any special unlocking.\n\nWhile well-intentioned, I don\u0027t think we need to do special handling here and unlock stuff, for two main reasons.\n\n1. How do we (as the engine) know that unlocking those locks is the intended behavior? I can believe that\u0027s the intended behavior like 99% of the time, but it\u0027s possible to synchronously pass the unlock promise to another realm and expect that realm to do the unlocking. Navigating a page might create a lot of garbage by virtue of making things unreachable, but it doesn\u0027t nuke them -- if objects otherwise reachable, their creation realm might have been navigated away but they\u0027re still usable objects.\n\n2. NotifyContextDisposed is a hint to the GC, not for triggering teardown logic. The reason FinalizationRegistries are in here is that they exist only for exposing GC logic. In general I don\u0027t think there\u0027s a norm of doing things on realm \"teardown\", in that it\u0027s not a teardown, but like a close or a navigation event.",
      "parentUuid": "da5d19f7_b6572acf",
      "range": {
        "startLine": 1986,
        "startChar": 4,
        "endLine": 1988,
        "endChar": 5
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddbf8020_187716f3",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 167,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T18:06:30Z",
      "side": 1,
      "message": "I\u0027m not sure if we want the `WaiterQueueNode` extensions here or in `waiter-queue-node.h`. We only need the `WaiterQueueNode` definition to be exposed to isolate.cc for the unique pointers.",
      "range": {
        "startLine": 167,
        "startChar": 19,
        "endLine": 167,
        "endChar": 39
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e7cd42b1_4756a088",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 167,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "I think leaving it unexposed inside this `.cc` until we need it is the right move.",
      "parentUuid": "ddbf8020_187716f3",
      "range": {
        "startLine": 167,
        "startChar": 19,
        "endLine": 167,
        "endChar": 39
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d796a5d4_b3099298",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 442,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T18:06:30Z",
      "side": 1,
      "message": "I\u0027d like to get rid of these, but I need to get the synchronization primitive from the `Global` stored in the node. Is there a way to do this without passing through `Local` and hence needing a HandleScope?",
      "range": {
        "startLine": 442,
        "startChar": 2,
        "endLine": 442,
        "endChar": 36
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82dca560_2113ebc6",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 442,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-18T22:20:33Z",
      "side": 1,
      "message": "Do you still need this if we don\u0027t support the case to match-by-global as suggested above and only allow match-by-Isolate?",
      "parentUuid": "d796a5d4_b3099298",
      "range": {
        "startLine": 442,
        "startChar": 2,
        "endLine": 442,
        "endChar": 36
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bec73ed4_0b490779",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 442,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T23:04:16Z",
      "side": 1,
      "message": "Yes, we need access to the js synchronization promitive to grab the lock queue, safely remove waiter from the queue, and possibly unlock the js mutexes.",
      "parentUuid": "82dca560_2113ebc6",
      "range": {
        "startLine": 442,
        "startChar": 2,
        "endLine": 442,
        "endChar": 36
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20755a1c_30cbc6a9",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 442,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-22T23:38:30Z",
      "side": 1,
      "message": "If no GC can happen, we can just take raw pointers to those, no?",
      "parentUuid": "bec73ed4_0b490779",
      "range": {
        "startLine": 442,
        "startChar": 2,
        "endLine": 442,
        "endChar": 36
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a266e0c_05a711b9",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 37
      },
      "lineNbr": 442,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-23T20:59:52Z",
      "side": 1,
      "message": "Yes, but I don\u0027t know how to code it. `ptr` is a protected member of `IndirectHandleBase` and `Utils::OpenDirectHandle` requires a `HandleScope`. I think it\u0027s fine to leave it like this, am I missing another way to do it?",
      "parentUuid": "20755a1c_30cbc6a9",
      "range": {
        "startLine": 442,
        "startChar": 2,
        "endLine": 442,
        "endChar": 36
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96c61bcc_bfe99636",
        "filename": "src/objects/js-atomics-synchronization.h",
        "patchSetId": 37
      },
      "lineNbr": 437,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T18:06:30Z",
      "side": 1,
      "message": "I\u0027m not 100% sure that this class should be in this file or in a separate \"utils\" file.",
      "range": {
        "startLine": 437,
        "startChar": 0,
        "endLine": 437,
        "endChar": 30
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4457c20_ce978020",
        "filename": "src/roots/roots.h",
        "patchSetId": 37
      },
      "lineNbr": 360,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T18:06:30Z",
      "side": 1,
      "message": "There is an issue here. Declaring the roots here and populating them on bootstrapper.cc works, but mkgrokdump crashes on `DumpKnownObject` because the root is not populated and hence a lot of cctests fail. I could declare this as HeapObject and initialize it with undefined, but I\u0027m not sure if that is the right thing to do.",
      "range": {
        "startLine": 355,
        "startChar": 2,
        "endLine": 360,
        "endChar": 37
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70de0271_f65d41d7",
        "filename": "src/roots/roots.h",
        "patchSetId": 37
      },
      "lineNbr": 360,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-23T20:59:52Z",
      "side": 1,
      "message": "@syg@chromium.org would you mind taking a look at this while I address the other comments?",
      "parentUuid": "b4457c20_ce978020",
      "range": {
        "startLine": 355,
        "startChar": 2,
        "endLine": 360,
        "endChar": 37
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ce6c415_3c8b77d5",
        "filename": "src/roots/roots.h",
        "patchSetId": 37
      },
      "lineNbr": 360,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T22:43:30Z",
      "side": 1,
      "message": "The norm right now is to unconditionally create SFIs in `setup-heap-internal.cc`, even for flagged features. For example, `shadow_realm_import_value_fulfilled_sfi`.",
      "parentUuid": "70de0271_f65d41d7",
      "range": {
        "startLine": 355,
        "startChar": 2,
        "endLine": 360,
        "endChar": 37
      },
      "revId": "2275c1a5bd842d4320b1a0cc76db6eb0f5d53918",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}