{
  "comments": [
    {
      "key": {
        "uuid": "5d00875b_5126610a",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 121,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2019-03-18T11:16:42Z",
      "side": 1,
      "message": "Note: Code objects will require a different padding, they are aligned to kCodeAlignment.",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8837e9e_62766c9d",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 121,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2019-03-18T21:32:49Z",
      "side": 1,
      "message": "Good point. I didn\u0027t realize there were cases like Code with larger padding. I think there\u0027s still a need for this behavior where we pad to the required alignment for the following field, but we\u0027ll eventually need to extend the syntax so we can specify a different alignment size for the Code case.",
      "parentUuid": "5d00875b_5126610a",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9cfc884b_1bd6c3c3",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 135,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2019-03-18T11:16:42Z",
      "side": 1,
      "message": "Did you consider different solutions that avoid the addtl Map class? This feels pretty awkward to me, esp. compared with the previous solution which was just \n\n  V(kLayoutDescriptorOffset, FLAG_unbox_double_fields ? kTaggedSize : 0)    \\\n\nFor example, what about emulating current behavior by adding Torque syntax for conditional fields? Or using a dedicated type just for layout_descriptor that is size 0 if the flag is unset? Or, not sure if/when this will happen, wait until double-unboxing is removed when pointer compression ships?",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ce1f556_bbfc2bda",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 135,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2019-03-18T21:32:49Z",
      "side": 1,
      "message": "I\u0027m somewhat relieved that you and Igor find this pattern uncomfortable too. I expressed similar concerns in an email to Daniel a few weeks back:\n\n\u003e Iâ€™m a little bit hesitant about that approach: it turns Map::kSize into a footgun, it complicates Map::BodyDescriptor because pointer fields are split across Map and a subclass, and it scatters a handful of new casts throughout the code. None of these things are terrible, but all together they feel kind of inelegant compared to the current representation of Map as a single class.\n\nIgor\u0027s suggestion of typedefing Map to either MapWithLayoutDescriptor or MapWithoutLayoutDescriptor would alleviate most of the ugliness in the runtime code, but it would still be nicer to define a single Torque class. To summarize the options I\u0027ve heard so far (and there are probably others):\n\n1. Use the C preprocessor. I like this option for its instantly familiar syntax, and it\u0027s powerful enough that we may find other uses for it too.\n2. Add new Torque syntax that decorates a field type as optional based on a flag.\n3. Use a special type (LayoutDescriptorIfUnboxDoubleFields?), that is known to the compiler to mean \"LayoutDescriptor or empty, depending on FLAG_unbox_double_fields\". This keeps the Torque syntax as simple as possible, but at the cost of putting some additional knowledge about the program being compiled into the compiler itself.\n\nWith options 1 and 2, we need to specify a list of values (such as FLAG_unbox_double_fields) that should be available at Torque compilation time. We wouldn\u0027t want to pass the original cflags and duplicate a bunch of logic from build-config.h and globals.h. Seems like we could just put this list in a .cc file and include it in the compiled torque executable.\n\nWhich solution would you prefer?",
      "parentUuid": "9cfc884b_1bd6c3c3",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a409b4e4_dac9010f",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 135,
      "author": {
        "id": 1115890
      },
      "writtenOn": "2019-03-19T01:09:31Z",
      "side": 1,
      "message": "OK, I think you\u0027ve convinced me. Up until now, I was quite hesitant to use #defines just because this adds a whole new level to the machinery we already have for a small number of cases, but it seems everybody is more comfortable with that than the multiple class definitions. \n\nIf we go this route, than I very strongly prefer 1). \n\nI am probably just being daft, but why do we not want to specify build-config.h and global.h when running the preprocessor? It seems like the simplest and most robust way to do this to not have to maintain multiple lists.",
      "parentUuid": "4ce1f556_bbfc2bda",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8978fa89_0fbcbd72",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 135,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2019-03-19T04:03:27Z",
      "side": 1,
      "message": "Great point regarding globals.h and build-config. I was making things way more complicated than they need to be, when we could include those files directly in the preprocessing step.",
      "parentUuid": "a409b4e4_dac9010f",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2a955a0b_efab70e2",
        "filename": "src/builtins/base.tq",
        "patchSetId": 7
      },
      "lineNbr": 135,
      "author": {
        "id": 1115890
      },
      "writtenOn": "2019-03-19T13:06:51Z",
      "side": 1,
      "message": "BTW, If we don\u0027t go the pre-process way, then the typedef of Map to the right class would definitely reduce the amount of code churn, and should be added to this patch for any short-term solution.\n\nSo, any preference on how to handle this? Do you want to try to first try to land with with the two-class solution and add the #ifdefs support later? Even better would be to pre-land the pre-processor support in a separate CL. Although we can do this on our side, Tobias in on vacation and I\u0027m traveling right now, so I am not sure how quickly it would get done if it\u0027s on our plate. You\u0027re welcome to give it a shot.",
      "parentUuid": "a409b4e4_dac9010f",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7efb1ae_b4c86893",
        "filename": "src/objects/map.h",
        "patchSetId": 7
      },
      "lineNbr": 978,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2019-03-18T11:18:47Z",
      "side": 1,
      "message": "Given that we will not have maps with and without the descriptor field at the same time it would be much cleaner to keep having only one definition of the Map class. Let us discuss what we can do on Torque side to make it possible.\n\nAnyway, I think it would be better if we define Map as typedef to either MapWithLayoutDescriptor or MapWithoutLayoutDescriptor otherwise it really causes confusion on runtime side.",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "988f5919_36d9501a",
        "filename": "src/objects/map.h",
        "patchSetId": 7
      },
      "lineNbr": 978,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2019-03-18T21:32:49Z",
      "side": 1,
      "message": "Responded in another closely-related comment thread: https://chromium-review.googlesource.com/c/v8/v8/+/1480919/7/src/builtins/base.tq#135",
      "parentUuid": "b7efb1ae_b4c86893",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "235413e8_ae8b6227",
        "filename": "src/objects/map.h",
        "patchSetId": 7
      },
      "lineNbr": 978,
      "author": {
        "id": 1115890
      },
      "writtenOn": "2019-03-19T01:09:31Z",
      "side": 1,
      "message": "As discussed in the other class, let\u0027s hook up the C++ preprocessor to do this, using the #if/#endif syntax.",
      "parentUuid": "988f5919_36d9501a",
      "revId": "3d4fbf7fdeb08dfcdf4934b7ea307c2cc4734be7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}