{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "604f0ea2_146811cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 38
      },
      "lineNbr": 0,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "Still working through it, posting more questions and comments in the meantime.",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27e8576a_e20a321b",
        "filename": "src/heap/heap.h",
        "patchSetId": 38
      },
      "lineNbr": 890,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-22T23:38:30Z",
      "side": 1,
      "message": "Nit: It is verbose, but we should spell out `SharedFunctionInfo(s)`.",
      "range": {
        "startLine": 890,
        "startChar": 7,
        "endLine": 890,
        "endChar": 44
      },
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b6a9796_6c5fb8cb",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 279,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "This shouldn\u0027t be needed, as `~Global()` already does a `Reset()`.",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "17f20194_0db20594",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 285,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "Here and below: `std::make_unique`?",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f27adc0b_b9703843",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 285,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-23T21:23:04Z",
      "side": 1,
      "message": "I tried, but `std::make_unique` doesn\u0027t work with private constructors.",
      "parentUuid": "17f20194_0db20594",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a6372421_da71d465",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 285,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T22:10:10Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "f27adc0b_b9703843",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6eab4359_4ac3d6c8",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 332,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "We should `SetNotInListForVerification` even when cancelled, I think?",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e12aaab6_286a701d",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 443,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-18T22:20:33Z",
      "side": 1,
      "message": "I\u0027m not sure if a `std::list` is best here vs an intrusive list yet. Opinions?",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a6cb507_0330bbb2",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 443,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-18T23:04:16Z",
      "side": 1,
      "message": "I think the ownership looks cleaner with `std::list` but an intrusive list has a constant dequeue time (and we dequeue everytime the lock is asynchronously taken and released). The ownership with the intrusive list would look like this:\n```\nclass AsycWaiterQueueNodeBase : public WaiterQueueNode {\nstd::unique_ptr\u003cAsycWaiterQueueNodeBase\u003e next_async_node_;\nAsycWaiterQueueNodeBase* prev_async_node_;\n}\n```\nBoth types of AsyncWaiterQueueNodes would inherit from this because the queue is shared and if there is a single async node in the queue it would keep itself alive.\n\n\nDo you think this is a better approach?",
      "parentUuid": "e12aaab6_286a701d",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b3d306e_8144e3d3",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 443,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-22T23:38:30Z",
      "side": 1,
      "message": "I\u0027m happy with `std::list` for now. We can optimize as needed, but this won\u0027t be a performance critical part for the time being.",
      "parentUuid": "1a6cb507_0330bbb2",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb6e1d16_4d25e8b2",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 598,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "I *think* this should be inlined but maybe `V8_INLINE` this method just to be sure.",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33527c3c_7fc10c86",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 824,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "```suggestion\nHandle\u003cJSPromise\u003e JSAtomicsMutex::LockOrEnqueuePromise(\n```",
      "range": {
        "startLine": 824,
        "startChar": 34,
        "endLine": 824,
        "endChar": 52
      },
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53214662_abc83a74",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 827,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "Do we need `lock_promise`? AFAICT it\u0027s an internal promise whose purpose is to enqueue the `run_under_lock` microtask when the lock is acquired. Can we directly call `run_under_lock` without the need for this internal promise? Perhaps I\u0027m missing something.",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "960f4e05_0a6e7459",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 827,
      "author": {
        "id": 1506979
      },
      "writtenOn": "2024-04-23T21:23:04Z",
      "side": 1,
      "message": "This removes ambiguity since the callback will always run in a microtask regardless if the lock was acquired synchronously or not, also I\u0027m reusing the `atomics_waitasync_promises` map to keep everything alive without using strong global handles, this way I can put `lock_promise` in the map without adding extra machinery to the native context.",
      "parentUuid": "53214662_abc83a74",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "826f1886_c205ecd0",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 827,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T22:10:10Z",
      "side": 1,
      "message": "Good point about always running `run_under_lock` in a microtask, that is an important invariant to keep for async APIs. The other way to do that would be to always run it in a (macro)task by posting a non-nestable task if the lock could be synchronously acquired. That means having a special synchronously acquired lock task which keeps `run_under_lock` alive, which is extra complexity. I\u0027m convinced \nnow it\u0027s fine to have this internal promise.",
      "parentUuid": "960f4e05_0a6e7459",
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b0ba3f8_30e7b24e",
        "filename": "src/objects/js-atomics-synchronization.cc",
        "patchSetId": 38
      },
      "lineNbr": 894,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2024-04-23T21:00:52Z",
      "side": 1,
      "message": "```suggestion\n  // node in the C++ heap. Its lifetime is managed by the requester\u0027s\n```",
      "range": {
        "startLine": 894,
        "startChar": 27,
        "endLine": 894,
        "endChar": 31
      },
      "revId": "a5dd2675de5747129d3f9b265810eecb10dee777",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}