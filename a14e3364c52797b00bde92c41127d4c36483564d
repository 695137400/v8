{
  "comments": [
    {
      "key": {
        "uuid": "5abd1a3b_aabbd287",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-10-06T13:56:14Z",
      "side": 1,
      "message": "lgtm, thanks for the explanations",
      "revId": "a14e3364c52797b00bde92c41127d4c36483564d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "49430652_54a5ed87",
        "filename": "src/heap/cppgc/write-barrier.cc",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-10-06T11:45:34Z",
      "side": 1,
      "message": "The reason for introducing all of the complexity around in-construction objects was so that the write barrier cannot blow up any in construction list. E.g.,\n\n  struct GCed : ... {\n   GCed() { global_data_structure.push(this); }\n  }\n\nThe in-construction worklist we have right now does not allow bailing out on duplicates.\n\nCan we get what we initially wanted: An external data structure to do a containments check that allows us to filter dupes, so that we can do:\n\n  if (IsInConstruction(header) \u0026\u0026 MarkExternalBit(header)) {\n    in_construction_object.Push(header);\n  } else if (MarkNoPush(header)) {\n    marking_worklist_.Push(descriptor);\n  }\n\nThis way we bound processing an object by 2 times as in the worst case we have it in the regular worklist and in the in-construction worklist.",
      "range": {
        "startLine": 44,
        "startChar": 11,
        "endLine": 44,
        "endChar": 17
      },
      "revId": "a14e3364c52797b00bde92c41127d4c36483564d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edcb1650_5ecc72da",
        "filename": "src/heap/cppgc/write-barrier.cc",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-10-06T12:05:16Z",
      "side": 1,
      "message": "The in-construction worklist (following [1]) is already an std::unordered_set which would eliminate duplicates implicitly. Processing is already bound by 2 times (1 in in-construction worklist and 1 in regular worklist).\n\n[1] https://chromium-review.googlesource.com/c/v8/v8/+/2437388",
      "parentUuid": "49430652_54a5ed87",
      "range": {
        "startLine": 44,
        "startChar": 11,
        "endLine": 44,
        "endChar": 17
      },
      "revId": "a14e3364c52797b00bde92c41127d4c36483564d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "244cc1a0_fa23e478",
        "filename": "src/heap/cppgc/write-barrier.cc",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-10-06T12:30:39Z",
      "side": 1,
      "message": "Context: I am trying to work around the Unmark() (Black-\u003eWhite transition) which has caused issues every now and then.\n\nObservation: We are bound by 2 times processing (in-construction + regular). Whether the markbit is set or not doesn\u0027t matter for here.\n\nSince we anyways have the potential double processing, we may as well change the extraction in [1] to \n  // ...\n  MarkNoPush(*object);\n  previously_not_fully_constructed_worklist_.Push(object);\n  // ...\n\nDo you see any issues with that?\n\n[1] https://source.chromium.org/chromium/chromium/src/+/master:v8/src/heap/cppgc/marking-state.cc;l\u003d16?q\u003dMarkingState::FlushNotFullyConstructedObjects\u0026ss\u003dchromium",
      "parentUuid": "edcb1650_5ecc72da",
      "range": {
        "startLine": 44,
        "startChar": 11,
        "endLine": 44,
        "endChar": 17
      },
      "revId": "a14e3364c52797b00bde92c41127d4c36483564d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1edbc0e2_e44074d1",
        "filename": "src/heap/cppgc/write-barrier.cc",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-10-06T13:45:49Z",
      "side": 1,
      "message": "I was actually going to suggest that once I understood what your concern was. I think it\u0027s better than having 2 data structures that hold the same data.\nThere are 2 possible downsides:\n(1) We might trace the same object twice, but that should be negligible in terms of performance.\n(2) Our marked bytes accounting will be off since we account after tracing (and as (1) mentioned we might trace twice).\n\nRegarding (2), we already might be slightly off if two concurrent markers trace the same object. This case will be easier to \"exploit\" but given that in-construction should be very rare, maybe the impact will be minimal. We can try to address that by accounting when marking instead of accounting when tracing. wdyt?",
      "parentUuid": "244cc1a0_fa23e478",
      "range": {
        "startLine": 44,
        "startChar": 11,
        "endLine": 44,
        "endChar": 17
      },
      "revId": "a14e3364c52797b00bde92c41127d4c36483564d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a308801b_3df007f7",
        "filename": "src/heap/cppgc/write-barrier.cc",
        "patchSetId": 1
      },
      "lineNbr": 44,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-10-06T13:56:14Z",
      "side": 1,
      "message": "Ugh, I think we should avoid double processing if somehow possible as we generally assume our counters are exact at some point.\n\nIf we unmark here we actually do not have double-processing, right? If the object is later on fully constructed it will be added to a regular worklist and the extraction will bail out, no?",
      "parentUuid": "1edbc0e2_e44074d1",
      "range": {
        "startLine": 44,
        "startChar": 11,
        "endLine": 44,
        "endChar": 17
      },
      "revId": "a14e3364c52797b00bde92c41127d4c36483564d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}