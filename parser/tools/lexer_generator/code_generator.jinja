// Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

{%- macro jump(id) -%}
  {%- set node = jump_table[id] -%}
  goto {{ node[1] ~ '_' ~ node[0] }};
{%- endmacro -%}

{%- macro do_key(key) -%}
  {%- for r in key -%}
    {%- if not loop.first %} || {% endif -%}
    {%- if r[0] == 'PRIMARY_RANGE' -%}
      {%- if r[1][0] == r[1][1] and r[1][0] != 0 -%}
        primary_char == {{r[1][0]}}
      {%- elif r[1][0] == r[1][1] -%}
        (primary_char == 0 && cursor_ < buffer_end_)
      {%- elif r[1][0] == 0 -%}
        primary_char <= {{r[1][1]}}
      {%- elif r[1][1] == upper_bound and not encoding == 'utf16'-%}
        primary_char >= {{r[1][0]}}
      {%- else -%}
        ({{r[1][0]}} <= primary_char && primary_char <= {{r[1][1]}})
      {%- endif -%}
    {# These classes require long_char and to be outside the primary range #}
    {%- elif r[0] == 'LONG_CHAR_CLASS' and encoding in ['utf16', 'utf8'] -%}
      {%- if r[1] == 'call' -%}
        unicode_cache_->{{r[2]}}(long_char)
      {%- elif r[1] == 'invert' -%}
        !({{do_key(r[2])}})
      {%- elif r[1] == 'catch_all' -%}
        (true || long_char == 0) /* {{r[1]}} */
      {%- else -%}
        uncompilable code for {{encoding}} {{r[0]}} {{r[1]}}
      {%- endif -%}
    {%- else -%}
      uncompilable code for {{encoding}} {{r[0]}} {{r[1]}}
    {%- endif -%}
  {%- endfor -%}
{%- endmacro -%}


{#- entry actions must not change the value of the cursor
    unless they jump -#}
{% macro dispatch_entry_action(type, args) -%}
  {% if type == 'store_token' %}
    stored_token = Token::{{args[0]}};
  {% elif type == 'no_op' %}
    {# TODO(dcarney): remove #}
  {% elif type == 'set_marker' %}
    marker = cursor_ - {{args[0]}};
  {% elif type == 'set_has_escapes' %}
    next_.has_escapes = true;
  {% elif type == 'octal_inside_string' %}
    last_octal_end_ = cursor_;
    next_.has_escapes = true;
  {% elif type == 'line_terminator_in_multiline_comment' %}
    has_multiline_comment_before_next_ = true;
  {% elif type == 'store_token' %}
    stored_token = Token::{{args[0]}};
  {% elif type == 'store_harmony_token' %}
    if (harmony_{{args[0]}}_) {
      stored_token = Token::{{args[1]}};
    } else {
      stored_token = Token::{{args[2]}};
    }
  {% elif type == 'check_escaped_identifier_start' %}
    if (!unicode_cache_->IsIdentifierStart(ScanHexNumber(4))) {
      goto default_action;
    }
    next_.has_escapes = true;
  {% elif type == 'check_escaped_identifier_part' %}
    if (!unicode_cache_->IsIdentifierPart(ScanHexNumber(4))) {
      goto default_action;
    }
    next_.has_escapes = true;
  {% elif type == 'if_line_terminator_backtrack' %}
    if (!has_line_terminator_before_next_) {
      {{dispatch_match_action('manual_backtrack', args)}}
    }
  {% elif type == 'store_lexing_state' %}
    STORE_LEXING_STATE();
  {% elif type == 'chain' %}
    {%- for arg in args %}
      {{dispatch_entry_action(arg.name(), arg.args())}}
    {% endfor -%}
  {% else %}
    uncompilable code for {{type}} {{args}}
  {% endif -%}
{%- endmacro -%}


{#- match actions must all explicitly jump or return -#}
{% macro dispatch_match_action(type, args) -%}
  {% if type == 'terminate' %}
    {{dispatch_match_action('manual_backtrack', ('1', 'EOS'))}}
  {% elif type == 'terminate_illegal' %}
    start_ = marker;
    {{dispatch_match_action('manual_backtrack', ('1', 'ILLEGAL'))}}
  {% elif type == 'skip' %}
    RESET_START();
    {%- if encoding == 'utf16'or encoding == 'utf8' -%}
      next_.is_in_primary_range = true;
    {%- endif -%}
    goto state_entry_0;
  {% elif type == 'skip_and_terminate' %}
    RESET_START();
    --start_;
    {{dispatch_match_action('terminate', None)}}
  {% elif type == 'line_terminator' %}
    RESET_START();
    {%- if encoding == 'utf16'or encoding == 'utf8' -%}
      next_.is_in_primary_range = true;
    {%- endif -%}
    has_line_terminator_before_next_ = true;
    goto state_entry_0;
  {% elif type == 'token' %}
    DO_TOKEN(Token::{{args[0]}})
    return;
  {% elif type == 'do_stored_token' %}
    DO_TOKEN(stored_token)
    return;
  {% elif type == 'default' %}
    DO_TOKEN(Token::ILLEGAL);
    FORWARD();
    RESET_START();
    return;
  {% elif type == 'harmony_token' %}
    if (harmony_{{args[0]}}_) {
      DO_TOKEN(Token::{{args[1]}});
    } else {
      DO_TOKEN(Token::{{args[2]}});
    }
    return;
  {% elif type == 'octal_number' %}
    last_octal_end_ = cursor_;
    DO_TOKEN(Token::NUMBER);
    return;
  {% elif type == 'manual_backtrack' %}
    BACKWARD({{args[0]}});
    DO_TOKEN(Token::{{args[1]}});
    return;
  {% elif type == 'backtrack' %}
    RESTORE_LEXING_STATE();
    {{dispatch_match_action(args[0].name(), args[0].args())}}
  {% else %}
    uncompilable code for {{type}} {{args}}
  {% endif -%}
{%- endmacro -%}


{%- macro long_char_check() -%}
  {%- if encoding == 'utf16'-%}
    primary_char > {{upper_bound}}
  {%- elif encoding == 'utf8'-%}
    primary_char < 0
  {%- else -%}
    uncompilable code for {{encoding}}
  {%- endif -%}
{%- endmacro -%}


{%- macro long_char_create() -%}
  {%- if encoding == 'utf16'-%}
    const uint32_t long_char = primary_char;
  {%- elif encoding == 'utf8'-%}
    unsigned bytes_read = 0;
    const uint32_t long_char = unibrow::Utf8::CalculateValue(
        reinterpret_cast<const uint8_t*>(cursor_),
        buffer_end_ - cursor_,
        &bytes_read);
    cursor_ += bytes_read - 1;
  {%- else -%}
    uncompilable code for {{encoding}}
  {%- endif -%}
{%- endmacro -%}


{%- macro write_label(label_name, node_number) %}
  {%- set state = dfa_states[node_number] -%}
  {%- set used = state['entry_points'][label_name] -%}
  {%- set long_label = label_name ~ '_' ~ node_number -%}
  {%- set inlined = 'inlined' if state['inline'] else 'not inlined' -%}
  {% if used -%}
    {{long_label}}: // {{inlined}}
  {%- else -%}
    // {{long_label}}: {{inlined}}
  {%- endif %}
{% endmacro -%}


{%- macro do_dfa_state(node_number) -%}

  {%- set state = dfa_states[node_number] -%}

  {{ write_label('state_entry', node_number) }}

  {% if not state['elide_read'] -%}
    READ_CURSOR();
  {%- endif -%}

  {% if debug_print %}
    fprintf(stderr,
            "state {{state.node_number}}, start %d, cursor %d\n",
            start_ - buffer_,
            cursor_ - buffer_);
  {% endif -%}

  {%- set action = state['action'].term() -%}
  {%- if action %}
    {%- if not state['total_transitions'] -%}
      {{ dispatch_match_action(action.name(), action.args()) }}
    {%- else -%}
      {{ dispatch_entry_action(action.name(), action.args()) }}
    {%- endif -%}
  {%- endif %}

  {{ write_label('after_entry_code', node_number) }}

  {%- if debug_print %}
    fprintf(stderr, "char at hand is %c (%d)\n", primary_char, primary_char);
  {% endif -%}

  {%- macro do_transition(jump_id, do_forward = True) -%}
    {%- set transition_state_id = jump_table[jump_id][0] -%}
    {%- set inline_transition = jump_table[jump_id][1] == 'inline' %}
    {%- if do_forward %}
      FORWARD();
    {% endif %}
    {%- if inline_transition %}
      {{ do_dfa_state(transition_state_id) }}
    {% else %}
      {{ jump(jump_id) }}
    {% endif %}
  {%- endmacro -%}

  {%- if state['switch_transitions'] -%}
    switch(primary_char) {
    {%- for ranges, jump_id in state['switch_transitions'] %}
      {%- for r in ranges -%}
        {%- for key in range(r[0], r[1] + 1) -%}
          case {{key}}:
        {% endfor %}
      {%- endfor -%}
      {{ do_transition(jump_id) }}
    {% endfor -%}
    }
  {%- endif -%}

  {%- for key, jump_id in state['if_transitions'] %}
    if ({{do_key(key)}}) { // normal if transition
      {{ do_transition(jump_id) }}
    }
  {% endfor -%}

  {%- if 'eos' in state['unique_transitions'] %}
    if (primary_char == 0 && cursor_ >= buffer_end_) { // eos handler
      FORWARD();
      {{ jump(state['unique_transitions']['eos']) }}
    }
  {%- endif -%}

  {%- if state['deferred_transitions'] %}
    if ({{long_char_check()}}) {
      next_.is_in_primary_range = false;
      {{long_char_create()}}
      {%- for key, jump_id in state['deferred_transitions'] %}
        if ({{do_key(key)}}) { // long_char transition
          {{ do_transition(jump_id) }}
        }
      {% endfor -%}
    }
  {%- endif -%}

  {%- if state['omega_transition'] %}
    {{ do_transition(state['omega_transition'], False) }}
  {%- endif -%}

  goto default_action; {# this is wrong, should be CRASH(); #}

{%- endmacro %}

#include "lexer/lexer.h"

#define RESET_START() {               \
  start_ = cursor_;                   \
}

#define STORE_LEXING_STATE() {        \
  stored_marker = marker;             \
  stored_cursor = cursor_;            \
  stored_start = start_;              \
}

#define RESTORE_LEXING_STATE() {      \
  marker = stored_marker;             \
  cursor_ = stored_cursor;            \
  start_ = stored_start;              \
}

#define DO_TOKEN(T) {                 \
  next_.beg_pos = start_ - buffer_;   \
  next_.end_pos = cursor_ - buffer_;  \
  next_.token = T;                    \
  RESET_START();                      \
}

#define FORWARD() {                               \
  cursor_++;                                      \
}

#define BACKWARD(n) {                             \
  cursor_ -= n;                                   \
}

#define READ_CURSOR() {                           \
  if (cursor_ >= buffer_end_) primary_char = 0;   \
  else primary_char = *(cursor_);                 \
}

#ifdef DEBUG
#define CRASH() { ((void(*)())0)(); }
#else
#define CRASH() { }
#endif


namespace v8 {
namespace internal {
template<>
void Lexer<{{char_type}}>::Scan() {

  // Setup environment.
  next_.has_escapes = false;
  next_.is_in_primary_range = true;
  Token::Value stored_token;
  const {{char_type}} * marker;
  {{char_type}} primary_char;
  const {{char_type}} * stored_marker;  {# TODO(dcarney): complete this #}
  const {{char_type}} * stored_cursor;
  const {{char_type}} * stored_start;

{# first node is start node #}
{% for dfa_state in dfa_states -%}
  {%- if not dfa_state['inline'] %}
    {{ do_dfa_state(dfa_state['node_number']) }}
  {%- endif -%}
{%- endfor %}

  // Execute the default action.
  default_action:
{%- if debug_print %}
    fprintf(stderr, "default action\n");
{% endif -%}
    {%- set action = default_action.term() -%}
    {{dispatch_match_action(action.name(), action.args())}}
  CRASH();

  if (false) {
    // force use of stored_token
    stored_token = Token::ILLEGAL;
    // force use of marker
    marker = NULL;
    // force use of state_entry_0
    goto state_entry_0;
  }
}
} }

