{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5947f11c_8a87b074",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-10-19T11:16:05Z",
      "side": 1,
      "message": "this is not necessarily the case, if e.g. the first OSR compilation didn\u0027t know about feedback collected while executing the second loop.",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a0b1708_876c52cf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-10-20T03:47:51Z",
      "side": 1,
      "message": "Sorry, I didn\u0027t write potential precondition \"If no more feedback changeâ€œ to the git commit message, I added the potential precondition just now. This patch intervene OSR compilation only in the condition that there is no more feedback change.\nIf new feedback was collected while executing the second loop, profiler ticks is reset by IC::OnFeedbackChanged() or CodeStubAssembler::ReportFeedbackUpdate(), the feedback collection state go back to the beginning and start again, the OSR urgency will not increase to more than 0 before accumulating enough no feedback change profiler ticks to meet the condition of SmallEnoughForOSR().",
      "parentUuid": "5947f11c_8a87b074",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2592f2b2_f7d5de05",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-10-20T08:24:55Z",
      "side": 1,
      "message": "So you\u0027re saying that your patch isn\u0027t necessary if feedback changes (because profiler ticks get reset anyway), and only has interesting behaviour if feedback doesn\u0027t change (because the second loop is included in the first loop)? And you want the second loop to go through the same profiler tick increase as the first loop did, before actually getting compiled?",
      "parentUuid": "9a0b1708_876c52cf",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "091a6073_f8ade098",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-10-20T09:17:55Z",
      "side": 1,
      "message": "Yes. The current latency of waiting for hitting the entry of the first OSR (1 profiler tick) is too few, change to the latency of from scratch OSR (go through the same profiler tick increase as the first loop did).",
      "parentUuid": "2592f2b2_f7d5de05",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c17928c8_a59f7fc1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-10-20T12:10:52Z",
      "side": 1,
      "message": "We could still have the case though, that the first loop compile takes a long time, and the second loop\u0027s compile has been going for a long time, right? Resetting profile ticks on compile completion is not the same thing as resetting them when the new loop starts. Maybe we should reset OSR urgency / profiling ticks when a different loop is taken?",
      "parentUuid": "091a6073_f8ade098",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0efd45c_91b2a44b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-10-20T13:20:52Z",
      "side": 1,
      "message": "No, the second loop\u0027s compile (https://source.chromium.org/chromium/chromium/src/+/main:v8/src/execution/tiering-manager.cc;drc\u003d325853cf50658e7e14980a42e42ecb5dbed1f411;l\u003d302) won\u0027t start before the first loop compile completion (https://source.chromium.org/chromium/chromium/src/+/main:v8/src/execution/tiering-manager.cc;drc\u003d325853cf50658e7e14980a42e42ecb5dbed1f411;l\u003d271), we reset OSR urgency when the first loop\u0027s compile start (https://source.chromium.org/chromium/chromium/src/+/main:v8/src/codegen/compiler.cc;drc\u003d283791d250fe8cce64e1d973116faf92ddd304e4;l\u003d3897), I don\u0027t understand why we should reset OSR urgency / profiling ticks when a different (nesting?) loop is taken.",
      "parentUuid": "c17928c8_a59f7fc1",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a633c9b7_42403f95",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-10-20T13:42:39Z",
      "side": 1,
      "message": "So what happens is:\n\n  1. We start executing the first loop,\n  2. Eventually, we collect enough profiling ticks to OSR the first loop, so we start concurrent OSR (and reset ticks when starting), \n  3. We continue executing the first loop, increasing profiling ticks again,\n  4. We finish executing the first loop,\n  5. We start executing the second loop, with profiling ticks quite high due to (3)\n  6. Concurrent OSR for the first loop completes,\n  7. We immediately start concurrent OSR for the second loop, despite there not being many ticks created by the second loop.\n  \nAnd you want to insert a second tick reset between (6) and (7), to delay when (7) happens? My question is: what if the time between (5) and (6) is long?",
      "parentUuid": "a0efd45c_91b2a44b",
      "range": {
        "startLine": 14,
        "startChar": 20,
        "endLine": 14,
        "endChar": 56
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8987b2a4_67714aad",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 24,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-10-19T11:16:05Z",
      "side": 1,
      "message": "does it have an effect on actual performance/score?",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 21
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4139efa3_8353f03a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 24,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-10-20T03:47:51Z",
      "side": 1,
      "message": "I didn\u0027t see stable performance/score modification. I think this patch takes more effect on few cpu core or little memory or the os is executing some other heavy workload. As the os is executing some other heavy workload may increase variance, I\u0027m trying to find test machine with few cpu core and little memory to test this patch.",
      "parentUuid": "8987b2a4_67714aad",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 21
      },
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16173a2f_443b18c0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-10-18T06:56:29Z",
      "side": 1,
      "message": "Could you please review this patch?",
      "revId": "be261f1885bd9450d2cc72faae5fc7ddd9a82064",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}