{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "885fd31a_99ed48c6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-06T21:49:30Z",
      "side": 1,
      "message": "Please also write an explanation of what the optimization tries to do and when it applies.",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45154d3f_81f9a146",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-06T07:40:33Z",
      "side": 1,
      "message": "Hi Leszek and Shu, this CL is a follow-up CL for https://chromium-review.googlesource.com/c/v8/v8/+/3816221.\n\nIn the previous CL, we could elide redundant immutable context load in some case like: `a.b \u003d a.c`, but we can\u0027t optimize it in `a.b.bb \u003d a.c`, because the accumulator was changed between generating bytecodes for lhs and rhs.\n\nIn this CL, we could cover this case, PTAL, thanks!",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97f0cb0b_063c5168",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-09-06T15:11:40Z",
      "side": 1,
      "message": "Shu, can you review this since you reviewed the first CL?",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7563cec8_428d549a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-06T21:49:30Z",
      "side": 1,
      "message": "Thanks for the CL. Holding off on the nitpicky things since I\u0027m not yet clear on two bigger points:\n\n1. What benchmarks does this improve for Speedometer2?\n\n2. I don\u0027t understand why this optimization is safe because of the use of the static variable. Why is the reserved register static?",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74348f7f_7b0e9762",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-08T10:41:49Z",
      "side": 1,
      "message": "Thanks for your reply!\n\n1. There are some hot functions called `showEntries` and `updateElementCount` in `resources/todomvc/vanilla-examples/es2015-babel-webpack/src/view.js`, they have the pattern like `a.b.bb \u003d a.c`, in the previous CL we could elide redundant bytecode in cases like `a.b \u003d a.c`, this CL could do futher.\n\n2. Please see the clarify in another comment.",
      "parentUuid": "7563cec8_428d549a",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0755413b_c06f5299",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-06T21:49:30Z",
      "side": 1,
      "message": "I don\u0027t understand why this optimization is safe because the reserved register index is a static variable. Can\u0027t `VisitAssignment` be recursively called in `VisitForAccumulatorValue` above on L4679?",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58b401d5_537915e4",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-08T10:41:49Z",
      "side": 1,
      "message": "In this CL we just mark the two expression in some cases like: `a.b.bb \u003d a.c`, and we will clear the mark after visiting the `Assignment` expression.\nThe lhs and rhs would be some nested `Property` ast nodes and finally ends with `VariableProxy` ast node, there are leaf nodes which don\u0027t contain a `Assignment` inside, so I suppose there is no `VisitAssignment` will be invoked when we visit lhs and rhs expressions just like the above case.",
      "parentUuid": "0755413b_c06f5299",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "748ff549_d0b2c6f4",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-16T00:48:06Z",
      "side": 1,
      "message": "Unfortunately JS is a tricky language. It is definitely possible to nest assignments in this case, consider the following, which currently causes an assertion with your CL:\n\n```\nfunction outer() {\n  let a \u003d { x: 42, nested: { name: \"a\" } };\n  let b \u003d { x: 42, nested: { name: \"x\" } };\n  function inner() {\n    a.nested.name \u003d a[b.nested.name \u003d b.x];\n  }\n  inner();\n}\nouter();\n```",
      "parentUuid": "58b401d5_537915e4",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "674436cc_2beb5997",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-16T04:32:35Z",
      "side": 1,
      "message": "Oops! Thanks for your reminder! You are exactly correct, I didn\u0027t cover this case, there is potential `Assignment` in current marking mechanism, but I have used a `DCHECK` at L3657 `DCHECK(IsVariableInRegister(variable, Register(RegisterAllocationScope::get_reserved_index())));`.\n\nit looks like it could catch these corner cases, because the nested variable `b` is not same as variable `a`, if the nested variable is same as outter variable, we could even elide the nested load bytecode by reusing the outter variable, but in this CL, we would like just to elide load bytecode in leaf node without nested `Assignment`, so if there is futher case like these we could use this `DCHECK` to find it.\n\nI also updated this patch set which avoid marking the case you metioned by checking whether the `key` of `Property` is a `Literal`, and also the arguments in `Call`, hence there may not be potential nested `Assignment`, how does that sounds to you?",
      "parentUuid": "748ff549_d0b2c6f4",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33d189f7_539abae5",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-16T12:35:53Z",
      "side": 1,
      "message": "I found that I may go into a wrong direction to solve this proble, I would like to just slove this `Assignment` as a leaf node at begin, so I chose to use a static variable. \n\nAfter I got your insights, I think I could slove this problem even in a nested `Assignment` by using a stack, I updated this patchset to add a stack called `reserved_indexes_` in `BytecodeGenerator`, PTAL, thank!",
      "parentUuid": "674436cc_2beb5997",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66d44756_1de1aa03",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-20T00:44:13Z",
      "side": 1,
      "message": "Thanks for updating your approach. What speedup do you see with this optimization? \n\nI\u0027m a little unconvinced currently that the complexity in the bytecode compiler is worth it.",
      "parentUuid": "33d189f7_539abae5",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e91889f_8f29956f",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-21T07:31:33Z",
      "side": 1,
      "message": "Thanks for your review! We didn\u0027t find obvious performance gain in spd2.\nIf you think the complexity comes from the addtional logic of release register in the destructor of `RegisterAllocationScope`, we may have to abodon this CL, but if you think the complexity comes from other parts, we may try some other way to work around, how do you think of this?",
      "parentUuid": "66d44756_1de1aa03",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75f70000_c9698ed3",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-21T20:34:34Z",
      "side": 1,
      "message": "My opinion is that the bytecode compiler should remain as straightforward as possible, with minimal optimizations, barring really compelling speedups. The general architecture of V8 is many layers of JIT compilers, with each layer doing optimization than the previous. Philosophically I think adding more complexity in the bytecode compiler is usually not worth it -- but some such optimizations are simple or yield significant speedup. In this particular case the patterns being optimized seem pretty targeted, so without really compelling numbers I\u0027d prefer keep the bytecode compiler simple.",
      "parentUuid": "7e91889f_8f29956f",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}