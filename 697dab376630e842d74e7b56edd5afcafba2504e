{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "885fd31a_99ed48c6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 7
      },
      "lineNbr": 39,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-06T21:49:30Z",
      "side": 1,
      "message": "Please also write an explanation of what the optimization tries to do and when it applies.",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45154d3f_81f9a146",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-06T07:40:33Z",
      "side": 1,
      "message": "Hi Leszek and Shu, this CL is a follow-up CL for https://chromium-review.googlesource.com/c/v8/v8/+/3816221.\n\nIn the previous CL, we could elide redundant immutable context load in some case like: `a.b \u003d a.c`, but we can\u0027t optimize it in `a.b.bb \u003d a.c`, because the accumulator was changed between generating bytecodes for lhs and rhs.\n\nIn this CL, we could cover this case, PTAL, thanks!",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97f0cb0b_063c5168",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-09-06T15:11:40Z",
      "side": 1,
      "message": "Shu, can you review this since you reviewed the first CL?",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7563cec8_428d549a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-06T21:49:30Z",
      "side": 1,
      "message": "Thanks for the CL. Holding off on the nitpicky things since I\u0027m not yet clear on two bigger points:\n\n1. What benchmarks does this improve for Speedometer2?\n\n2. I don\u0027t understand why this optimization is safe because of the use of the static variable. Why is the reserved register static?",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74348f7f_7b0e9762",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-08T10:41:49Z",
      "side": 1,
      "message": "Thanks for your reply!\n\n1. There are some hot functions called `showEntries` and `updateElementCount` in `resources/todomvc/vanilla-examples/es2015-babel-webpack/src/view.js`, they have the pattern like `a.b.bb \u003d a.c`, in the previous CL we could elide redundant bytecode in cases like `a.b \u003d a.c`, this CL could do futher.\n\n2. Please see the clarify in another comment.",
      "parentUuid": "7563cec8_428d549a",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0755413b_c06f5299",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-06T21:49:30Z",
      "side": 1,
      "message": "I don\u0027t understand why this optimization is safe because the reserved register index is a static variable. Can\u0027t `VisitAssignment` be recursively called in `VisitForAccumulatorValue` above on L4679?",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58b401d5_537915e4",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1531727
      },
      "writtenOn": "2022-09-08T10:41:49Z",
      "side": 1,
      "message": "In this CL we just mark the two expression in some cases like: `a.b.bb \u003d a.c`, and we will clear the mark after visiting the `Assignment` expression.\nThe lhs and rhs would be some nested `Property` ast nodes and finally ends with `VariableProxy` ast node, there are leaf nodes which don\u0027t contain a `Assignment` inside, so I suppose there is no `VisitAssignment` will be invoked when we visit lhs and rhs expressions just like the above case.",
      "parentUuid": "0755413b_c06f5299",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "748ff549_d0b2c6f4",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 7
      },
      "lineNbr": 4687,
      "author": {
        "id": 1362925
      },
      "writtenOn": "2022-09-16T00:48:06Z",
      "side": 1,
      "message": "Unfortunately JS is a tricky language. It is definitely possible to nest assignments in this case, consider the following, which currently causes an assertion with your CL:\n\n```\nfunction outer() {\n  let a \u003d { x: 42, nested: { name: \"a\" } };\n  let b \u003d { x: 42, nested: { name: \"x\" } };\n  function inner() {\n    a.nested.name \u003d a[b.nested.name \u003d b.x];\n  }\n  inner();\n}\nouter();\n```",
      "parentUuid": "58b401d5_537915e4",
      "revId": "697dab376630e842d74e7b56edd5afcafba2504e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}