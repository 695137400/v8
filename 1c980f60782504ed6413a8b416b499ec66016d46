{
  "comments": [
    {
      "key": {
        "uuid": "e60d47e8_b5071450",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1117099
      },
      "writtenOn": "2017-04-07T11:31:02Z",
      "side": 1,
      "message": "super nitpick: if -\u003e If",
      "range": {
        "startLine": 9,
        "startChar": 49,
        "endLine": 9,
        "endChar": 51
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37e4a15b_e9b23431",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3542,
      "author": {
        "id": 1117099
      },
      "writtenOn": "2017-04-07T11:31:02Z",
      "side": 1,
      "message": "Declare where it\u0027s used?\n\nAlso, I find \u0027ok\u0027 only a good name if it\u0027s used very locally (where the reader can immediately see which thing is supposed to be \u0027ok\u0027 or not. If the name is valid across a larger chunk of code, it\u0027s not really very useful. (Kind of like how \u0027i\u0027 or \u0027iter\u0027 is a useful variable name for a loop induction variable, but a terribly name anywhere else.)",
      "range": {
        "startLine": 3541,
        "startChar": 2,
        "endLine": 3542,
        "endChar": 0
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3adb5c89_66a299a3",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3552,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-04-07T07:47:39Z",
      "side": 1,
      "message": "Would it make sense to add a comment here explaining where we are in the stream? For normal functions the code looks like we\u0027re in \"(async)? function (*)? \u003cHERE\u003e foo() {Â ... }\"  and for arrow functions... where? Do generators (function * foo() { }) work correctly too?\n\nNow that I think of it, it would make sense to either augment the CompilerDispatcher unit tests to test with other function kinds too, not just normal (non-async non-generator non-arrow) *or* add a DCHECK (or maybe even CHECK) here that only normal functions end here. (But the tests don\u0027t need to be in this CL, they can be a follow up.)",
      "range": {
        "startLine": 3552,
        "startChar": 4,
        "endLine": 3552,
        "endChar": 8
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1d85c77a_ba763525",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3555,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-04-07T07:47:39Z",
      "side": 1,
      "message": "Can\u0027t this function be sometimes called for arrow functions?\n\nYou can check info-\u003efunction_kind(), and either assert that it\u0027s not an arrow function, or handle the arrow functions here too.\n\nBut for now, this code path is not used in production at all, right? Since only CompilerDispatcher unit tests and your feature create parse jobs for functions. So maybe DCHECK the kind?",
      "range": {
        "startLine": 3555,
        "startChar": 27,
        "endLine": 3555,
        "endChar": 33
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1fdc688f_6e9611fa",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3555,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-04-07T07:51:11Z",
      "side": 1,
      "message": "Ah,I just saw your other CL. info-\u003efunction_kind() is not correct here. It should be though.",
      "parentUuid": "1d85c77a_ba763525",
      "range": {
        "startLine": 3555,
        "startChar": 27,
        "endLine": 3555,
        "endChar": 33
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f669b1a0_6f720a0d",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3559,
      "author": {
        "id": 1117099
      },
      "writtenOn": "2017-04-07T11:31:02Z",
      "side": 1,
      "message": "Initialize?\n\nDo we know whether ParseIdentifierOrStrictReservedWord will always initialize/modify *is_strict_reserved (if given)?",
      "range": {
        "startLine": 3559,
        "startChar": 13,
        "endLine": 3559,
        "endChar": 31
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "065d539e_8721fb65",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3560,
      "author": {
        "id": 1117099
      },
      "writtenOn": "2017-04-07T11:31:02Z",
      "side": 1,
      "message": "I\u0027m surprised this works, because this would probably advance the Scanner + stream, and hence DoParseFunction would suddenly start at a different offset than it\u0027s used to. Is there - somewhere else? - code to compensate for this?",
      "range": {
        "startLine": 3560,
        "startChar": 24,
        "endLine": 3560,
        "endChar": 59
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dfd601e7_e77dd616",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3562,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-04-07T07:47:39Z",
      "side": 1,
      "message": "Makes sense to resolve this FIXME before landing this...",
      "range": {
        "startLine": 3562,
        "startChar": 22,
        "endLine": 3562,
        "endChar": 27
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d76430b4_85d475dd",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3563,
      "author": {
        "id": 1117099
      },
      "writtenOn": "2017-04-07T11:31:02Z",
      "side": 1,
      "message": "Why?\n\n(I thought treatment of \u0027future strict reserved\u0027 keywords would depend strict-vs-non-strict mode. Not sure if this is factored in already.)",
      "range": {
        "startLine": 3563,
        "startChar": 8,
        "endLine": 3563,
        "endChar": 43
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf7debd5_d5c809a9",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 3568,
      "author": {
        "id": 1117099
      },
      "writtenOn": "2017-04-07T11:31:02Z",
      "side": 1,
      "message": "And... what if !ok ?",
      "range": {
        "startLine": 3568,
        "startChar": 5,
        "endLine": 3568,
        "endChar": 0
      },
      "revId": "1c980f60782504ed6413a8b416b499ec66016d46",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}