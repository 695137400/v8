{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "73587948_264a9b17",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2020-11-04T17:30:08Z",
      "side": 1,
      "message": "lgtm, but please ensure that the bots that failed last time work with the new test",
      "revId": "89360b958106c4afa0abf2661d75217e72108567",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ef64f37_e73196a4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-11-04T17:32:24Z",
      "side": 1,
      "message": "Are you sure that this still fails with the original bug?",
      "revId": "89360b958106c4afa0abf2661d75217e72108567",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "676887ac_8eb9bcd6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2020-11-04T17:38:01Z",
      "side": 1,
      "message": "With small stack size like in this case it should at least be crashing on ASAN builds without the fix.",
      "parentUuid": "8ef64f37_e73196a4",
      "revId": "89360b958106c4afa0abf2661d75217e72108567",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ee9def2_3bb8b0e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-11-04T17:51:09Z",
      "side": 1,
      "message": "Ah I see, ASAN is the key. So what was wrong with the old test which also used a small stack limit but only failed on ARM, not on Intel IIRC? test/mjsunit/regress/regress-353058.js",
      "parentUuid": "676887ac_8eb9bcd6",
      "revId": "89360b958106c4afa0abf2661d75217e72108567",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6befa8b_eec8dfa3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1368302
      },
      "writtenOn": "2020-11-04T18:08:41Z",
      "side": 1,
      "message": "I guess the magic is the walk backwards and forwards of the stack that is not present test/mjsunit/regress/regress-353058.js. In the previous test, the code would hit the stackoverflow check from InterpreterEntry. The current one makes sure to hit both code paths.",
      "parentUuid": "5ee9def2_3bb8b0e0",
      "revId": "89360b958106c4afa0abf2661d75217e72108567",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d769f7a9_9e058ef3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2020-11-04T18:10:43Z",
      "side": 1,
      "message": "There were two keys:\n1) we needed --no-opt to avoid stack overflows caused by OSR compilation\n2) when we try to call f() near the stack limit (as in regress-353058.js) the interpreter trampoline catches the SO case, but in the new test we return from recursion and keep calling f(), so that eventually the interpreter trampoline gets enough stack space while the new stack check in InvokePrologue() still triggers (or in case of non-fixed version it\u0027ll try to access memory beyond the stack limit, which should be catchable by ASAN).",
      "parentUuid": "5ee9def2_3bb8b0e0",
      "revId": "89360b958106c4afa0abf2661d75217e72108567",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}