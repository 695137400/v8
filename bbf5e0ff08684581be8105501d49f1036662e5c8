{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b994bb00_5b1fd115",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2022-10-04T06:39:01Z",
      "side": 1,
      "message": "Thanks! LGTM % the open question for Mathias, and the discussion about tracking nesting levels.",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1fc2bcd2_422e57d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-06T13:10:15Z",
      "side": 1,
      "message": "Thanks for your comments, Markus!",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7542e296_8705c764",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 428,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T00:03:40Z",
      "side": 1,
      "message": "Please remove the comma. (I recognize it from my native German language :-)",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6ab11284_61879fff",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 428,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-06T13:10:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7542e296_8705c764",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ae13b34_952cbd5f",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 448,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T00:03:40Z",
      "side": 1,
      "message": "Wouldn\u0027t it be easier to use UnicodeSet throughout the parser, and build the ZoneList or whatever you need for the matcher at the end -- rather than going back \u0026 forth when you need to fetch properties or perform set operations?\n\nYou might even try to use UnicodeSet in the matcher (after freeze()ing it).",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f849822_a74bab3d",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 448,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-06T13:10:15Z",
      "side": 1,
      "message": "I think if we had scf mappings in the ICU library (like you mentioned in another comment), we could simplify quite a lot stuff.\nEven without it might be better to use UnicodeSet throughout, but we would need to try and measure the performance impact. This is definetly something I see out of scope of this CL.\n\nAd using UnicodeSet in the matcher:\nThat is non-trivial as RegExp patterns are JS objects managed by the V8 Heap/GC.\nThere were ideas about using the ICU library for unicode property values instead of creating large character classes in the past, but I think becuase of the point mentioned above + performance implications we never got to try it out.\n\nI don\u0027t know all the details. Jakob, please correct me if I am wrong or I missed something.",
      "parentUuid": "5ae13b34_952cbd5f",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76458e4b_d50e527b",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 448,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T18:44:25Z",
      "side": 1,
      "message": "ICU UnicodeSet uses an inversion list for ranges of code points, since its creation in the late 1990s, with optimized algorithms for set operations. Building and manipulating it should be as fast as anything working on ranges, and you would benefit from less code in Chromium.\n\nI don\u0027t understand the part about \"using the ICU library for unicode property values\". Do you have a separate copy of the Unicode properties data? If so, why?\n\nI assume that parsing a regex and building a matcher is less performance-sensitive than doing the matching, but I also assume that you would find it just as fast using UnicodeSet. I do understand if you want to explore that separately, but it seems sad to add so much set operations code in this PR when all of that is redundant with functionality in a library that Chromium is already using.\n\nAs for runtime matching: I don\u0027t know if ICU would fit into your matcher. It does have optimizations for fast \"contains(code point)\" after you call \"freeze()\" on it. Strings are much less optimized; they are stored in a vector. It might be worth exploring to pull the strings out and match them like you normally do in a disjunction, but to use UnicodeSet for matching code points. Note that UnicodeSet also has optimized span() etc. functions for fast iteration over a substring of elements contained or not contained in the set.",
      "parentUuid": "2f849822_a74bab3d",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9122de89_1892ca8f",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 448,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-07T13:23:57Z",
      "side": 1,
      "message": "ad \"using the ICU library for unicode property values\": We do use the ICU library for property values to create RegExp character ranges (but those ranges can get quite large). What I was referring to was an idea (and I might misremember/misunderstood it) to use ICU at runtime to check for property values.\n\nWhile building a matcher is less performance-sensitive than doing the matching, we still had performance issues in the past (e.g. https://crbug.com/v8/6727).\nI did a quick microbenchmark comparing the current implementation with one that uses the ICU functions and ICU was ~11% slower. This doesn\u0027t mean that the ICU implementation is strictly slower though, because the ICU version includes conversions from our `CharacterRange`s to `UnicodeSet`. So if we would use `UnicodeSet` throughout the parser, we should re-evaluate this.",
      "parentUuid": "76458e4b_d50e527b",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eca942b7_888a3b36",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 462,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T00:03:40Z",
      "side": 1,
      "message": "I don\u0027t think this does what we need.\n\nEven in /u mode, [USET_CASE_INSENSITIVE](https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/uset_8h.html#a16af7b253440dadd46a80a4b9fddba4da740685a55f610ca84868b60aef83db7b) does more than simple case folding. I see that you build it without strings, and later removeAllStrings(), but I suspect that the behavior is not 100% the same.\n\nIn /v mode, once you support strings (which I realize you don\u0027t yet in this PR), we do need to handle strings, and we won\u0027t want USET_CASE_INSENSITIVE to add a ß when the input contains \"ss\".\n\nI will try to find time in the next few days and write a piece of ICU-using code that adds the scf mappings according to the proposed MaybeSimpleCaseFolding(). Once the spec and the implementations settle, I can propose that as a new API option and move it into the ICU library.\n\nAre you sure that you want to just *add* the scf mappings, and not remove the non-scf versions like the proposed spec says?",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 462,
        "endChar": 3
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f0510d2_1f2bf152",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 462,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-06T13:10:15Z",
      "side": 1,
      "message": "May I ask why you suspect that the behavior is not correct for /u?\n\nFor /v with strings we won\u0027t be able to use the current methods in the ICU library (as far as I am aware), because as you mentioned the library does full case folding instead of simple case folding and with strings we won\u0027t be able to use the hack we use right now to guarantee that ß is not turned into \u0027ss\u0027.\n\nIt would be really awesome, if you could add scf mappings to ICU!\n\nAbout just adding: I think it should work, but it can be improved. That\u0027s why I added the comment/TODO here to `CharacterRange::AddUnicodeCaseEquivalents` (line 424).",
      "parentUuid": "eca942b7_888a3b36",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 462,
        "endChar": 3
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a635d4df_e11db5b4",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 462,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T18:44:25Z",
      "side": 1,
      "message": "Both /u and /v use simple case folding. I am not confident that your workaround achieves equivalent results in all cases. I don\u0027t know if there are real differences until I can write scf-only code and compare the two.\n\n\u003e It would be really awesome, if you could add scf mappings to ICU!\n\nICU of course has API+data for scf, just not currently available via UnicodeSet::closeOver(). I will write code that does MaybeSimpleCaseFolding() using UnicodeSet and scf APIs.",
      "parentUuid": "6f0510d2_1f2bf152",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 462,
        "endChar": 3
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3b76b7c_ddfea01f",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 462,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-07T13:23:57Z",
      "side": 1,
      "message": "If you could point me to the ICU API for scf, I would be happy to give it a shot myself. I was just not able to find it in the documentation myself :/",
      "parentUuid": "a635d4df_e11db5b4",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 462,
        "endChar": 3
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4de4cce_557fe6c3",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 462,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-08T00:41:17Z",
      "side": 1,
      "message": "Please see https://github.com/unicode-org/icu/pull/2225/files\n- scfCloseOver() is a condensed version of your code here\n- scfDirect() implements MaybeSimpleCaseFolding(), including support for strings\n\nI have some interesting test cases for scfDirect() which pass.\n\nI have code that compares the results of both for single-code-point sets of lots of code points (all except controls and Chinese/Korean).\nThere are 7 code points where closeOver() yields more characters than the ECMAScript spec. For example, you should see an incorrect match of `\\0390` given `[\\u1FD3]`.\nThese differences actually smell like a bug in the derivation of Unicode CaseFolding.txt, but due to stability guarantees they cannot be fixed.",
      "parentUuid": "c3b76b7c_ddfea01f",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 462,
        "endChar": 3
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce58f886_b3323a2a",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 462,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-11T14:29:58Z",
      "side": 1,
      "message": "Thanks a lot Markus!\nFirst, The example code provides very useful hints for implementing a correct SimpleCaseFolding in V8.\nAnd you just found a bug we had for `/ui` RegExps. Filed at https://crbug.com/v8/13377 and will address in a follow-up.",
      "parentUuid": "f4de4cce_557fe6c3",
      "range": {
        "startLine": 455,
        "startChar": 0,
        "endLine": 462,
        "endChar": 3
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c247e50_5b2b643b",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 1516,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T00:03:40Z",
      "side": 1,
      "message": "This would be so much simpler using icu::UnicodeSet which also supports multi-character strings...\n- union \u003d addAll(set)\n- intersection \u003d retainAll(set)\n- subtraction \u003d removeAll(set)\n\nhttps://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1UnicodeSet.html",
      "range": {
        "startLine": 1516,
        "startChar": 2,
        "endLine": 1516,
        "endChar": 30
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdf6c986_292a30f9",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 1516,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-06T13:10:15Z",
      "side": 1,
      "message": "I initially thought (misunderstood), that UnicodeSet operations work on a per-character basis instead of ranges.\nThat\u0027s why I initially decided to implement the operations for ranges myself.\nIIUC I was wrong about the UnicodeSet implementation and it indeed also works on ranges.\n\nThis is related to your comment about using UnicodeSets more throughout the implementation: We might be able to simplify a lot of things by using more ICU methods, but this should be a separate project IMO.",
      "parentUuid": "1c247e50_5b2b643b",
      "range": {
        "startLine": 1516,
        "startChar": 2,
        "endLine": 1516,
        "endChar": 30
      },
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd5328da_a3077dd6",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 1601,
      "author": {
        "id": 1249238
      },
      "writtenOn": "2022-10-06T00:03:40Z",
      "side": 1,
      "message": "FYI [UnicodeSet::complement()](https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1UnicodeSet.html#a60460749e20685e496e819b368496089) \"negates\" all code points. It does not remove or modify strings. But we are not negating sets/classes that contain (or even \"may contain\") strings. Could DCHECK for .hasStrings().",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d70136ef_387cfa21",
        "filename": "src/regexp/regexp-compiler-tonode.cc",
        "patchSetId": 7
      },
      "lineNbr": 1601,
      "author": {
        "id": 1468500
      },
      "writtenOn": "2022-10-06T13:10:15Z",
      "side": 1,
      "message": "As mentioned in other comments: Worth trying to replace more of our implementations with UnicodeSets (in a follow-up).",
      "parentUuid": "fd5328da_a3077dd6",
      "revId": "bbf5e0ff08684581be8105501d49f1036662e5c8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}