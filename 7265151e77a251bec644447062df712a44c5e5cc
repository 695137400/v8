{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5b44edc3_577d3336",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-01-31T16:35:32Z",
      "side": 1,
      "message": "Do you have a performance improvement estimate or measurement here? We\u0027re wondering how much this can actually help given that we have to do a lot of the checks anyway.",
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fa9c0d4_7ced25ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-02-01T09:14:11Z",
      "side": 1,
      "message": "For the code I picked from React-TodoMVC, I saw a +20% performance gain when enabling Maglev and Turbofan:\n```\nconst props \u003d {};\nfor (propName in config) {\n  if (hasOwnProperty.call(config, propName) \u0026\u0026\n      !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] \u003d config[propName];\n  }\n}\n```\nI will try it in pinpoint to see the performance impact in the benchmark.\n\nFor the checks introduced by this CL, I think we only have overhead at runtime because we allow ic state transition from `MegaTransition` to `Megamorphic`. The checks in Builtin_KeyedStoreIC_Transition is still simpler than the `CodeStubAssembler::TryToName` heuristic in Megamorphic state. We can also further optimize them in Maglev/Turbofan because we know that the key is guaranteed to be a unique name. Avoiding these checks bring +8% more gain to the microbench.",
      "parentUuid": "5b44edc3_577d3336",
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fbfd47f_1c606785",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 795,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-01-31T16:35:32Z",
      "side": 1,
      "message": "this is not how we would do this. Instead, in the polymorphic case, we would allow a transition to MEGATRANSITION  (similar to UpdateMegaDOMIC), and the handling in the MEGATRANSITION case would assume that if we are in the runtime, we must have missed, and therefore we need to go megamorphic.",
      "range": {
        "startLine": 790,
        "startChar": 0,
        "endLine": 795,
        "endChar": 16
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "149f4da5_4547f89c",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-01-31T16:35:32Z",
      "side": 1,
      "message": "This is not strong enough, because of inlining. Do you actually need to deopt here at all though? The miss path will still work.",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e95e945a_9294e5bb",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-02-01T09:14:11Z",
      "side": 1,
      "message": "No, it is not necessary to deopt because the miss path still work. Recompiling the code with megamorphic ic can avoid calling to runtime for performance purpose. Actually we have the following methods to deal with the ic miss in optimized code:\n1. Just call runtime.\n2. Mark this function as deopt and lazily deoptimize it.\n3. In Builtin_KeyedStoreIC_Transition , try descriptor array lookup after transition array lookup miss.\n\nWDYT of the solutions?",
      "parentUuid": "149f4da5_4547f89c",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4edb155b_efc0d739",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-02-01T09:48:37Z",
      "side": 1,
      "message": "We discussed this a bit internally -- we\u0027re wondering how much benefit we could get from \"simply\" changing the order of the generic megamorphic builtin to e.g. check for transitions first, or at least check for a single transition (which is a cheap check).\n\nDeopting otherwise sounds like the right choice, so that we don\u0027t get \"stuck\" in a medium efficiency path, though we\u0027d need to figure out exactly how to do it (we\u0027re considering a stack walk to find the calling optimized code). We could also consider tightening the fast path to simple transitioning fast data stores, make the builtin return just the map (or 0 on a miss), and emit the actual field store in the optimized code. Something like this would have the big advantage that we can guarantee that the store has no side effects, which could help with optimising the surrounding code.\n\nThere\u0027s a couple of different options here and they\u0027re all worth exploring and benchmarking against each other.",
      "parentUuid": "e95e945a_9294e5bb",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}