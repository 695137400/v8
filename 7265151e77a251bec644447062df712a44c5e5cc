{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5b44edc3_577d3336",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-01-31T16:35:32Z",
      "side": 1,
      "message": "Do you have a performance improvement estimate or measurement here? We\u0027re wondering how much this can actually help given that we have to do a lot of the checks anyway.",
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fa9c0d4_7ced25ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-02-01T09:14:11Z",
      "side": 1,
      "message": "For the code I picked from React-TodoMVC, I saw a +20% performance gain when enabling Maglev and Turbofan:\n```\nconst props \u003d {};\nfor (propName in config) {\n  if (hasOwnProperty.call(config, propName) \u0026\u0026\n      !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] \u003d config[propName];\n  }\n}\n```\nI will try it in pinpoint to see the performance impact in the benchmark.\n\nFor the checks introduced by this CL, I think we only have overhead at runtime because we allow ic state transition from `MegaTransition` to `Megamorphic`. The checks in Builtin_KeyedStoreIC_Transition is still simpler than the `CodeStubAssembler::TryToName` heuristic in Megamorphic state. We can also further optimize them in Maglev/Turbofan because we know that the key is guaranteed to be a unique name. Avoiding these checks bring +8% more gain to the microbench.",
      "parentUuid": "5b44edc3_577d3336",
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fbfd47f_1c606785",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 795,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-01-31T16:35:32Z",
      "side": 1,
      "message": "this is not how we would do this. Instead, in the polymorphic case, we would allow a transition to MEGATRANSITION  (similar to UpdateMegaDOMIC), and the handling in the MEGATRANSITION case would assume that if we are in the runtime, we must have missed, and therefore we need to go megamorphic.",
      "range": {
        "startLine": 790,
        "startChar": 0,
        "endLine": 795,
        "endChar": 16
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "149f4da5_4547f89c",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-01-31T16:35:32Z",
      "side": 1,
      "message": "This is not strong enough, because of inlining. Do you actually need to deopt here at all though? The miss path will still work.",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e95e945a_9294e5bb",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-02-01T09:14:11Z",
      "side": 1,
      "message": "No, it is not necessary to deopt because the miss path still work. Recompiling the code with megamorphic ic can avoid calling to runtime for performance purpose. Actually we have the following methods to deal with the ic miss in optimized code:\n1. Just call runtime.\n2. Mark this function as deopt and lazily deoptimize it.\n3. In Builtin_KeyedStoreIC_Transition , try descriptor array lookup after transition array lookup miss.\n\nWDYT of the solutions?",
      "parentUuid": "149f4da5_4547f89c",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4edb155b_efc0d739",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-02-01T09:48:37Z",
      "side": 1,
      "message": "We discussed this a bit internally -- we\u0027re wondering how much benefit we could get from \"simply\" changing the order of the generic megamorphic builtin to e.g. check for transitions first, or at least check for a single transition (which is a cheap check).\n\nDeopting otherwise sounds like the right choice, so that we don\u0027t get \"stuck\" in a medium efficiency path, though we\u0027d need to figure out exactly how to do it (we\u0027re considering a stack walk to find the calling optimized code). We could also consider tightening the fast path to simple transitioning fast data stores, make the builtin return just the map (or 0 on a miss), and emit the actual field store in the optimized code. Something like this would have the big advantage that we can guarantee that the store has no side effects, which could help with optimising the surrounding code.\n\nThere\u0027s a couple of different options here and they\u0027re all worth exploring and benchmarking against each other.",
      "parentUuid": "e95e945a_9294e5bb",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81cbaeb3_ee29644a",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-02-01T11:05:30Z",
      "side": 1,
      "message": "Thanks for your suggestion!\n\nI will try the solutions like changing the order of the generic megamorphic builtin and evaluate their performance impacts. I will also prepare for a design doc for discussion.",
      "parentUuid": "4edb155b_efc0d739",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "837088be_b67080c7",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-03-15T11:27:21Z",
      "side": 1,
      "message": "I\u0027ve evaluated the performance of some of the options from our discussion:\n1) Transition Array Lookup before the Description array lookup.\n2) Introduce MegaTransition state for all keyed stores. \n3) Introduce MegaTransition state only for enumerated key stores. (The key is from for-in statement)\n\nAccording to the tests, option 1) doesn\u0027t seem to benefit performance:\nhttps://pinpoint-dot-chromeperf.appspot.com/job/11f5e50ade0000\n\nOption 2) even have some regression, which I think is due to the deoptimization. \n\nOption 3) is the only option that might be beneficial (+0.6~1% to speedometer2):\nhttps://pinpoint-dot-chromeperf.appspot.com/job/102f95535e0000\nhttps://pinpoint-dot-chromeperf.appspot.com/job/161435765e0000\nhttps://pinpoint-dot-chromeperf.appspot.com/job/11df9eaa5e0000\n\nComparing 2) and 3), I think 3) is better because it is less likely to have deoptimization in JIT code (1/450000 of the chance to deopt), and we can avoid the `TryToName` heuristic because we know that the key is UniqueName.\n\nI haven\u0027t try the options that tighten the fast path to simple transitioning fast data stores yet, I think we can make it as a TODO because it sounds to depends on the collected feedback in this CL.\n\nDo you have any suggestion and comments for our next step?",
      "parentUuid": "81cbaeb3_ee29644a",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ef6d4ec_3d09b133",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2024-03-15T12:41:48Z",
      "side": 1,
      "message": "\u003e 1/450000 of the chance to deopt\n\nWhere does this number come from? Just counting deopts with the two different options? Do you know why option 2) was deopting so much?",
      "parentUuid": "837088be_b67080c7",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dcde92f_3f923d4e",
        "filename": "src/ic/ic.cc",
        "patchSetId": 7
      },
      "lineNbr": 801,
      "author": {
        "id": 1420650
      },
      "writtenOn": "2024-03-18T02:32:01Z",
      "side": 1,
      "message": "First of all in the current CL I have a Builtin for `MegaTransition` state that is only called from Maglev/Turbofan JIT\u0027d code. I added some counters in this Builtin (by Builtin PGO profiling) and the number is calculated by `times_to_call_runtime_ic_miss/call_count_of_this_builtin`.\n\nOne of the reason that 2) have more deoptimizations is that in 2) I didn\u0027t deal with dictionary properties in `MegaTransition` state. If in Ignition/Sparkplug we only saw fast-mode receiver but encounter a dictionary-mode receiver in Maglev/Turbofan, we will have to deoptimize.\n\nFor 3), if the key is coming from `for-in`\u0027s enum cache, the receiver is more likely to stay in fast mode. In the future we can even have some tricks to avoid receiver to have `fast mode -\u003e dictionary mode` conversion in bytecode.",
      "parentUuid": "3ef6d4ec_3d09b133",
      "range": {
        "startLine": 797,
        "startChar": 10,
        "endLine": 801,
        "endChar": 9
      },
      "revId": "7265151e77a251bec644447062df712a44c5e5cc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}