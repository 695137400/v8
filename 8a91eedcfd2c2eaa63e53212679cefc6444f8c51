{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "451b6ea8_dc40cc88",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 9
      },
      "lineNbr": 3304,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2020-12-16T12:00:01Z",
      "side": 1,
      "message": "This adds a cost to all LHS for optional chaining. Can you find a way to push this down into the relevant paths only? The parser is very performance sensitive and we should avoid adding code for one case on the fast path for all.",
      "revId": "8a91eedcfd2c2eaa63e53212679cefc6444f8c51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44a553f3_f56fa431",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 9
      },
      "lineNbr": 3304,
      "author": {
        "id": 1341998
      },
      "writtenOn": "2020-12-16T15:45:22Z",
      "side": 1,
      "message": "What if, once an optional chain is detected, a separate function handles parsing the remainder of the chain?",
      "parentUuid": "451b6ea8_dc40cc88",
      "revId": "8a91eedcfd2c2eaa63e53212679cefc6444f8c51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5bda4e99_ca7d16a6",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 9
      },
      "lineNbr": 3304,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2020-12-17T15:20:43Z",
      "side": 1,
      "message": "I\u0027m not sure what that would look like. This function is copied twice due to parser+preparser though, so it may start using quite a lot of binary space.",
      "parentUuid": "44a553f3_f56fa431",
      "revId": "8a91eedcfd2c2eaa63e53212679cefc6444f8c51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4294c753_8dade0de",
        "filename": "src/parsing/parser-base.h",
        "patchSetId": 9
      },
      "lineNbr": 3304,
      "author": {
        "id": 1341998
      },
      "writtenOn": "2020-12-17T19:21:32Z",
      "side": 1,
      "message": "I played around and I\u0027m pretty sure I was over complicating the implementation, tests pass if I only capture the source range position when we observe a ?.:\n\n      case Token::QUESTION_PERIOD: {\n        if (is_optional) {\n          ReportUnexpectedToken(peek());\n          return impl()-\u003eFailureExpression();\n        }\n        // Include the ?. in the source range position.\n        optional_link_begin \u003d scanner()-\u003epeek_location().beg_pos;\n        Consume(Token::QUESTION_PERIOD);\n        is_optional \u003d true;\n        optional_chaining \u003d true;\n        continue;\n      }\n\nWhen recording the arrange, I added a \u0027continue\u0027:\n\n    if (is_optional) {\n      SourceRange chain_link_range(optional_link_begin, end_position());\n      impl()-\u003eRecordExpressionSourceRange(result, chain_link_range);\n      is_optional \u003d false;\n      continue;\n    }\n\nSo there should be no additional comparisons than before this code change (as the next line of code already checked is_optional):\n\n} while (is_optional || Token::IsPropertyOrCall(peek()));\n\nI think we could eliminate some additional comparisons if we did something like this, but was wondering if it\u0027s worthwhile?\n\n\n    if (is_optional) {\n      SourceRange chain_link_range(optional_link_begin, end_position());\n      impl()-\u003eRecordExpressionSourceRange(result, chain_link_range);\n      is_optional \u003d false;\n      continue;\n    } else if (Token::IsPropertyOrCall(peek()) {\n      continue;\n    } else {\n      break;\n    }\n    } while (is_optional || Token::IsPropertyOrCall(peek()));",
      "parentUuid": "5bda4e99_ca7d16a6",
      "revId": "8a91eedcfd2c2eaa63e53212679cefc6444f8c51",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}