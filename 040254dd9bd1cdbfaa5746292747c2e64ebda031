{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "48084d0e_fb8020a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 11,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2023-11-13T09:47:49Z",
      "side": 1,
      "message": "Why is that a problem?\nA direct handle to an on stack object should be safe imo.",
      "range": {
        "startLine": 11,
        "startChar": 30,
        "endLine": 11,
        "endChar": 53
      },
      "revId": "040254dd9bd1cdbfaa5746292747c2e64ebda031",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b0a73bf_2d5dee6d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 11,
      "author": {
        "id": 1147189
      },
      "writtenOn": "2023-11-13T13:37:56Z",
      "side": 1,
      "message": "It\u0027s the same problem we had with out-of-stack `v8::Local`, externally. A heap-allocated vector of `Handle\u003cT\u003e` is indeed safe, and will remain so (as long as `Handle\u003cT\u003e` is indirect). A heap-allocated vector of `DirectHandle\u003cT\u003e` is not safe, because the pointers are not scanned conservatively. If we need such vectors, we will have to introduce a `DirectHandleVector\u003cT\u003e`, as we did with `v8::LocalVector`.\n\nThis CL eliminates some instances where the vector is not really required, so that they can subsequently be migrated.",
      "parentUuid": "48084d0e_fb8020a9",
      "range": {
        "startLine": 11,
        "startChar": 30,
        "endLine": 11,
        "endChar": 53
      },
      "revId": "040254dd9bd1cdbfaa5746292747c2e64ebda031",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f664c9e7_1bb06b97",
        "filename": "src/heap/factory.h",
        "patchSetId": 2
      },
      "lineNbr": 807,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2023-11-13T09:47:49Z",
      "side": 1,
      "message": "Are you sure about this? It seems wrong to me.\n`sizeof...` would have nothing to unpack here, so you just checking `sizeof(MemorySpan)` which would be fixed. I assume you want to check how many args were passed, but that is dynamic and can\u0027t be constexpr imo.",
      "range": {
        "startLine": 807,
        "startChar": 25,
        "endLine": 807,
        "endChar": 40
      },
      "revId": "040254dd9bd1cdbfaa5746292747c2e64ebda031",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9db01e5f_014e326f",
        "filename": "src/heap/factory.h",
        "patchSetId": 2
      },
      "lineNbr": 807,
      "author": {
        "id": 1147189
      },
      "writtenOn": "2023-11-13T13:37:56Z",
      "side": 1,
      "message": "This `sizeof...` counts the number of arguments in the parameter pack passed to this function template: https://en.cppreference.com/w/cpp/language/sizeof...\nIt is known at compile-time when the template is instantiated, hence the `constexpr` both in `N` and in the `if` below.",
      "parentUuid": "f664c9e7_1bb06b97",
      "range": {
        "startLine": 807,
        "startChar": 25,
        "endLine": 807,
        "endChar": 40
      },
      "revId": "040254dd9bd1cdbfaa5746292747c2e64ebda031",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}