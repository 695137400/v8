{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "51992537_54944691",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 1
      },
      "lineNbr": 2457,
      "author": {
        "id": 1323977
      },
      "writtenOn": "2023-01-09T07:11:42Z",
      "side": 1,
      "message": "I hope I\u0027m holding this right. The \"VisitTryFinallyStatement\" does the same thing.",
      "range": {
        "startLine": 2457,
        "startChar": 6,
        "endLine": 2457,
        "endChar": 24
      },
      "revId": "95e4e7a87feab8ec24d6782b45fd460895064892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05f556d8_b292da13",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 1
      },
      "lineNbr": 2457,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2023-01-09T07:36:26Z",
      "side": 1,
      "message": "Hm, not sure, `VisitTryFinallyStatement` can do this because that\u0027s a user try-finally block, while this is a de-sugared one. We used to have a DESUGARING prediction but it got removed, and it was roughly equivalent to CAUGHT (https://chromium-review.googlesource.com/c/v8/v8/+/3003468). Then again, that one was for when both exception and catch are from desugared code, while here the exception is a user exception. What are the consequences if this is `CAUGHT` and not `catch_prediction()`?\n\nCan you also check BuildFinalizeIteration? That one suppresses the thrown exception if the continuation token is `RETHROW`.",
      "parentUuid": "51992537_54944691",
      "range": {
        "startLine": 2457,
        "startChar": 6,
        "endLine": 2457,
        "endChar": 24
      },
      "revId": "95e4e7a87feab8ec24d6782b45fd460895064892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6edde533_bf710c13",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 1
      },
      "lineNbr": 2457,
      "author": {
        "id": 1323977
      },
      "writtenOn": "2023-01-09T09:15:23Z",
      "side": 1,
      "message": "Maybe I understood catch prediction in the bytecode generator wrong. So I added two more test cases, a throwing \u0027.next\u0027 and a throwing \u0027.return\u0027 iterator.\n\nBoth of the calls are marked as \"UNCAUGHT\" in the generated bytecode, so when the debugger looks for a catch handler on the stack frame for `iterateIterator` and `iterateWithBreak` respectively, it doesn\u0027t find one (and also not further up the stack). Even though both bytecodes are surrounded by the user-written try-catch.\n\nThis is the reason why the initial CL uses the parent catch prediction: It\u0027s a try-finally block, so IIUC then any thrown exception is propagated up anyway, making it look like the de-sugared try/finally is not even there.\n\nThe only bit that confuses me is the re-throw logic in the finally block, although I wasn\u0027t able to follow when an exception would be swallowed vs when it would be propagated.",
      "parentUuid": "05f556d8_b292da13",
      "range": {
        "startLine": 2457,
        "startChar": 6,
        "endLine": 2457,
        "endChar": 24
      },
      "revId": "95e4e7a87feab8ec24d6782b45fd460895064892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "631aa91c_86a9af34",
        "filename": "src/interpreter/bytecode-generator.cc",
        "patchSetId": 1
      },
      "lineNbr": 2457,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2023-01-09T10:53:36Z",
      "side": 1,
      "message": "you also need to add tests for the for loop body itself throwing; in particular, an exception is swallowed when: a) the for loop body throws, and b) .return _also_ throws. Then, the b) exception is swallowed because the a) exception is rethrown.\n\nAll that said, the more I page this logic back in, the more inheriting the parent catch prediction seems to be the right thing to do (both here and in BuildFinalizeIteration)",
      "parentUuid": "6edde533_bf710c13",
      "range": {
        "startLine": 2457,
        "startChar": 6,
        "endLine": 2457,
        "endChar": 24
      },
      "revId": "95e4e7a87feab8ec24d6782b45fd460895064892",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}