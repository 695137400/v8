{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f1dadce9_64b2cd8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2021-01-28T21:48:58Z",
      "side": 1,
      "message": "Hello Igor, do you know when you might have time to take a look?",
      "revId": "7e51296e6928e1b6faf6708862e47a05a2dc9c26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57767d8d_6f648db4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2021-01-29T08:00:27Z",
      "side": 1,
      "message": "Hello Seth, I\u0027m sorry for delays and thank you for the CL. \n\nI have some comments.\n\n@relaxedRead - sgtm.\nI agree that the old way of accessing arrays of \"inlined structs\" is worth improving.\n\nI\u0027m a bit concerned about the new API. I see two scenarios of how these structs/fields can be accessed:\n  a) all or nothing, when we need to load/store all fields at once. \n  b) we need to access only some fields in the array.\n\nScenario (a) is handled fine by the API, but (b) seems to be error-prone and confusing (see Jakob\u0027s comments re Optional fields) and less efficient compared with what we had before. In addition, the fact that such structs might contain raw tagged pointers seems scary to me.\n\nI think if you could extend the API with a way to provide a reference to an existing struct element in the array then the gap between this API and C++\u0027y way of dealing with arrays might be reduced.\n\nWhat I have in mind is that Torque might also generate one-word \"view\" objects for such structs which would contain an address of the struct and accessors to the fields of the struct (similar to how C++ code \"sees\" objects stored in V8 heap).\nThis should address (b) use cases. The code that accesses only some of the fields will look like\n  Name name \u003d module.vars(j);\n  module.vars(i).set_name(name);\n\nor\n  Handle\u003cName\u003e name(module.vars(j).name(), isolate);\n  \n  TqModuleVariableRef var_ref \u003d module.vars(i); // just a one-word object\n  var_ref.set_name(*name);\n  var_ref.set_index(42);\n  var_ref.set_properties(props);\n\nNote, that in this example \n1) we have to write similar amount of code anyway as with the TqSetterStructModuleVariable approach. \n2) we access only those variables that we want to access and we can create handles if we need to without leaving TqGetterStructModuleVariable struct with a raw value.\n3) we have full fine-grained control over whether we want to trigger write barrier for storing to particular field.\n4) since module.vars(i) is just a simple address computation, the C++ compiler will have an opportunity to combine it into complex addressing mode for particular struct field access.\n5) we might need to teach GC mole bot to treat TqModuleVariableRef/TqGetterStructModuleVariable/TqSetterStructModuleVariable as raw tagged pointers and ensure GC does not invalidate them unexpectedly.\n\nWe might still have a TqSetterStructModuleVariable-like structure (without base::Optional) for initializing all fields at once, but I\u0027m not sure it\u0027ll be more readable/cleaner than just calling setters one by one. \n\nPlease take my comments with a grain of salt since I haven\u0027t been following the direction of Torque language development, so I might be missing things that have already beed discussed before.",
      "parentUuid": "f1dadce9_64b2cd8e",
      "revId": "7e51296e6928e1b6faf6708862e47a05a2dc9c26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f4e6b82_5675bb5b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2021-01-29T22:03:05Z",
      "side": 1,
      "message": "Thanks for the detailed response! I hadn\u0027t thought about the inherent risk in storing raw tagged pointers in a temporary struct before passing them to a setter, but it makes a lot of sense now that you point it out.\n\nI agree that your proposal for reference-style access looks a lot cleaner and simpler. I had previously considered reference-style access but thought that it would either be too slow (if the reference contained a Handle and an offset) or too risky (if the reference contained a raw pointer). I hadn\u0027t realized that we might make the raw-pointer option acceptably safe by updating gcmole to treat the references like raw pointers.\n\nAnother option I just thought of: perhaps the Ref object could contain only an offset (no dangerous raw pointers) and require the caller to pass the object again for every access. Example usage:\n\n  TqModuleVariableRef var_ref \u003d module.vars(i); // just a one-word object\n  var_ref.set_name(module, *name);\n  var_ref.set_index(module, 42);\n  var_ref.set_properties(module, props);\n\nThe downsides are obvious: this option is more verbose and opens up an exciting new opportunity for misuse by passing an object that doesn\u0027t match the original. However, I like that this option doesn\u0027t require anybody to learn about a new kind of unsafe object. V8 developers are already used to recognizing Object-derived things as raw tagged pointers and using DisallowGarbageCollection accordingly, but I worry that adding a new category of rarely-used unsafe access would do more harm than good. I think we could somewhat mitigate the risk of passing the wrong object by having Refs in debug builds contain the originally-requested index and check during each access that the offset matches a newly-computed offset.\n\nIn any case, there\u0027s a pretty clear consensus that this CL as it currently stands is harmful, so I\u0027ll undo the struct-related parts and leave just the non-contentious @relaxedRead part. Thanks again for the great feedback!",
      "parentUuid": "57767d8d_6f648db4",
      "revId": "7e51296e6928e1b6faf6708862e47a05a2dc9c26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24f1fe98_72964230",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2021-02-01T10:45:36Z",
      "side": 1,
      "message": "Actually, the compilers might already be smart enough to be able to hoist the i-th struct offset computation if necessary or pack it into complex addressing mode that the CPUs can execute fast. In this case we could just have the code like this:\n  Name name \u003d module.var_name(j);\n  ...\n  module.set_var_name(i, name);\n  module.set_var_index(i, 42);\n  module.set_properties(i, props);\n\nWell, it might seem \"slow\" but \n1) still be fast in practice,\n2) provide all the required flexibility regarding write barriers,\n3) will not add new sources of raw pointers (and surprises) that GC mole has to support,\n4) the C++ code will exactly match the code that is generated via Torque/CSA pipeline for accesses of the i-th struct\u0027s fields.\n\nI think if Torque will provide a bunch of auto- and properly-generated set of accessors like those that you removed from CoverageInfo it would already be very useful.\n\nJakob, Nico, Seth, WDYT?",
      "parentUuid": "9f4e6b82_5675bb5b",
      "revId": "7e51296e6928e1b6faf6708862e47a05a2dc9c26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6b7afaf_e1f1a071",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2021-02-01T10:58:38Z",
      "side": 1,
      "message": "Individual setters sgtm.",
      "parentUuid": "24f1fe98_72964230",
      "revId": "7e51296e6928e1b6faf6708862e47a05a2dc9c26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bfc5f002_752a4a50",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2021-02-01T23:28:52Z",
      "side": 1,
      "message": "I agree, that sounds much nicer. I\u0027ve updated this CL to be just @relaxedRead, but I hope I\u0027ll get time soon to implement struct accessors based on your recommendations. Thanks!",
      "parentUuid": "b6b7afaf_e1f1a071",
      "revId": "7e51296e6928e1b6faf6708862e47a05a2dc9c26",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}