{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a9c022c6_811c8778",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2022-07-27T10:05:05Z",
      "side": 1,
      "message": "Hi,\n\nI renamed the field to clarify this is related to indirect jumps, PTAL!\n\nLooking at the results, they seem worthwhile so I\u0027d like to turn the flag on by default, at least for Arm64. I could try pinpoint with linux-perf to check that not deopting to baseline does not regress on other platforms. Or, if I turn it on by default, we can revert the patch if it\u0027s causing regressions, WDYT?\n\n",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16d7599a_6cfcd84b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-07-27T14:53:07Z",
      "side": 1,
      "message": "Let\u0027s leave it deopting to baseline in this CL, and switch it off in a separate CL, so that performance reverts are a single line CL revert and not reverting this whole patch.",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "797f0519_7bd5b226",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2022-07-27T16:50:23Z",
      "side": 1,
      "message": "Hi Toon, could you take a look at the deoptimizer change?",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3e19a86_46027ea5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2022-07-28T14:20:04Z",
      "side": 1,
      "message": "lgtm with a comment\n\nOne additional comment: don\u0027t we dynamically know whether CFI is available? Even though bti is a nop when it\u0027s not available, it would still make sense to skip all of this stuff in that case (and e.g., deopt to baseline because there\u0027s no cost.)",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a393a653_aca7a87f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2022-07-28T16:26:34Z",
      "side": 1,
      "message": "We haven\u0027t added a way to detect CFI support at runtime at this time, the reasons being to:\n\n  1. Limit the number of configurations we have to test, that way we don\u0027t have to check the detection logic works.\n  2. Reduce the ability for it to be turned off at runtime by a bad actor.\n\nThat being said, the last point is less about jitted code generation and more about making sure we hardcode the PROT_BTI mprotect flag when CFI is enabled at compile-time. This way if sparkplug is corrupted so that it forgets to place BTI instructions, then jumping anywhere in jitted code still doesn\u0027t work. \n\nSo I suppose we could add a runtime check, although we\u0027d want to add a warning so we don\u0027t do the same for the `mprotect()` syscall. \n\nI guess we could take a look at that as a follow-up, would that be OK? I was planning on doing another patch that tries to turn the flag on and see where we get regressions, if any. This way we can decide if this should be the default everywhere, be Arm64 only, Arm64+CFI only, or finally Arm64+CFI-detected-at-runtime only.\n\nI also took a look at annotating all sparkplug bytecodes that may trigger eager and lazy deopts, this is also an option, but it doesn\u0027t reduce the code size nearly as much :-/",
      "parentUuid": "c3e19a86_46027ea5",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "563c9d03_0d301d2e",
        "filename": "src/baseline/baseline-compiler.h",
        "patchSetId": 5
      },
      "lineNbr": 187,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2022-07-28T14:20:04Z",
      "side": 1,
      "message": "I simplified BaselineLabels in https://chromium-review.googlesource.com/c/v8/v8/+/3790975 because it wasn\u0027t necessary to track forward references separately. You can update this CL by changing `Label** labels_` to `base::PointerWithPayload\u003cLabel, bool, 1\u003e* labels_` and storing your bool into that payload.",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88144bf5_a63d863a",
        "filename": "src/baseline/baseline-compiler.h",
        "patchSetId": 5
      },
      "lineNbr": 187,
      "author": {
        "id": 1183769
      },
      "writtenOn": "2022-07-28T16:26:34Z",
      "side": 1,
      "message": "Oh that\u0027s great, I did find the \"EnsureLabels()\" a little confusing given it was more about a single label than multiple :-). I was going to ask if it\u0027d be better to use a bitvector that\u0027s stored separately, but actually, `PointerWithPayload` looks ideal space-wise.",
      "parentUuid": "563c9d03_0d301d2e",
      "revId": "523985603b68f18ed5a738b950901407bbc566ab",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}