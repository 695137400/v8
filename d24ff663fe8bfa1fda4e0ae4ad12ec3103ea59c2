{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a2f9c94f_536a71d9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-07-18T15:14:37Z",
      "side": 1,
      "message": "what happens if this is actually a long running loop, and OSR would have been good?",
      "range": {
        "startLine": 16,
        "startChar": 3,
        "endLine": 16,
        "endChar": 11
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b3638d94_94c786ce",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1180419
      },
      "writtenOn": "2022-07-18T15:28:19Z",
      "side": 1,
      "message": "I think that we should compile concurrent OSR code objects in a way that they have multiple entries for the different nested loops. This would be better than to re-try optimization with different entries. And normally, it shouldn\u0027t increase code-size much, multiple loops in sequence as in the example are almost for free. In some cases, we might have to peel a bit more to make things reducible, but compared to re-triggering optimization, it should still be better and more reliable.",
      "parentUuid": "a2f9c94f_536a71d9",
      "range": {
        "startLine": 16,
        "startChar": 3,
        "endLine": 16,
        "endChar": 11
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "09416bb3_6d2eba6a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-07-19T08:36:15Z",
      "side": 1,
      "message": "Thanks for your comments and discussion!\nHi Tobias, I don\u0027t understand your opinion, could you please describe it more detail or give an example.\nHi Leszek, OSR will have been bad if there is an actually long running loop in the same nested loop with OSR\u0027d loop.\nWhat do you think of adding a threshold before re-triggering OSR? Like\n  int ticks_for_reosr \u003d function\u0027s bytecode length dependent experimental value, e.g. a JS function osr state machine, trigger OSR after m ticks, concurrent OSR finish at m + n ticks, ticks_for_reosr \u003d m + n + o; \n  if (SmallEnoughForOSR() \u0026\u0026 (!function.feedback_vector().maybe_has_optimized_osr_code() || !IsInOsrLoop() || ticks \u003e\u003d ticks_for_reosr) {\n   TryIncrementOsrUrgency();\n  }",
      "parentUuid": "b3638d94_94c786ce",
      "range": {
        "startLine": 16,
        "startChar": 3,
        "endLine": 16,
        "endChar": 11
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78697752_b8449929",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-07-19T09:46:23Z",
      "side": 1,
      "message": "I\u0027m at best medium happy about adding yet another OSR thersholding heuristic, the fixes we have are already getting very ad-hoc...",
      "parentUuid": "09416bb3_6d2eba6a",
      "range": {
        "startLine": 16,
        "startChar": 3,
        "endLine": 16,
        "endChar": 11
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d759308_592af9b4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1167225
      },
      "writtenOn": "2022-07-19T10:13:42Z",
      "side": 1,
      "message": "The problem we are trying to solve here is that with concurrent OSR, we don\u0027t know in which part of the code we will be when the OSR compilation is finished. At the moment, we try to solve this by triggering multiple OSR compilations from different start points, which takes a long time and causes multiple compilations. Your CL reduces the number of triggered compilations, but doesn\u0027t solve the issue that the loop for which we compiled OSR might take very long to be reached. I\u0027m suggesting to solve the problem by changing the way we produce OSR code: produce a single code object that is valid for multiple bytecode positions / loop backedges. The code object starts with a switch on the bytecode position and based on this starting execution from different positions in the nested loops. \nThis would have better latency than the current approach, since the first OSR result has more opportunities to be switched to. And it reduces the total number of OSR compilations, as a single compilation is enough.",
      "parentUuid": "78697752_b8449929",
      "range": {
        "startLine": 16,
        "startChar": 3,
        "endLine": 16,
        "endChar": 11
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc1502dd_a459ff30",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 16,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-07-20T08:11:16Z",
      "side": 1,
      "message": "Hi Leszek, thanks! I gave up another OSR thresholding heuristic solution, I\u0027ll consider more reasonable solution.\nHi Tobias, thanks for your repeated detail description! I got your idea. It\u0027s an ideal solution, but it may take a long time. Is there on-going work or plan related to this solution? We will be very happy if we can make some contribution to this solution.",
      "parentUuid": "0d759308_592af9b4",
      "range": {
        "startLine": 16,
        "startChar": 3,
        "endLine": 16,
        "endChar": 11
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "624155bb_fb9a2a5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2022-07-06T13:29:34Z",
      "side": 1,
      "message": "Can you have a look, Tobias?",
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a1ee7df_ffbd5a05",
        "filename": "src/execution/tiering-manager.cc",
        "patchSetId": 5
      },
      "lineNbr": 324,
      "author": {
        "id": 1180419
      },
      "writtenOn": "2022-07-18T15:28:19Z",
      "side": 1,
      "message": "This is an expensive check, therefore I think we should flip the two sides of the `\u0026\u0026` operator.",
      "range": {
        "startLine": 324,
        "startChar": 10,
        "endLine": 324,
        "endChar": 21
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7d2e86bc_a735a543",
        "filename": "src/execution/tiering-manager.cc",
        "patchSetId": 5
      },
      "lineNbr": 324,
      "author": {
        "id": 1313365
      },
      "writtenOn": "2022-07-19T08:36:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7a1ee7df_ffbd5a05",
      "range": {
        "startLine": 324,
        "startChar": 10,
        "endLine": 324,
        "endChar": 21
      },
      "revId": "d24ff663fe8bfa1fda4e0ae4ad12ec3103ea59c2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}