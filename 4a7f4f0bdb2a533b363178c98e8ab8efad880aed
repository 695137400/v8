{
  "comments": [
    {
      "key": {
        "uuid": "975def15_dad9c4e4",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-06-25T09:43:40Z",
      "side": 1,
      "message": "Is the issue that IsJSObject will load a map? i.e it would be equivalent to\n  if (!map-\u003eprototype().synchronized_map().IsJSObjectMap()) {\nor similar?",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "636a2eb5_c2b16fed",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-06-25T09:45:55Z",
      "side": 1,
      "message": "Yes, the issue is that each time we do an IsFoo check, we load potentially a different map.",
      "parentUuid": "975def15_dad9c4e4",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0d64a791_5c522fc3",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-06-25T09:51:10Z",
      "side": 1,
      "message": "Pasting this from the other CL\n\nIf\n\n  map-\u003eprototype().IsJSObject();\nhas a problem then\n  prototype_map \u003d map-\u003eprototype()-\u003esynchronized_map()-\u003eIsJSObjectMap();\nhas the same issue.\nIt could happen that BG thread does map-\u003eprototype(), goes to sleep due to scheduling, main thread changes the prototype, and then BG thread does -\u003esynchronized_map() and sees \"the wrong\" map.\n\n\nI think we might need a lock.",
      "parentUuid": "636a2eb5_c2b16fed",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8818c95_087b2adc",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-06-25T09:56:31Z",
      "side": 1,
      "message": "I don\u0027t understand the example, it doesn\u0027t type-check. We should read the prototype only once, and from that we should read the map only once.\n\n\u003e It could happen that BG thread does map-\u003eprototype(), goes to sleep due to scheduling, main thread changes the prototype,\n\nWe concluded earlier that the prototype is immutable, right? It can only change by replacing the entire map. In that case we continue working with the old map and probably abort optimization at the end when we notice the inconsistency.",
      "parentUuid": "0d64a791_5c522fc3",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0355ae4_ec6edd09",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1002405
      },
      "writtenOn": "2020-06-25T10:02:52Z",
      "side": 1,
      "message": "\"map_prototype-\u003esynchronized_map().IsJSObjectMap()\" would be sufficient to resolve the data race I mentioned in the other CL.\n\nI think Georg wants additionally to ensure that map_prototype-\u003esynchronized_map() stays the same throughout the whole code. For that we would need to save the map:\n\"Handle\u003cMap\u003e map_of_map_prototype \u003d handle(map_prototype-\u003esynchronized_map(), isolate())\" and then work with the map_of_map_prototype. \n\nThat would be also good for performance as it would avoid fences.",
      "parentUuid": "f8818c95_087b2adc",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40168fa9_46529566",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-06-25T10:07:24Z",
      "side": 1,
      "message": "Right, thanks for pointing out that this second property is not about a data race.",
      "parentUuid": "b0355ae4_ec6edd09",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "926829be_ce6b9afc",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-06-25T10:07:46Z",
      "side": 1,
      "message": "\u003e We should read the prototype only once, and from that we should read the map only once\n\nThat was what the previous CL was doing (https://chromium-review.googlesource.com/c/v8/v8/+/2210233) and we said it was unsafe because the prototype might transition.\n\n\u003e I don\u0027t understand the example\n\nMy point is that this chain \"map-\u003eprototype().synchronized_map().IsJSObjectMap()\" is not atomic. It could happen that \"map-\u003eprototype()\" happens, then the prototype transitions, and then we do \".synchronized_map().IsJSObjectMap()\". We are still in the same place as before.",
      "parentUuid": "f8818c95_087b2adc",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86c07830_11a11481",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1002405
      },
      "writtenOn": "2020-06-25T10:12:58Z",
      "side": 1,
      "message": "Wait, does prototype.IsJSObject() load the map using synchronized_map()? I thought it was a relaxed load.",
      "parentUuid": "926829be_ce6b9afc",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9264833_795cd3bb",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1002405
      },
      "writtenOn": "2020-06-25T10:14:55Z",
      "side": 1,
      "message": "It is a relaxed load: https://cs.chromium.org/chromium/src/v8/src/objects/object-macros.h?rcl\u003dca2f986fb2d16524b6067686dcc765f9836a02db\u0026l\u003d256",
      "parentUuid": "86c07830_11a11481",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24972ecc_8707ed7c",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2020-06-25T10:21:51Z",
      "side": 1,
      "message": "Santiago: In the previous CL, we read the map multiple times, namely because each map_prototype.IsFoo() read it.",
      "parentUuid": "d9264833_795cd3bb",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75a442dd_bf9ad64c",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1002405
      },
      "writtenOn": "2020-06-25T10:28:18Z",
      "side": 1,
      "message": "To clarify the data race I had in mind.\n\nMain thread does: 1) allocate a new map 2) write instance type to the new map 3) transition the prototype to the new map\n\nBackground thread does: A) Load the map from the prototype B) load the instance type from the map.\n\n(A) and (3) should form an acquire-release (or consume-release) pair to ensure that (B) loads (2).\nOtherwise, (B) could in theory load an \"undefined\" value and TSAN should warn about it, but I guess it doesn\u0027t currently because instance_type is an atomic, so TSAN just ignores it.",
      "parentUuid": "24972ecc_8707ed7c",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6601b28_870389d6",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-06-25T10:53:12Z",
      "side": 1,
      "message": "Ok, so we have two things:\n1) we would like that every time we read map\u0027s prototype\u0027s map to read the same one. I agree.\n2) we have a data race (Ulan\u0027s example) unless we add some more synchronization\n\nRegarding the example:\n\u003e Main thread does: 1) allocate a new map 2) write instance type to the new map 3) transition the prototype to the new map\n\u003e \n\u003e Background thread does: A) Load the map from the prototype B) load the instance type from the map.\n\nIs the point that we are okay with these two orders:\n * 1, 2, 3, A, B\n * A, B, 1, 2, 3\nbut we are not okay with\n * 1, 3, A, B, 2\n? Is this what we want to safeguard against?",
      "parentUuid": "75a442dd_bf9ad64c",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28b27aec_7e379b51",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1002405
      },
      "writtenOn": "2020-06-25T11:29:29Z",
      "side": 1,
      "message": "That\u0027s one of the possible orders that we need to guard against. Without acquire/consume load of A, the compiler is also allowed to reorder A and B even though there is data dependency. For example, the compiler could speculate the address of B and the confirm that after loading A.\n\nConsume load was intended to solve that, but today all compilers emit the same sequence for consume and acquire, so acquire is generally preferred.\n\n(I personally find it easier to reason about acquire/release pairs that justify other loads and stores, rather than preventing reordering.)",
      "parentUuid": "c6601b28_870389d6",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "631fc43b_60667fa0",
        "filename": "src/compiler/access-info.cc",
        "patchSetId": 1
      },
      "lineNbr": 567,
      "author": {
        "id": 1327869
      },
      "writtenOn": "2020-06-25T13:13:12Z",
      "side": 1,
      "message": "Ack, submitting a new patchset with this in mind.",
      "parentUuid": "28b27aec_7e379b51",
      "range": {
        "startLine": 567,
        "startChar": 26,
        "endLine": 567,
        "endChar": 36
      },
      "revId": "4a7f4f0bdb2a533b363178c98e8ab8efad880aed",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}