{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5fe46850_8dedb79a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2022-05-26T13:14:02Z",
      "side": 1,
      "message": "builtin calls",
      "range": {
        "startLine": 7,
        "startChar": 33,
        "endLine": 7,
        "endChar": 41
      },
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b835ceb_e12b2c7e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1221720
      },
      "writtenOn": "2022-06-01T09:26:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5fe46850_8dedb79a",
      "range": {
        "startLine": 7,
        "startChar": 33,
        "endLine": 7,
        "endChar": 41
      },
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "641b52ca_8db6e835",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1221720
      },
      "writtenOn": "2022-05-25T15:10:01Z",
      "side": 1,
      "message": "PTAL!",
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9a58150_ec165f39",
        "filename": "src/deoptimizer/deoptimizer-cfi-builtins.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2022-05-25T16:13:11Z",
      "side": 1,
      "message": "I\u0027m afraid that the offset comparing approach might not always work because of this feature:\nhttps://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/code.cc;l\u003d53?q\u003dfile:code.cc\u0026ss\u003dchromium\n\nIsolate might suddenly start using remapped builtins while the Isolate::embedded_blob_code() still points to the embedded builtins blob in the binary.\n\nSee OffHeapInstructionStream::TryLookupCode() which has to deal with the same issue.\n\nMoreover, in order to support bigger code ranges on arm64 while still allowing short builtin calls we are considering as one of the options remapping the builtins blob into code range multiple times (once per 256Mb).\n\nI think you might handle this issue by passing here both Isolate* and pc, using EmbeddedData::GetEmbeddedDataForPC() and then comparing pc against EmbeddedData::InstructionStartOfBuiltin(Builtin::kXXX).",
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5cbfaffa_5d692cd1",
        "filename": "src/deoptimizer/deoptimizer-cfi-builtins.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1221720
      },
      "writtenOn": "2022-05-26T08:30:20Z",
      "side": 1,
      "message": "I\u0027m trying to understand how I can test this issue, because testing with `v8_enable_pointer_compression_shared_cage \u003d true` in addition to CFI and short builtins doesn\u0027t show any problems.\n\nThe addresses we pass to `IsValidReturnAddress` in this case are all builtin addresses chosen by the deoptimizer, which calls `Code::InstructionStart` to get their address and therefore ultimately gets to the function you linked to. I don\u0027t understand how the isolate wouldn\u0027t know about the per-process code range, though, since the heap is initialised before we get to remapping the builtins and setting `embedded_blob_code_`, and it should take care of the shared code space initialisation (https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/heap.cc;l\u003d5717) (unless we\u0027re running jitless, but that seems a simpler configuration to think about). What am I missing?",
      "parentUuid": "f9a58150_ec165f39",
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd67f1c7_58d079b4",
        "filename": "src/deoptimizer/deoptimizer-cfi-builtins.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2022-05-26T13:14:02Z",
      "side": 1,
      "message": "It\u0027s a bit of a mess what\u0027s going on there, but it can happen when:\n1) the first Isolate is created under memory pressure and thus it decides to not enable short builtin calls: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/execution/isolate.cc;l\u003d4016?q\u003dfile:isolate.cc\u0026ss\u003dchromium \n2) then memory pressure goes away and another Isolate (worker) is created which in turn decides to enable short builtin calls and thus remap the embedded builtins,\n3) from now on Code::InstructionStart() will always return pointers to remapped embedded builtins for all the Isolates (even though the first one doesn\u0027t known about the remapped builtins copy).\n\nSo, if you reuse the existing machinery then it would be easier to clean this up or extend it without unexpected breakages.",
      "parentUuid": "5cbfaffa_5d692cd1",
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0da43454_908f944d",
        "filename": "src/deoptimizer/deoptimizer-cfi-builtins.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1221720
      },
      "writtenOn": "2022-06-01T09:26:17Z",
      "side": 1,
      "message": "Thanks for the explanation! I\u0027m now passing the Isolate pointer to `IsValidReturnAddress` and using `EmbeddedData::GetEmbeddedDataForPC` as you suggested. I can\u0027t use `EmbeddedData::InstructionStartOfBuiltin` because some of the labels we compare against are not at the start of builtins, but I\u0027d also like to keep the read-only allowlist. We should be able to sign the few pointers to the embedded data blob that `EmbeddedData::GetEmbeddedDataForPC` uses in a follow-up, to provide additional protection.",
      "parentUuid": "dd67f1c7_58d079b4",
      "revId": "b7ade70e77ed1f2911eb99254dd402c4a02ff327",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}