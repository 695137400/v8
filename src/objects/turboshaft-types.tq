// Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/objects/turboshaft-types.h"

bitfield struct TurboshaftTypeKind extends uint16 {
  range: bool: 1 bit;
  minus_zero: bool: 1 bit;
  nan: bool: 1 bit;
}

@abstract
extern class TurboshaftType extends HeapObject {
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftWord32Type extends TurboshaftType {
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftWord32RangeType extends TurboshaftWord32Type {
  from: uint32;
  to: uint32;
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftWord32SetType extends TurboshaftWord32Type {
  const set_size: uint32;
  elements[set_size]: uint32;
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftWord64Type extends TurboshaftType {
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftWord64RangeType extends TurboshaftWord64Type {
  from_high: uint32;
  from_low: uint32;
  to_high: uint32;
  to_low: uint32;
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftWord64SetType extends TurboshaftWord64Type {
  const set_size: uint32;
  elements_high[set_size]: uint32;
  elements_low[set_size]: uint32;
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftFloat32Type extends TurboshaftType {
  kind: TurboshaftTypeKind;
  _padding: uint16;
  // TODO(nicohartmann@): Use float32 types here once Torque supports it.
  min: float64;
  max: float64;
}

@generateBodyDescriptor
@generateUniqueMap
@generateFactoryFunction
extern class TurboshaftFloat64Type extends TurboshaftType {
  kind: TurboshaftTypeKind;
  _padding: uint16;
  min: float64;
  max: float64;
}

macro TestTurboshaftWord32Type(
    value: uint32, expected: TurboshaftWord32Type): bool {
  typeswitch (expected) {
    case (range: TurboshaftWord32RangeType): {
      if (range.from > range.to) {
        return value <= range.to || range.from <= value;
      }
      return range.from <= value && value <= range.to;
    }
    case (set: TurboshaftWord32SetType): {
      for (let i: uint32 = 0; i < set.set_size; ++i) {
        if (set.elements[i] == value) return true;
      }
      return false;
    }
    case (TurboshaftWord32Type): {
      unreachable;
    }
  }
}

builtin CheckTurboshaftWord32Type(implicit context: Context)(
    value: uint32, expectedType: TurboshaftWord32Type, nodeId: Smi): Undefined {
  if (TestTurboshaftWord32Type(value, expectedType)) {
    return Undefined;
  }

  Print('Type assertion failed!');
  Print('Node id', nodeId);
  Print('Actual value', Convert<Number>(value));
  Print('Expected type', expectedType);
  unreachable;
}

macro CompareUint64HighLow(
    lhsHigh: uint32, lhsLow: uint32, rhsHigh: uint32, rhsLow: uint32): int32 {
  if (lhsHigh == rhsHigh) {
    if (lhsLow == rhsLow) return 0;
    return lhsLow < rhsLow ? Convert<int32>(-1) : 1;
  } else {
    return lhsHigh < rhsHigh ? Convert<int32>(-1) : 1;
  }
}

macro TestTurboshaftWord64Type(
    valueHigh: uint32, valueLow: uint32, expected: TurboshaftWord64Type): bool {
  typeswitch (expected) {
    case (range: TurboshaftWord64RangeType): {
      const greaterThanOrEqualFrom =
          CompareUint64HighLow(
              valueHigh, valueLow, range.from_high, range.from_low) >= 0;
      const lessThanOrEqualTo =
          CompareUint64HighLow(
              valueHigh, valueLow, range.to_high, range.to_low) <= 0;
      const isWrapping =
          CompareUint64HighLow(
              range.from_high, range.from_low, range.to_high, range.to_low) < 0;

      return (isWrapping && (greaterThanOrEqualFrom || lessThanOrEqualTo)) ||
          (greaterThanOrEqualFrom && lessThanOrEqualTo);
    }
    case (set: TurboshaftWord64SetType): {
      for (let i: uint32 = 0; i < set.set_size; ++i) {
        if (CompareUint64HighLow(
                set.elements_high[i], set.elements_low[i], valueHigh,
                valueLow) == 0) {
          return true;
        }
      }
      return false;
    }
    case (TurboshaftWord64Type): {
      unreachable;
    }
  }
}

builtin CheckTurboshaftWord64Type(implicit context: Context)(
    valueHigh: uint32, valueLow: uint32, expectedType: TurboshaftWord64Type,
    nodeId: Smi): Undefined {
  if (TestTurboshaftWord64Type(valueHigh, valueLow, expectedType)) {
    return Undefined;
  }

  Print('Type assertion failed!');
  Print('Node id', nodeId);
  Print('Actual value (high)', Convert<Number>(valueHigh));
  Print('Actual vlaue (low)', Convert<Number>(valueLow));
  Print('Expected type', expectedType);
  unreachable;
}

builtin CheckTurboshaftFloat32Type(implicit context: Context)(
    value: float32, expectedType: TurboshaftFloat32Type,
    nodeId: Smi): Undefined {
  const value = Convert<float64>(value);
  if (Float64IsNaN(value) && expectedType.kind.nan) return Undefined;
  if (IsMinusZero(value) && expectedType.kind.minus_zero) return Undefined;
  if (expectedType.kind.range) {
    if (value >= expectedType.min && value <= expectedType.max) {
      return Undefined;
    }
  }

  Print('Type assertion failed!');
  Print('Node id', nodeId);
  Print('Actual value', Convert<Number>(value));
  Print('Expected type', expectedType);
  unreachable;
}

builtin CheckTurboshaftFloat64Type(implicit context: Context)(
    value: float64, expectedType: TurboshaftFloat64Type,
    nodeId: Smi): Undefined {
  if (Float64IsNaN(value) && expectedType.kind.nan) return Undefined;
  if (IsMinusZero(value) && expectedType.kind.minus_zero) return Undefined;
  if (expectedType.kind.range) {
    if (value >= expectedType.min && value <= expectedType.max) {
      return Undefined;
    }
  }

  Print('Type assertion failed!');
  Print('Node id', nodeId);
  Print('Actual value', Convert<Number>(value));
  Print('Expected type', expectedType);
  unreachable;
}
