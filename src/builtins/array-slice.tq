// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module array {
  macro HandleSimpleArgumentsSlice(
      context: Context, args: JSArgumentsObjectWithLength, start: Smi,
      count: Smi): JSArray
      labels Bailout {
    const end: Smi = start + count;
    const sourceElements: FixedArray =
        Cast<FixedArray>(args.elements) otherwise Bailout;
    if (SmiAbove(end, sourceElements.length)) goto Bailout;

    const arrayMap: Map = LoadJSArrayElementsMap(HOLEY_ELEMENTS, context);
    const result: JSArray =
        AllocateJSArray(HOLEY_ELEMENTS, arrayMap, count, count);
    const newElements: FixedArray =
        Cast<FixedArray>(result.elements) otherwise Bailout;
    let dest: Smi = 0;
    let current: Smi = start;
    while (current < end) {
      StoreFixedArrayElementSmi(
          newElements, dest++, sourceElements[current++], SKIP_WRITE_BARRIER);
    }
    return result;
  }

  macro HandleFastAliasedSloppyArgumentsSlice(
      context: Context, args: JSArgumentsObjectWithLength, start: Smi,
      count: Smi): JSArray
      labels Bailout {
    const sloppyElements: SloppyArgumentsElements =
        Cast<SloppyArgumentsElements>(args.elements) otherwise Bailout;
    const sloppyElementsLength: Smi = sloppyElements.length;
    const parameterMapLength: Smi =
        sloppyElementsLength - kSloppyArgumentsParameterMapStart;

    // Check to make sure that the extraction will not access outside the
    // defined arguments
    const end: Smi = start + count;
    const unmappedElements: FixedArray =
        Cast<FixedArray>(sloppyElements[kSloppyArgumentsArgumentsIndex])
        otherwise Bailout;
    const unmappedElementsLength: Smi = unmappedElements.length;
    if (SmiAbove(end, unmappedElementsLength)) goto Bailout;

    const argumentsContext: Context =
        UnsafeCast<Context>(sloppyElements[kSloppyArgumentsContextIndex]);

    const arrayMap: Map = LoadJSArrayElementsMap(HOLEY_ELEMENTS, context);
    const result: JSArray =
        AllocateJSArray(HOLEY_ELEMENTS, arrayMap, count, count);

    let indexOut: Smi = 0;
    const resultElements: FixedArray = UnsafeCast<FixedArray>(result.elements);
    const to: Smi = SmiMin(parameterMapLength, end);

    // Fill in the part of the result that map to context-mapped parameters.
    for (let current: Smi = start; current < to; ++current) {
      const e: Object =
          sloppyElements[current + kSloppyArgumentsParameterMapStart];
      const newElement: Object = e != Hole ?
          argumentsContext[UnsafeCast<Smi>(e)] :
          unmappedElements[current];
      StoreFixedArrayElementSmi(
          resultElements, indexOut++, newElement, SKIP_WRITE_BARRIER);
    }

    // Fill in the rest of the result that contains the unmapped parameters
    // above the format parameters.
    const unmappedFrom: Smi = SmiMax(parameterMapLength, start);
    for (let current: Smi = unmappedFrom; current < end; ++current) {
      StoreFixedArrayElementSmi(
          resultElements, indexOut++, unmappedElements[current],
          SKIP_WRITE_BARRIER);
    }

    return result;
  }

  macro HandleFastSlice(
      context: Context, o: Object, startNumber: Number, countNumber: Number):
      JSArray
      labels Bailout {
    const start: Smi = Cast<Smi>(startNumber) otherwise Bailout;
    const count: Smi = Cast<Smi>(countNumber) otherwise Bailout;

    // If the resulting array doesn't fit in new space, use the slow path.
    if (count >= kMaxNewSpaceFixedArrayElements) goto Bailout;

    // Start can be zero if the argument's object's length is set to a
    // negative value. See regress-778668.js
    if (start < 0) goto Bailout;

    // It's possible to modify the array length from a valueOf
    // callback between the original array length read and this
    // point. Therefore, re-check the length before calling the
    // appropriate fast path. See regress-785804.js
    typeswitch (o) {
      case (a: FastJSArrayForCopy): {
        if (SmiAbove(start + count, a.length)) goto Bailout;
        return ExtractFastJSArray(context, a, start, count);
      }
      case (a: JSArgumentsObjectWithLength): {
        const arrayLength: Smi = Cast<Smi>(a.length) otherwise Bailout;
        if (SmiAbove(start + count, arrayLength)) goto Bailout;
        const nativeContext: NativeContext = LoadNativeContext(context);
        const map: Map = a.map;
        if (map == nativeContext[FAST_ALIASED_ARGUMENTS_MAP_INDEX]) {
          return HandleFastAliasedSloppyArgumentsSlice(context, a, start, count)
              otherwise Bailout;
        } else if (
            map == nativeContext[SLOPPY_ARGUMENTS_MAP_INDEX] ||
            map == nativeContext[STRICT_ARGUMENTS_MAP_INDEX]) {
          return HandleSimpleArgumentsSlice(context, a, start, count)
              otherwise Bailout;
        }
      }
      case (Object): {
      }
    }
    goto Bailout;
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.slice
  javascript builtin ArraySlice(
      context: Context, receiver: Object, ...arguments): Object {
    // Fast-case array cloning case if the receiver is a fast array.
    if (arguments.length == 0) {
      if (BranchIfFastJSArrayForCopy(receiver, context)) {
        return CloneFastJSArray(context, receiver);
      }
    }

    // 1. Let O be ? ToObject(this value).
    const o: JSReceiver = ToObject_Inline(context, receiver);

    // 2. Let len be ? ToLength(? Get(O, "length")).
    const len: Number = GetLengthProperty(o);

    // 3. Let relativeStart be ? ToInteger(start).
    const start: Object = arguments[0];
    const relativeStart: Number = ToInteger_Inline(context, start);

    // 4. If relativeStart < 0, let k be max((len + relativeStart), 0);
    //    else let k be min(relativeStart, len).
    let k: Number = relativeStart < 0 ? Max((len + relativeStart), 0) :
                                        Min(relativeStart, len);

    // 5. If end is undefined, let relativeEnd be len;
    //    else let relativeEnd be ? ToInteger(end).
    const end: Object = arguments[1];
    const relativeEnd: Number =
        end == Undefined ? len : ToInteger_Inline(context, end);

    // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0);
    //    else let final be min(relativeEnd, len).
    const final: Number =
        relativeEnd < 0 ? Max((len + relativeEnd), 0) : Min(relativeEnd, len);

    // 7. Let count be max(final - k, 0).
    const count: Number = Max(final - k, 0);

    try {
      return HandleFastSlice(context, o, k, count) otherwise Slow;
    }
    label Slow {}

    // 8. Let A be ? ArraySpeciesCreate(O, count).
    const a: JSReceiver = ArraySpeciesCreate(context, o, count);

    // 9. Let n be 0.
    let n: Number = 0;

    // 10. Repeat, while k < final
    while (k < final) {
      // a. Let Pk be ! ToString(k).
      let pK: Number = k;

      // b. Let kPresent be ? HasProperty(O, Pk).
      const fromPresent: Boolean = HasProperty(o, pK);

      // c. If kPresent is true, then
      if (fromPresent == True) {
        // i. Let kValue be ? Get(O, Pk).
        const kValue: Object = GetProperty(o, pK);

        // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue).
        CreateDataProperty(a, n, kValue);
      }

      // d. Increase k by 1.
      k++;

      // e. Increase n by 1.
      n++;
    }

    // 11. Perform ? Set(A, "length", n, true).
    SetProperty(a, kLengthString, n);

    // 12. Return A.
    return a;
  }
}
