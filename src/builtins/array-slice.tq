// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module array {
  macro HandleSimpleArgumentsSlice(
      context: Context, args: JSArgumentsObjectWithLength, start: Smi,
      count: Smi): JSArray
      labels Bailout {
    const end: Smi = start + count;
    const sourceElements: FixedArray =
        Cast<FixedArray>(args.elements) otherwise Bailout;
    if (SmiAbove(end, sourceElements.length)) goto Bailout;

    const arrayMap: Map = LoadJSArrayElementsMap(HOLEY_ELEMENTS, context);
    const result: JSArray =
        AllocateJSArray(HOLEY_ELEMENTS, arrayMap, count, count);
    const newElements: FixedArray =
        Cast<FixedArray>(result.elements) otherwise Bailout;
    let dest: Smi = 0;
    let current: Smi = start;
    while (current < end) {
      StoreFixedArrayElementSmi(
          newElements, dest++, sourceElements[current++], SKIP_WRITE_BARRIER);
    }
    return result;
  }

  macro HandleFastAliasedSloppyArgumentsSlice(
      context: Context, args: JSArgumentsObjectWithLength, start: Smi,
      count: Smi): JSArray
      labels Bailout {
    const sloppyElements: SloppyArgumentsElements =
        Cast<SloppyArgumentsElements>(args.elements) otherwise Bailout;
    const sloppyElementsLength: Smi = sloppyElements.length;
    const parameterMapLength: Smi =
        sloppyElementsLength - kSloppyArgumentsParameterMapStart;

    // Check to make sure that the extraction will not access outside the
    // defined arguments
    const end: Smi = start + count;
    const unmappedElements: FixedArray =
        Cast<FixedArray>(sloppyElements[kSloppyArgumentsArgumentsIndex])
        otherwise Bailout;
    const unmappedElementsLength: Smi = unmappedElements.length;
    if (SmiAbove(end, unmappedElementsLength)) goto Bailout;

    const argumentsContext: Context =
        UnsafeCast<Context>(sloppyElements[kSloppyArgumentsContextIndex]);

    const arrayMap: Map = LoadJSArrayElementsMap(HOLEY_ELEMENTS, context);
    const result: JSArray =
        AllocateJSArray(HOLEY_ELEMENTS, arrayMap, count, count);

    let indexOut: Smi = 0;
    const resultElements: FixedArray = UnsafeCast<FixedArray>(result.elements);
    const startMapped: Smi = SmiMin(parameterMapLength, start);
    const to: Smi = SmiMin(parameterMapLength, end);

    // Fill in the part of the result that map to context-mapped parameters.
    for (let current: Smi = startMapped; current < to; ++current) {
      const e: Object =
          sloppyElements[current + kSloppyArgumentsParameterMapStart];
      const newElement: Object = e != Hole ?
          argumentsContext[UnsafeCast<Smi>(e)] :
          unmappedElements[current];
      StoreFixedArrayElementSmi(
          resultElements, indexOut++, newElement, SKIP_WRITE_BARRIER);
    }

    // Fill in the rest of the result that contains the unmapped parameters
    // above the format parameters.
    const unmappedFrom: Smi = SmiMin(SmiMax(parameterMapLength, start), end);
    for (let current: Smi = unmappedFrom; current < end; ++current) {
      StoreFixedArrayElementSmi(
          resultElements, indexOut++, unmappedElements[current],
          SKIP_WRITE_BARRIER);
    }

    return result;
  }

  macro HandleSloppyArgumentsSlice(
      context: Context, o: Object, start: Smi, count: Smi): JSArray
      labels Bailout {
    // If the resulting array doesn't fit in new space, use the slow path.
    if (count >= kMaxNewSpaceFixedArrayElements) goto Bailout;

    // Start can be zero if the argument's object's length is set to a
    // negative value. See regress-778668.js
    if (start < 0) goto Bailout;

    // Test the receiver to see if it's a a fast sloppy arguments object.
    const heapObject: HeapObject = Cast<HeapObject>(o) otherwise Bailout;
    const map: Map = heapObject.map;
    const nativeContext: NativeContext = LoadNativeContext(context);
    const args: JSArgumentsObjectWithLength =
        Cast<JSArgumentsObjectWithLength>(o) otherwise Bailout;

    // It's possible to modify the array length from a valueOf
    // callback between the original array length read and this
    // point. Therefore, re-check the length. See regress-785804.js
    const arrayLengthNumber: Object = args.length;
    const arrayLength: Smi = Cast<Smi>(arrayLengthNumber) otherwise Bailout;
    if (SmiAbove(start + count, arrayLength)) goto Bailout;

    if (map == nativeContext[SLOPPY_ARGUMENTS_MAP_INDEX]) {
      return HandleSimpleArgumentsSlice(context, args, start, count)
          otherwise Bailout;
    }
    if (map == nativeContext[STRICT_ARGUMENTS_MAP_INDEX]) {
      return HandleSimpleArgumentsSlice(context, args, start, count)
          otherwise Bailout;
    }
    if (map != nativeContext[FAST_ALIASED_ARGUMENTS_MAP_INDEX]) {
      goto Bailout;
    }
    return HandleFastAliasedSloppyArgumentsSlice(context, args, start, count)
        otherwise Bailout;
  }

  macro HandleFastSlice(
      context: Context, o: Object, startNumber: Number, countNumber: Number):
      JSArray
      labels Bailout {
    const start: Smi = Cast<Smi>(startNumber) otherwise Bailout;
    const count: Smi = Cast<Smi>(countNumber) otherwise Bailout;
    try {
      if (BranchIfNotFastJSArrayForCopy(o)) {
        goto TryFastAliasedArguments;
      }
      const a: JSArray = Cast<JSArray>(o) otherwise unreachable;

      // It's possible to modify the array length from a valueOf
      // callback between the original array length read and this
      // point. Therefore, re-check the length. See regress-785804.js
      const arrayLengthNumber: Number = a.length;
      const arrayLength: Smi = Cast<Smi>(arrayLengthNumber) otherwise Bailout;
      if (SmiAbove(start + count, arrayLength)) goto Bailout;

      assert(SmiGreaterThanOrEqual(start, SmiConstant(0)));
      return ExtractFastJSArray(context, a, start, count);
    }
    label TryFastAliasedArguments {
      return HandleSloppyArgumentsSlice(context, o, start, count)
          otherwise Bailout;
    }
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.slice
  javascript builtin ArraySlice(
      context: Context, receiver: Object, ...arguments): Object {
    // Fast-case array cloning case if the receiver is a fast array.
    if (arguments.length == 0) {
      if (BranchIfFastJSArrayForCopy(receiver, context)) {
        return CloneFastJSArray(context, receiver);
      }
    }

    // 1. Let O be ? ToObject(this value).
    const o: JSReceiver = ToObject_Inline(context, receiver);

    // 2. Let len be ? ToLength(? Get(O, "length")).
    const len: Number = GetLengthProperty(o);

    // 3. Let relativeStart be ? ToInteger(start).
    const start: Object = arguments[0];
    const relativeStart: Number = ToInteger_Inline(context, start);

    // 4. If relativeStart < 0, let k be max((len + relativeStart), 0);
    //    else let k be min(relativeStart, len).
    let k: Number = relativeStart < 0 ? Max((len + relativeStart), 0) :
                                        Min(relativeStart, len);

    // 5. If end is undefined, let relativeEnd be len;
    //    else let relativeEnd be ? ToInteger(end).
    const end: Object = arguments[1];
    const relativeEnd: Number =
        end == Undefined ? len : ToInteger_Inline(context, end);

    // 6. If relativeEnd < 0, let final be max((len + relativeEnd), 0);
    //    else let final be min(relativeEnd, len).
    const final: Number =
        relativeEnd < 0 ? Max((len + relativeEnd), 0) : Min(relativeEnd, len);

    // 7. Let count be max(final - k, 0).
    const count: Number = Max(final - k, 0);

    try {
      return HandleFastSlice(context, o, k, count) otherwise Slow;
    }
    label Slow {}

    // 8. Let A be ? ArraySpeciesCreate(O, count).
    const a: JSReceiver = ArraySpeciesCreate(context, o, count);

    // 9. Let n be 0.
    let n: Number = 0;

    // 10. Repeat, while k < final
    while (k < final) {
      // a. Let Pk be ! ToString(k).
      let pK: Number = k;

      // b. Let kPresent be ? HasProperty(O, Pk).
      const fromPresent: Boolean = HasProperty(o, pK);

      // c. If kPresent is true, then
      if (fromPresent == True) {
        // i. Let kValue be ? Get(O, Pk).
        const kValue: Object = GetProperty(o, pK);

        // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(n), kValue).
        CreateDataProperty(a, n, kValue);
      }

      // d. Increase k by 1.
      k++;

      // e. Increase n by 1.
      n++;
    }

    // 11. Perform ? Set(A, "length", n, true).
    SetProperty(a, kLengthString, n);

    // 12. Return A.
    return a;
  }
}
