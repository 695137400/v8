// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module array {
  // Naming convention from elements.cc. We have a similar intent but implement
  // fastpaths using generics instead of using a class hierarchy for elements
  // kinds specific implementations.
  type GenericElementsAccessor;
  type FastPackedSmiElements;
  type FastSmiOrObjectElements;
  type FastDoubleElements;
  type DictionaryElements;

  // This is a special type, used to access the work array which is always
  // PACKED_ELEMENTS. As a result, we do not need a sanity check for it,
  // otherwise we might wrongly bail to the slow path.
  type WorkArrayElements;

  type LoadFn = builtin(Context, FixedArray, Object, Smi) => Object;
  type StoreFn = builtin(Context, FixedArray, Object, Smi, Object) => Smi;
  type CanUseSameAccessorFn =
      builtin(Context, Object, Object, Object, Number) => Boolean;

  builtin Load<ElementsAccessor : type>(
      context: Context, sortState: FixedArray, elements: Object,
      index: Smi): Object {
    return GetProperty(context, elements, index);
  }

  Load<FastPackedSmiElements>(
      context: Context, sortState: FixedArray, elements: Object,
      index: Smi): Object {
    assert(IsFixedArray(unsafe_cast<HeapObject>(elements)));
    let elems: FixedArray = unsafe_cast<FixedArray>(elements);
    return elems[index];
  }

  Load<FastSmiOrObjectElements>(
      context: Context, sortState: FixedArray, elements: Object,
      index: Smi): Object {
    assert(IsFixedArray(unsafe_cast<HeapObject>(elements)));
    let elems: FixedArray = unsafe_cast<FixedArray>(elements);
    let result: Object = elems[index];
    if (IsTheHole(result)) {
      sortState[kBailoutStatusIdx()] = kFailure();
      return result;
    }
    return result;
  }

  Load<FastDoubleElements>(
      context: Context, sortState: FixedArray, elements: Object,
      index: Smi): Object {
    try {
      let elems: FixedDoubleArray = unsafe_cast<FixedDoubleArray>(elements);
      let value: float64 =
          LoadDoubleWithHoleCheck(elems, index) otherwise Bailout;
      return AllocateHeapNumberWithValue(value);
    }
    label Bailout {
      sortState[kBailoutStatusIdx()] = kFailure();
      return kSuccess();
    }
  }

  Load<DictionaryElements>(
      context: Context, sortState: FixedArray, elements: Object,
      index: Smi): Object {
    try {
      let dictionary: NumberDictionary =
          unsafe_cast<NumberDictionary>(elements);
      let intptr_index: intptr = convert<intptr>(index);
      let value: Object =
          BasicLoadNumberDictionaryElement(dictionary, intptr_index)
      otherwise Bailout, Bailout;
      return value;
    }
    label Bailout {
      sortState[kBailoutStatusIdx()] = kFailure();
      return kSuccess();
    }
  }

  Load<WorkArrayElements>(
      context: Context, sortState: FixedArray, elements: Object,
      index: Smi): Object {
    assert(IsFixedArray(unsafe_cast<HeapObject>(elements)));
    let elems: FixedArray = unsafe_cast<FixedArray>(elements);
    return elems[index];
  }

  builtin Store<ElementsAccessor : type>(
      context: Context, sortState: FixedArray, elements: Object, index: Smi,
      value: Object): Smi {
    SetProperty(context, elements, index, value, kStrict);
    return kSuccess();
  }

  Store<FastPackedSmiElements>(
      context: Context, sortState: FixedArray, elements: Object, index: Smi,
      value: Object): Smi {
    let elems: FixedArray = unsafe_cast<FixedArray>(elements);
    elems[index] = value;
    return kSuccess();
  }

  Store<FastSmiOrObjectElements>(
      context: Context, sortState: FixedArray, elements: Object, index: Smi,
      value: Object): Smi {
    let elems: FixedArray = unsafe_cast<FixedArray>(elements);
    elems[index] = value;
    return kSuccess();
  }

  Store<FastDoubleElements>(
      context: Context, sortState: FixedArray, elements: Object, index: Smi,
      value: Object): Smi {
    let elems: FixedDoubleArray = unsafe_cast<FixedDoubleArray>(elements);
    let heap_val: HeapNumber = unsafe_cast<HeapNumber>(value);
    // Make sure we do not store signalling NaNs into double arrays.
    let val: float64 = Float64SilenceNaN(convert<float64>(heap_val));
    StoreFixedDoubleArrayElementWithSmiIndex(elems, index, val);
    return kSuccess();
  }

  Store<DictionaryElements>(
      context: Context, sortState: FixedArray, elements: Object, index: Smi,
      value: Object): Smi {
    let dictionary: NumberDictionary = unsafe_cast<NumberDictionary>(elements);
    let intptr_index: intptr = convert<intptr>(index);
    try {
      BasicStoreNumberDictionaryElement(dictionary, intptr_index, value)
      otherwise Fail, Fail, ReadOnly;
      return kSuccess();
    }
    label ReadOnly {
      let receiver: Object = sortState[kReceiverIdx()];
      ThrowTypeError(
          context, kStrictReadOnlyProperty, index, Typeof(receiver), receiver);
    }
    label Fail {
      return kFailure();
    }
  }

  Store<WorkArrayElements>(
      context: Context, sortState: FixedArray, elements: Object, index: Smi,
      value: Object): Smi {
    let elems: FixedArray = unsafe_cast<FixedArray>(elements);
    elems[index] = value;
    return kSuccess();
  }

  type CompareBuiltinFn = builtin(Context, Object, Object, Object) => Number;
  extern macro UnsafeCastObjectToCompareBuiltinFn(Object): CompareBuiltinFn;
  unsafe_cast<CompareBuiltinFn>(o: Object): CompareBuiltinFn {
    return UnsafeCastObjectToCompareBuiltinFn(o);
  }

  extern macro UnsafeCastObjectToLoadFn(Object): LoadFn;
  unsafe_cast<LoadFn>(o: Object): LoadFn {
    return UnsafeCastObjectToLoadFn(o);
  }

  extern macro UnsafeCastObjectToStoreFn(Object): StoreFn;
  unsafe_cast<StoreFn>(o: Object): StoreFn {
    return UnsafeCastObjectToStoreFn(o);
  }

  extern macro UnsafeCastObjectToCanUseSameAccessorFn(Object):
      CanUseSameAccessorFn;
  unsafe_cast<CanUseSameAccessorFn>(o: Object): CanUseSameAccessorFn {
    return UnsafeCastObjectToCanUseSameAccessorFn(o);
  }

  builtin SortCompareDefault(
      context: Context, comparefn: Object, x: Object, y: Object): Number {
    assert(comparefn == Undefined);

    if (TaggedIsSmi(x) && TaggedIsSmi(y)) {
      // TODO(szuend): Replace with a fast CallCFunction call.
      return SmiLexicographicCompare(context, x, y);
    }

    // 5. Let xString be ? ToString(x).
    let xString: String = ToString_Inline(context, x);

    // 6. Let yString be ? ToString(y).
    let yString: String = ToString_Inline(context, y);

    // 7. Let xSmaller be the result of performing
    //    Abstract Relational Comparison xString < yString.
    // 8. If xSmaller is true, return -1.
    if (StringLessThan(context, xString, yString) == True) return -1;

    // 9. Let ySmaller be the result of performing
    //    Abstract Relational Comparison yString < xString.
    // 10. If ySmaller is true, return 1.
    if (StringLessThan(context, yString, xString) == True) return 1;

    // 11. Return +0.
    return 0;
  }

  builtin SortCompareUserFn(
      context: Context, comparefn: Object, x: Object, y: Object): Number {
    assert(comparefn != Undefined);
    let cmpfn: Callable = unsafe_cast<Callable>(comparefn);

    // a. Let v be ? ToNumber(? Call(comparefn, undefined, x, y)).
    let v: Number =
        ToNumber_Inline(context, Call(context, cmpfn, Undefined, x, y));

    // b. If v is NaN, return +0.
    if (NumberIsNaN(v)) return 0;

    // c. return v.
    return v;
  }

  builtin CanUseSameAccessor<ElementsAccessor : type>(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number): Boolean {
    assert(IsJSArray(unsafe_cast<HeapObject>(receiver)));

    let a: JSArray = unsafe_cast<JSArray>(receiver);
    if (a.map != initialReceiverMap) return False;

    assert(TaggedIsSmi(initialReceiverLength));
    let originalLength: Smi = unsafe_cast<Smi>(initialReceiverLength);
    if (a.length_fast != originalLength) return False;

    if (a.elements != elements) return False;

    return True;
  }

  CanUseSameAccessor<GenericElementsAccessor>(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number): Boolean {
    // Do nothing. We are already on the slow path.
    return True;
  }

  CanUseSameAccessor<DictionaryElements>(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number): Boolean {
    let obj: JSReceiver = unsafe_cast<JSReceiver>(receiver);
    return obj.map == initialReceiverMap ? True : False;
  }

  CanUseSameAccessor<WorkArrayElements>(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number): Boolean {
    // Do nothing for the work array. Otherwise we might bail to the slow path
    // even if we are already on the slow path.
    return True;
  }

  macro CallCompareFn(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number,
      userCmpFn: Object, sortCompare: CompareBuiltinFn,
      CanUseSameAccessor: CanUseSameAccessorFn, x: Object,
      y: Object): Number labels Bailout {
    let result: Number = sortCompare(context, userCmpFn, x, y);
    if (CanUseSameAccessor(
            context, receiver, elements, initialReceiverMap,
            initialReceiverLength) == False)
      goto Bailout;
    return result;
  }

  // TODO(szuend): Replace these with constants when Torque has them.
  macro kReceiverIdx(): constexpr int31 {
    return 0;
  }
  macro kUserCmpFnIdx(): constexpr int31 {
    return 1;
  }
  macro kSortComparePtrIdx(): constexpr int31 {
    return 2;
  }
  macro kInitialReceiverMapIdx(): constexpr int31 {
    return 3;
  }
  macro kInitialReceiverLengthIdx(): constexpr int31 {
    return 4;
  }
  macro kElementsIdx(): constexpr int31 {
    return 5;
  }
  macro kRunBaseStackIdx(): constexpr int31 {
    return 6;
  }
  macro kRunLensStackIdx(): constexpr int31 {
    return 7;
  }
  macro kStackSizeIdx(): constexpr int31 {
    return 8;
  }
  macro kWorkArrayIdx(): constexpr int31 {
    return 9;
  }
  macro kWorkArraySizeIdx(): constexpr int31 {
    return 10;
  }
  macro kMinGallopIdx(): constexpr int31 {
    return 11;
  }
  macro kBailoutStatusIdx(): constexpr int31 {
    return 12;
  }
  macro kLoadFnIdx(): constexpr int31 {
    return 13;
  }
  macro kStoreFnIdx(): constexpr int31 {
    return 14;
  }
  macro kCanUseSameAccessorFnIdx(): constexpr int31 {
    return 15;
  }
  macro kSortStateSize(): intptr {
    return IntPtrConstant(16);
  }

  macro kFailure(): Smi {
    return SmiConstant(-1);
  }
  macro kSuccess(): Smi {
    return SmiConstant(0);
  }

  // Re-loading the stack-size is done in a few places. The small macro allows
  // for easier invariant checks at all use sites.
  macro GetStackSize(sortState: FixedArray): Smi {
    assert(TaggedIsSmi(sortState[kStackSizeIdx()]));
    let stack_size: Smi = unsafe_cast<Smi>(sortState[kStackSizeIdx()]);

    assert(stack_size >= 0);
    return stack_size;
  }

  macro GetLoadFn(sortState: FixedArray): LoadFn {
    return unsafe_cast<LoadFn>(sortState[kLoadFnIdx()]);
  }

  macro GetStoreFn(sortState: FixedArray): StoreFn {
    return unsafe_cast<StoreFn>(sortState[kStoreFnIdx()]);
  }

  macro GetCanUseSameAccessorFn(sortState: FixedArray): CanUseSameAccessorFn {
    return unsafe_cast<CanUseSameAccessorFn>(
        sortState[kCanUseSameAccessorFnIdx()]);
  }

  macro CallLoad(
      context: Context, sortState: FixedArray, Load: LoadFn, elements: Object,
      index: Smi): Object labels Bailout {
    let result: Object = Load(context, sortState, elements, index);
    if (unsafe_cast<Smi>(sortState[kBailoutStatusIdx()]) < 0) goto Bailout;
    return result;
  }

  macro CallStore(
      context: Context, sortState: FixedArray, Store: StoreFn, elements: Object,
      index: Smi, value: Object) labels Bailout {
    let result: Smi = Store(context, sortState, elements, index, value);
    if (result < 0) goto Bailout;
  }

  // Returns the length of the run beginning at the specified position in the
  // array and reverses the run if it is descending (ensuring that the run will
  // always be ascending when the method returns).
  //
  // A run is the longest ascending sequence with:
  //
  //   a[from] <= a[from + 1] <= a[from + 2] <= ...
  //
  // or the longest descending sequence with:
  //
  //  a[from] > a[from + 1] > a[from + 2] > ...
  builtin CountRunAndMakeAscending(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number, from: Smi,
      to: Smi, userCmpFn: Object, sortCompare: CompareBuiltinFn,
      sortState: FixedArray): Smi {
    assert(from < to);

    let Load: LoadFn = GetLoadFn(sortState);
    let Store: StoreFn = GetStoreFn(sortState);
    let CanUseSameAccessor: CanUseSameAccessorFn =
        GetCanUseSameAccessorFn(sortState);

    let run_high: Smi = from + 1;
    if (run_high == to) return 1;

    try {
      // Find end of run, and reverse range if descending.
      let lo_elem: Object =
          CallLoad(context, sortState, Load, elements, from) otherwise Bailout;
      let hi_elem: Object = CallLoad(
          context, sortState, Load, elements, run_high++) otherwise Bailout;
      let order: Number = CallCompareFn(
          context, receiver, elements, initialReceiverMap,
          initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
          lo_elem, hi_elem)
      otherwise Bailout;
      if (order > 0) {  // Descending.
        while (run_high < to) {
          let run_high_elem: Object = CallLoad(
              context, sortState, Load, elements, run_high) otherwise Bailout;
          let run_next_elem: Object =
              CallLoad(context, sortState, Load, elements, run_high - 1)
          otherwise Bailout;
          order = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              run_high_elem, run_next_elem)
          otherwise Bailout;
          if (order >= 0) break;
          run_high++;
        }
        ReverseRange(context, sortState, Load, Store, elements, from, run_high)
        otherwise Bailout;
      } else {  // Ascending.
        while (run_high < to) {
          let run_high_elem: Object = CallLoad(
              context, sortState, Load, elements, run_high) otherwise Bailout;
          let run_next_elem: Object =
              CallLoad(context, sortState, Load, elements, run_high - 1)
          otherwise Bailout;
          order = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              run_high_elem, run_next_elem)
          otherwise Bailout;
          if (order < 0) break;
          run_high++;
        }
      }
      return run_high - from;
    }
    label Bailout {
      return kFailure();
    }
  }

  // Reverses the specified range of the given array.
  macro ReverseRange(
      context: Context, sortState: FixedArray, Load: LoadFn, Store: StoreFn,
      elements: Object, from: Smi, to: Smi)
  labels Bailout {
    let high: Smi = to - 1;
    let low: Smi = from;

    while (low < high) {
      let loElem: Object =
          CallLoad(context, sortState, Load, elements, low) otherwise Bailout;
      let hiElem: Object =
          CallLoad(context, sortState, Load, elements, high) otherwise Bailout;
      CallStore(context, sortState, Store, elements, low++, hiElem)
          otherwise Bailout;
      CallStore(context, sortState, Store, elements, high--, loElem)
          otherwise Bailout;
    }
  }

  // Sorts the specified portion of the array using a binary insertion sort.
  // This is the best method for sorting small number of elements.
  // If the initial part of the specified range is already sorted,
  // this method can take advantage of it: the builtin assumes that the elements
  // in [from, start) are already sorted.
  builtin BinaryInsertionSort(
      context: Context, receiver: Object, elements: Object,
      initialReceiverMap: Object, initialReceiverLength: Number, fromArg: Smi,
      toArg: Smi, startArg: Smi, userCmpFn: Object,
      sortCompare: CompareBuiltinFn, sortState: FixedArray): Smi {
    assert(fromArg <= startArg && startArg <= toArg);

    let Load: LoadFn = GetLoadFn(sortState);
    let Store: StoreFn = GetStoreFn(sortState);
    let CanUseSameAccessor: CanUseSameAccessorFn =
        GetCanUseSameAccessorFn(sortState);

    let start: Smi = startArg == fromArg ? startArg + 1 : startArg;

    try {
      for (; start < toArg; start++) {
        let pivot: Object = CallLoad(context, sortState, Load, elements, start)
        otherwise Bailout;

        // Set left (and right) to the index where a[start] (pivot) belongs.
        let left: Smi = fromArg;
        let right: Smi = start;
        assert(left <= right);

        // Invariants:
        //   pivot >= all in [from, left).
        //   pivot <  all in [right, start).
        while (left < right) {
          let mid: Smi = (left + right) >>> 1;
          let mid_elem: Object = CallLoad(
              context, sortState, Load, elements, mid) otherwise Bailout;
          let order: Number = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              pivot, mid_elem)
          otherwise Bailout;
          if (order < 0)
            right = mid;
          else
            left = mid + 1;
        }
        assert(left == right);

        // The invariants still hold, so pivot belongs at left. Note that if
        // there are elements equal to pivot, left points to the first slot
        // after them -- thats why this sort is stable.
        // Slide elements over to make room for pivot.
        let n: Smi = start - left;  // The number of elements to move.
        for (let j: Smi = left + n - 1; j >= left; --j) {
          let tmp: Object =
              CallLoad(context, sortState, Load, elements, j) otherwise Bailout;
          CallStore(context, sortState, Store, elements, j + 1, tmp)
              otherwise Bailout;
        }
        CallStore(context, sortState, Store, elements, left, pivot)
            otherwise Bailout;
      }
      return kSuccess();
    }
    label Bailout {
      return kFailure();
    }
  }

  // Returns the minimum acceptable run length for an array of the specified
  // length. Natural runs shorter than this will be extended with
  // BinaryInsertionSort.
  macro MinRunLength(nArg: Smi, kMinMerge: Smi): Smi {
    assert(nArg >= 0);
    let n: Smi = nArg;
    let r: Smi = 0;  // Becomes 1 if any 1 bits are shifted off.
    while (n >= kMinMerge) {
      r = r | (n & 1);
      n = n >>> 1;
    }
    return n + r;
  }

  // Merges the two runs at stack indices i and i + 1. Run i must be the
  // penultimate or antepenultimate run on the stack. In other words, i must be
  // equal to stack_size - 2 or stack_size - 3.
  builtin MergeAt(context: Context, sortState: FixedArray, i: Smi): Smi {
    let stack_size: Smi = GetStackSize(sortState);
    let run_base: FixedArray =
        unsafe_cast<FixedArray>(sortState[kRunBaseStackIdx()]);
    let run_lens: FixedArray =
        unsafe_cast<FixedArray>(sortState[kRunLensStackIdx()]);
    let elements: Object = sortState[kElementsIdx()];
    let Load: LoadFn = GetLoadFn(sortState);
    let CanUseSameAccessor: CanUseSameAccessorFn =
        GetCanUseSameAccessorFn(sortState);

    assert(stack_size >= 2);
    assert(i >= 0);
    assert(i == stack_size - 2 || i == stack_size - 3);

    let base1: Smi = unsafe_cast<Smi>(run_base[i]);
    let len1: Smi = unsafe_cast<Smi>(run_lens[i]);
    let base2: Smi = unsafe_cast<Smi>(run_base[i + 1]);
    let len2: Smi = unsafe_cast<Smi>(run_lens[i + 1]);
    assert(len1 > 0 && len2 > 0);
    assert(base1 + len1 == base2);

    // Record the length of the combined runs; if i is the 3rd-last run now,
    // also slide over the last run (which isn't involved in this merge).
    // The current run (i + 1) goes away in any case.
    run_lens[i] = len1 + len2;
    if (i == stack_size - 3) {
      run_base[i + 1] = run_base[i + 2];
      run_lens[i + 1] = run_lens[i + 2];
    }
    stack_size--;
    sortState[kStackSizeIdx()] = stack_size;
    try {
      // Find where the first element of run2 goes in run1. Prior elements in
      // run1 can be ignored (because the are already in place).
      let key_right: Object =
          CallLoad(context, sortState, Load, elements, base2)
      otherwise Bailout;

      let k: Smi = GallopRight(
          context, sortState, Load, CanUseSameAccessor, key_right, elements,
          base1, len1, 0);
      if (k < 0) goto Bailout;
      assert(k >= 0);
      base1 = base1 + k;
      len1 = len1 - k;
      if (len1 == 0) return kSuccess();

      // Find where the last element of run1 goes in run2. Subsequent elements
      // in run2 can be ignored (because they are already in place).
      let key_left: Object =
          CallLoad(context, sortState, Load, elements, base1 + len1 - 1)
      otherwise Bailout;

      len2 = GallopLeft(
          context, sortState, Load, CanUseSameAccessor, key_left, elements,
          base2, len2, len2 - 1);
      if (len2 < 0) goto Bailout;
      assert(len2 >= 0);
      if (len2 == 0) return kSuccess();

      // Merge remaining runs, using tmp array with min(len1, len2) elements.
      if (len1 <= len2) MergeLow(context, sortState, base1, len1, base2, len2)
        otherwise Bailout;
      else
        MergeHigh(context, sortState, base1, len1, base2, len2)
        otherwise Bailout;
      return kSuccess();
    }
    label Bailout {
      return kFailure();
    }
  }

  // Locates the position at which to insert the specified key into the
  // specified sorted range; if the range contains an element equal to key,
  // returns the index of the leftmost equal element.
  //
  // Returns the Smi k, 0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
  // pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
  // In other words, key belongs at index b + k.
  builtin GallopLeft(
      context: Context, sortState: FixedArray, Load: LoadFn,
      CanUseSameAccessor: CanUseSameAccessorFn, key: Object, elements: Object,
      base: Smi, len: Smi, hint: Smi): Smi {
    assert(len > 0 && hint >= 0 && hint < len);

    let receiver: Object = sortState[kReceiverIdx()];
    let userCmpFn: Object = sortState[kUserCmpFnIdx()];
    let sortCompare: CompareBuiltinFn =
        unsafe_cast<CompareBuiltinFn>(sortState[kSortComparePtrIdx()]);
    let initialReceiverMap: Object = sortState[kInitialReceiverMapIdx()];
    let initialReceiverLength: Number =
        unsafe_cast<Number>(sortState[kInitialReceiverLengthIdx()]);

    let last_ofs: Smi = 0;
    let ofs: Smi = 1;

    try {
      let base_hint: Object =
          CallLoad(context, sortState, Load, elements, base + hint)
      otherwise Bailout;
      let order: Number = CallCompareFn(
          context, receiver, elements, initialReceiverMap,
          initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
          key, base_hint)
      otherwise Bailout;

      if (order > 0) {
        // Gallop right until a[base+hint+last_ofs] < key <= a[base+hint+ofs].
        let max_ofs: Smi = len - hint;
        while (ofs < max_ofs) {
          let base_hint_ofs: Object =
              CallLoad(context, sortState, Load, elements, base + hint + ofs)
          otherwise Bailout;
          order = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              key, base_hint_ofs)
          otherwise Bailout;

          if (order <= 0) break;

          last_ofs = ofs;
          ofs = (ofs * SmiConstant(2)) + 1;

          // integer overflow.
          if (ofs <= 0) ofs = max_ofs;
        }

        if (ofs > max_ofs) ofs = max_ofs;

        // Make offsets relative to base.
        last_ofs = last_ofs + hint;
        ofs = ofs + hint;
      } else {  // key <= a[base + hint]
        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
        let max_ofs: Smi = hint + 1;
        while (ofs < max_ofs) {
          let base_hint_ofs: Object =
              CallLoad(context, sortState, Load, elements, base + hint - ofs)
          otherwise Bailout;
          order = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              key, base_hint_ofs)
          otherwise Bailout;

          if (order > 0) break;

          last_ofs = ofs;
          ofs = (ofs * 2) + 1;

          // integer overflow.
          if (ofs <= 0) ofs = max_ofs;
        }

        if (ofs > max_ofs) ofs = max_ofs;

        // Make offsets relative to base.
        let tmp: Smi = last_ofs;
        last_ofs = hint - ofs;
        ofs = hint - tmp;
      }
      assert(-1 <= last_ofs && last_ofs < ofs && ofs <= len);

      // Now a[base+last_ofs] < key <= a[base+ofs], so key belongs somewhere to
      // the right of last_ofs but no farther right than ofs. Do a binary
      // search, with invariant a[base + last_ofs - 1] < key <= a[base + ofs].
      last_ofs++;
      while (last_ofs < ofs) {
        let m: Smi = last_ofs + ((ofs - last_ofs) >>> 1);

        let base_m: Object =
            CallLoad(context, sortState, Load, elements, base + m)
        otherwise Bailout;
        order = CallCompareFn(
            context, receiver, elements, initialReceiverMap,
            initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
            key, base_m)
        otherwise Bailout;

        if (order > 0)
          last_ofs = m + 1;  // a[base + m] < key
        else
          ofs = m;  // key <= a[base + m]
      }
      assert(last_ofs == ofs);  // so a[base + ofs - 1] <= key < a[b + ofs]
      return ofs;
    }
    label Bailout {
      return kFailure();
    }
  }

  // Like GallopLeft, except that if the range contains an element equal to
  // key, GallopRight returns the index after the rightmost equal element.
  builtin GallopRight(
      context: Context, sortState: FixedArray, Load: LoadFn,
      CanUseSameAccessor: CanUseSameAccessorFn, key: Object, elements: Object,
      base: Smi, len: Smi, hint: Smi): Smi {
    assert(len > 0 && hint >= 0 && hint < len);

    let receiver: Object = sortState[kReceiverIdx()];
    let userCmpFn: Object = sortState[kUserCmpFnIdx()];
    let sortCompare: CompareBuiltinFn =
        unsafe_cast<CompareBuiltinFn>(sortState[kSortComparePtrIdx()]);
    let initialReceiverMap: Object = sortState[kInitialReceiverMapIdx()];
    let initialReceiverLength: Number =
        unsafe_cast<Number>(sortState[kInitialReceiverLengthIdx()]);

    let last_ofs: Smi = 0;
    let ofs: Smi = 1;

    try {
      let base_hint: Object =
          CallLoad(context, sortState, Load, elements, base + hint)
      otherwise Bailout;
      let order: Number = CallCompareFn(
          context, receiver, elements, initialReceiverMap,
          initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
          key, base_hint)
      otherwise Bailout;

      if (order < 0) {
        // Gallop left until a[base+hint-ofs] <= key < a[base+hint-last_ofs].
        let max_ofs: Smi = hint + 1;
        while (ofs < max_ofs) {
          let base_hint_ofs: Object =
              CallLoad(context, sortState, Load, elements, base + hint - ofs)
          otherwise Bailout;
          order = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              key, base_hint_ofs)
          otherwise Bailout;

          if (order >= 0) break;

          last_ofs = ofs;
          ofs = (ofs * SmiConstant(2)) + 1;

          // integer overflow.
          if (ofs <= 0) ofs = max_ofs;
        }

        if (ofs > max_ofs) ofs = max_ofs;

        // Make offsets relative to base.
        let tmp: Smi = last_ofs;
        last_ofs = hint - ofs;
        ofs = hint - tmp;
      } else {  // a[base + hint] <= key
        // Gallop right until a[base+hint+last_ofs] <= key < a[base+hint+ofs].
        let max_ofs: Smi = len - hint;
        while (ofs < max_ofs) {
          let base_hint_ofs: Object =
              CallLoad(context, sortState, Load, elements, base + hint + ofs)
          otherwise Bailout;
          order = CallCompareFn(
              context, receiver, elements, initialReceiverMap,
              initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
              key, base_hint_ofs)
          otherwise Bailout;

          if (order < 0) break;

          last_ofs = ofs;
          ofs = (ofs * 2) + 1;

          // integer overflow.
          if (ofs <= 0) ofs = max_ofs;
        }

        if (ofs > max_ofs) ofs = max_ofs;

        // Make offsets relative to base.
        last_ofs = last_ofs + hint;
        ofs = ofs + hint;
      }
      assert(-1 <= last_ofs && last_ofs < ofs && ofs <= len);

      // Now a[base+last_ofs] <= key < a[base+ofs], so key belongs somewhere to
      // the right of last_ofs but no farther right than ofs. Do a binary
      // search, with invariant a[base + last_ofs - 1] < key <= a[base + ofs].
      last_ofs++;
      while (last_ofs < ofs) {
        let m: Smi = last_ofs + ((ofs - last_ofs) >>> 1);

        let base_m: Object =
            CallLoad(context, sortState, Load, elements, base + m)
        otherwise Bailout;
        order = CallCompareFn(
            context, receiver, elements, initialReceiverMap,
            initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessor,
            key, base_m)
        otherwise Bailout;

        if (order < 0)
          ofs = m;  // key < a[base + m].
        else
          last_ofs = m + 1;  // a[base + m] <= key.
      }
      assert(last_ofs == ofs);  // so a[base + ofs - 1] <= key < a[b + ofs]
      return ofs;
    }
    label Bailout {
      return kFailure();
    }
  }

  // Ensures that the work_array has at least the specified number of elements,
  // increasing its size if necessary. Thie size increases exponentially to
  // ensure amortized linear time complexity.
  macro EnsureWorkArrayCapacity(sortState: FixedArray, minCapacity: Smi) {
    assert(TaggedIsSmi(sortState[kWorkArraySizeIdx()]));
    let work_array_size: Smi = unsafe_cast<Smi>(sortState[kWorkArraySizeIdx()]);
    if (work_array_size < minCapacity) {
      let new_size: Smi = minCapacity;
      new_size = new_size | (new_size >>> 1);
      new_size = new_size | (new_size >>> 2);
      new_size = new_size | (new_size >>> 4);
      new_size = new_size | (new_size >>> 8);
      new_size = new_size | (new_size >>> 16);
      new_size++;

      if (new_size < 0)
        new_size = minCapacity;
      else {
        let half_length: Smi =
            unsafe_cast<Smi>(sortState[kInitialReceiverLengthIdx()]) >>> 1;
        new_size = new_size < half_length ? new_size : half_length;
      }

      sortState[kWorkArrayIdx()] =
          AllocateFixedArray(PACKED_ELEMENTS, convert<intptr>(new_size));
      sortState[kWorkArraySizeIdx()] = new_size;
      FillFixedArrayWithZero(
          unsafe_cast<FixedArray>(sortState[kWorkArrayIdx()]), new_size);
    }
  }

  macro CopyToWorkArray(
      context: Context, sortState: FixedArray, Load: LoadFn,
      srcElements: Object, srcPos: Smi, workArray: FixedArray, dstPos: Smi,
      length: Smi)
  labels Bailout {
    let src_idx: Smi = srcPos;
    let dst_idx: Smi = dstPos;
    let to: Smi = srcPos + length;
    assert(dst_idx + length <= workArray.length);
    while (src_idx < to) {
      let element: Object =
          CallLoad(context, sortState, Load, srcElements, src_idx++)
      otherwise Bailout;
      workArray[dst_idx++] = element;
    }
  }

  builtin CopyFromWorkArray(
      context: Context, sortState: FixedArray, dstElements: Object, dstPos: Smi,
      workArray: FixedArray, srcPos: Smi, length: Smi): Smi {
    assert(srcPos >= 0);
    assert(dstPos >= 0);

    let Store: StoreFn = GetStoreFn(sortState);

    let src_idx: Smi = srcPos;
    let dst_idx: Smi = dstPos;
    let to: Smi = srcPos + length;
    try {
      while (src_idx < to) {
        CallStore(
            context, sortState, Store, dstElements, dst_idx++,
            workArray[src_idx++])
        otherwise Bailout;
      }
      return kSuccess();
    }
    label Bailout {
      return kFailure();
    }
  }

  builtin CopyWithinSortArray(
      context: Context, sortState: FixedArray, elements: Object, srcPos: Smi,
      dstPos: Smi, length: Smi): Smi {
    assert(srcPos >= 0);
    assert(dstPos >= 0);
    try {
      let Load: LoadFn = GetLoadFn(sortState);
      let Store: StoreFn = GetStoreFn(sortState);

      if (srcPos < dstPos) {
        let src_idx: Smi = srcPos + length - 1;
        let dst_idx: Smi = dstPos + length - 1;
        while (src_idx >= srcPos) {
          let element: Object =
              CallLoad(context, sortState, Load, elements, src_idx--)
          otherwise Bailout;
          CallStore(context, sortState, Store, elements, dst_idx--, element)
          otherwise Bailout;
        }
      } else {
        let src_idx: Smi = srcPos;
        let dst_idx: Smi = dstPos;
        let to: Smi = srcPos + length;
        while (src_idx < to) {
          let element: Object =
              CallLoad(context, sortState, Load, elements, src_idx++)
          otherwise Bailout;
          CallStore(context, sortState, Store, elements, dst_idx++, element)
          otherwise Bailout;
        }
      }
      return kSuccess();
    }
    label Bailout {
      return kFailure();
    }
  }

  // Merges two adjacent runs in place, in a stable fashion. The first element
  // of the first run must be greater than the first element of the second run
  // (a[base1] > a[base2]), and the last element of the first run
  // (a[base1 + len1-1]) must be greater than all elements of the second run.
  //
  // For performance, this method should be called only when len1 <= len2;
  // its twin, MergeHigh should be clled if len1 >= len2.
  macro MergeLow(
      context: Context, sortState: FixedArray, base1: Smi, len1Arg: Smi,
      base2: Smi, len2Arg: Smi): Object
  labels Bailout {
    assert(len1Arg > 0 && len2Arg > 0 && base1 + len1Arg == base2);

    let len1: Smi = len1Arg;
    let len2: Smi = len2Arg;
    let receiver: Object = sortState[kReceiverIdx()];
    let userCmpFn: Object = sortState[kUserCmpFnIdx()];
    let sortCompare: CompareBuiltinFn =
        unsafe_cast<CompareBuiltinFn>(sortState[kSortComparePtrIdx()]);
    let initialReceiverMap: Object = sortState[kInitialReceiverMapIdx()];
    let initialReceiverLength: Number =
        unsafe_cast<Number>(sortState[kInitialReceiverLengthIdx()]);
    let elements: Object = sortState[kElementsIdx()];
    let LoadF: LoadFn = GetLoadFn(sortState);
    let Store: StoreFn = GetStoreFn(sortState);
    let CanUseSameAccessorF: CanUseSameAccessorFn =
        GetCanUseSameAccessorFn(sortState);

    // Copy first run into temp array.
    EnsureWorkArrayCapacity(sortState, len1);
    let work_array: FixedArray =
        unsafe_cast<FixedArray>(sortState[kWorkArrayIdx()]);

    let cursor1: Smi = 0;      // Indexes into work array.
    let cursor2: Smi = base2;  // Indexes into a.
    let dest: Smi = base1;     // Indexes into a.
    CopyToWorkArray(
        context, sortState, LoadF, elements, base1, work_array, cursor1, len1)
    otherwise Bailout;

    // Move first element of second run and deal with degenerate cases.
    let elem_cursor2: Object =
        CallLoad(context, sortState, LoadF, elements, cursor2++)
    otherwise Bailout;
    CallStore(context, sortState, Store, elements, dest++, elem_cursor2)
        otherwise Bailout;

    if (--len2 == 0) {
      CopyFromWorkArray(
          context, sortState, elements, dest, work_array, cursor1, len1);
      return kSuccess();
    }
    if (len1 == 1) {
      let r: Smi = CopyWithinSortArray(
          context, sortState, elements, cursor2, dest, len2);
      if (r < 0) goto Bailout;
      // Last element of run 1 to end of merge.
      CallStore(
          context, sortState, Store, elements, dest + len2, work_array[cursor1])
      otherwise Bailout;
      return kSuccess();
    }

    assert(TaggedIsSmi(sortState[kMinGallopIdx()]));
    let min_gallop: Smi = unsafe_cast<Smi>(sortState[kMinGallopIdx()]);
    while (True == True) {
      let break_outer: bool = false;
      let count1: Smi = 0;  // Number of times in a row that first run won.
      let count2: Smi = 0;  // Number of times in a row that second run won.

      // Do the straightforward thing until (if ever) one run starts
      // winning consistantly.
      let first_iteration: bool = true;
      while (((count1 | count2) < min_gallop) || first_iteration) {
        first_iteration = false;

        assert(len1 > 1 && len2 > 0);
        let elem_a: Object =
            CallLoad(context, sortState, LoadF, elements, cursor2)
        otherwise Bailout;
        let elem_work: Object = work_array[cursor1];
        let order: Number = CallCompareFn(
            context, receiver, elements, initialReceiverMap,
            initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessorF,
            elem_a, elem_work)
        otherwise Bailout;

        if (order < 0) {
          let tmp: Object =
              CallLoad(context, sortState, LoadF, elements, cursor2++)
          otherwise Bailout;
          CallStore(context, sortState, Store, elements, dest++, tmp)
              otherwise Bailout;
          count2++;
          count1 = 0;
          if (--len2 == 0) {
            break_outer = true;
            assert(
                CanUseSameAccessorF(
                    context, receiver, elements, initialReceiverMap,
                    initialReceiverLength) == True);

            break;
          }
        } else {
          CallStore(
              context, sortState, Store, elements, dest++,
              work_array[cursor1++])
          otherwise Bailout;
          count1++;
          count2 = 0;
          if (--len1 == 1) {
            break_outer = true;
            break;
          }
        }
      }

      if (break_outer) break;

      // One run is winning so consistently that galloping may be a huge win.
      // So try that, and continue galloping until (if ever) neither run
      // appears to be winning consistentyl anymore.
      first_iteration = false;
      while ((count1 >= 7 || count2 >= 7) || first_iteration) {
        first_iteration = false;
        assert(len1 > 1 && len2 > 0);

        let key_right: Object =
            CallLoad(context, sortState, LoadF, elements, cursor2)
        otherwise Bailout;

        count1 = GallopRight(
            context, sortState, Load<WorkArrayElements>,
            CanUseSameAccessor<WorkArrayElements>, key_right, work_array,
            cursor1, len1, 0);
        if (count1 < 0) goto Bailout;
        if (count1 != 0) {
          CopyFromWorkArray(
              context, sortState, elements, dest, work_array, cursor1, count1);
          dest = dest + count1;
          cursor1 = cursor1 + count1;
          len1 = len1 - count1;
          if (len1 <= 1) {
            break_outer = true;
            break;
          }
        }
        let tmp: Object =
            CallLoad(context, sortState, LoadF, elements, cursor2++)
        otherwise Bailout;
        CallStore(context, sortState, Store, elements, dest++, tmp)
            otherwise Bailout;
        if (--len2 == 0) {
          break_outer = true;
          break;
        }

        count2 = GallopLeft(
            context, sortState, LoadF, CanUseSameAccessorF, work_array[cursor1],
            elements, cursor2, len2, 0);
        if (count2 < 0) goto Bailout;
        if (count2 != 0) {
          let r: Smi = CopyWithinSortArray(
              context, sortState, elements, cursor2, dest, count2);
          if (r < 0) goto Bailout;
          dest = dest + count2;
          cursor2 = cursor2 + count2;
          len2 = len2 - count2;
          if (len2 == 0) {
            break_outer = true;
            break;
          }
        }
        CallStore(
            context, sortState, Store, elements, dest++, work_array[cursor1++])
        otherwise Bailout;
        if (--len1 == 1) {
          break_outer = true;
          break;
        }
        min_gallop--;
      }
      if (break_outer) break;
      if (min_gallop < 0) min_gallop = 0;
      min_gallop = min_gallop + 2;  // Penalize for leaving gallop mode
    }
    sortState[kMinGallopIdx()] = min_gallop < 1 ? SmiConstant(1) : min_gallop;
    assert(TaggedIsSmi(sortState[kMinGallopIdx()]));

    if (len1 == 1) {
      assert(len2 > 0);
      let r: Smi = CopyWithinSortArray(
          context, sortState, elements, cursor2, dest, len2);
      if (r < 0) goto Bailout;
      // Last element of run1 to end of merge
      CallStore(
          context, sortState, Store, elements, dest + len2, work_array[cursor1])
      otherwise Bailout;
    } else if (len1 == 0) {
      // Comparison function does not behave well.
      // Do nothing.
    } else {
      assert(len2 == 0);
      assert(len1 > 0);
      CopyFromWorkArray(
          context, sortState, elements, dest, work_array, cursor1, len1);
    }

    return kSuccess();
  }

  // Like MergeLow, except that this method should be called only if
  // len1 >= len2.
  macro MergeHigh(
      context: Context, sortState: FixedArray, base1: Smi, len1Arg: Smi,
      base2: Smi, len2Arg: Smi): Object
  labels Bailout {
    assert(len1Arg > 0 && len2Arg > 0 && base1 + len1Arg == base2);

    let len1: Smi = len1Arg;
    let len2: Smi = len2Arg;
    let receiver: Object = sortState[kReceiverIdx()];
    let userCmpFn: Object = sortState[kUserCmpFnIdx()];
    let sortCompare: CompareBuiltinFn =
        unsafe_cast<CompareBuiltinFn>(sortState[kSortComparePtrIdx()]);
    let initialReceiverMap: Object = sortState[kInitialReceiverMapIdx()];
    let initialReceiverLength: Number =
        unsafe_cast<Number>(sortState[kInitialReceiverLengthIdx()]);
    let elements: Object = sortState[kElementsIdx()];
    let LoadF: LoadFn = GetLoadFn(sortState);
    let Store: StoreFn = GetStoreFn(sortState);
    let CanUseSameAccessorF: CanUseSameAccessorFn =
        GetCanUseSameAccessorFn(sortState);

    // Copy second run into temp array.
    EnsureWorkArrayCapacity(sortState, len2);
    let work_array: FixedArray =
        unsafe_cast<FixedArray>(sortState[kWorkArrayIdx()]);
    let cursor1: Smi = base1 + len1 - 1;  // Indexes into a.
    let cursor2: Smi = len2 - 1;          // Indexes into work array.
    let dest: Smi = base2 + len2 - 1;     // Indexes into a.
    CopyToWorkArray(
        context, sortState, LoadF, elements, base2, work_array, 0, len2)
    otherwise Bailout;

    // Move last element of first run and deal with degenerate cases.
    let tmp: Object = CallLoad(context, sortState, LoadF, elements, cursor1--)
    otherwise Bailout;
    CallStore(context, sortState, Store, elements, dest--, tmp)
        otherwise Bailout;
    if (--len1 == 0) {
      CopyFromWorkArray(
          context, sortState, elements, dest - (len2 - 1), work_array, 0, len2);
      return kSuccess();
    }
    if (len2 == 1) {
      dest = dest - len1;
      cursor1 = cursor1 - len1;
      let r: Smi = CopyWithinSortArray(
          context, sortState, elements, cursor1 + 1, dest + 1, len1);
      if (r < 0) goto Bailout;
      CallStore(context, sortState, Store, elements, dest, work_array[cursor2])
      otherwise Bailout;
      return kSuccess();
    }

    assert(TaggedIsSmi(sortState[kMinGallopIdx()]));
    let min_gallop: Smi = unsafe_cast<Smi>(sortState[kMinGallopIdx()]);
    while (True == True) {
      let break_outer: bool = false;
      let count1: Smi = 0;  // Number of times in a row that first run won.
      let count2: Smi = 0;  // Number of times in a row that second run won.

      // Do the straightforward thing until (if ever) one run starts
      // winning consistantly.
      let first_iteration: bool = true;
      while (((count1 | count2) < min_gallop) || first_iteration) {
        first_iteration = false;

        assert(len1 > 0 && len2 > 1);
        let elem_work: Object = work_array[cursor2];
        let elem_a: Object =
            CallLoad(context, sortState, LoadF, elements, cursor1)
        otherwise Bailout;

        let order: Number = CallCompareFn(
            context, receiver, elements, initialReceiverMap,
            initialReceiverLength, userCmpFn, sortCompare, CanUseSameAccessorF,
            elem_work, elem_a)
        otherwise Bailout;

        if (order < 0) {
          let tmp: Object =
              CallLoad(context, sortState, LoadF, elements, cursor1--)
          otherwise Bailout;
          CallStore(context, sortState, Store, elements, dest--, tmp)
              otherwise Bailout;
          count1++;
          count2 = 0;
          if (--len1 == 0) {
            break_outer = true;
            break;
          }
        } else {
          CallStore(
              context, sortState, Store, elements, dest--,
              work_array[cursor2--])
          otherwise Bailout;
          count2++;
          count1 = 0;
          if (--len2 == 1) {
            break_outer = true;
            break;
          }
        }
      }

      if (break_outer) break;

      // One run is winning so consistently that galloping may be a huge win.
      // So try that, and continue galloping until (if ever) neither run
      // appears to be winning consistently anymore.
      first_iteration = false;
      while ((count1 >= 7 || count2 >= 7) || first_iteration) {
        first_iteration = false;
        assert(len1 > 0 && len2 > 1);

        let gallop: Smi = GallopRight(
            context, sortState, LoadF, CanUseSameAccessorF, work_array[cursor2],
            elements, base1, len1, len1 - 1);
        if (gallop < 0) goto Bailout;
        count1 = len1 - gallop;
        if (count1 != 0) {
          dest = dest - count1;
          cursor1 = cursor1 - count1;
          len1 = len1 - count1;
          let r: Smi = CopyWithinSortArray(
              context, sortState, elements, cursor1 + 1, dest + 1, count1);
          if (r < 0) goto Bailout;
          if (len1 == 0) {
            break_outer = true;
            break;
          }
        }
        CallStore(
            context, sortState, Store, elements, dest--, work_array[cursor2--])
        otherwise Bailout;
        if (--len2 == 1) {
          break_outer = true;
          break;
        }

        let key_left: Object =
            CallLoad(context, sortState, LoadF, elements, cursor1)
        otherwise Bailout;
        let gallopl: Smi = GallopLeft(
            context, sortState, Load<WorkArrayElements>,
            CanUseSameAccessor<WorkArrayElements>, key_left, work_array, 0,
            len2, len2 - 1);
        if (gallopl < 0) goto Bailout;
        count2 = len2 - gallopl;
        if (count2 != 0) {
          dest = dest - count2;
          cursor2 = cursor2 - count2;
          len2 = len2 - count2;
          CopyFromWorkArray(
              context, sortState, elements, dest + 1, work_array, cursor2 + 1,
              count2);
          if (len2 <= 1) {
            break_outer = true;
            break;
          }
        }
        let tmp: Object =
            CallLoad(context, sortState, LoadF, elements, cursor1--)
        otherwise Bailout;
        CallStore(context, sortState, Store, elements, dest--, tmp)
        otherwise Bailout;
        if (--len1 == 0) {
          break_outer = true;
          break;
        }
        min_gallop--;
      }
      if (break_outer) break;
      if (min_gallop < 0) min_gallop = 0;
      min_gallop = min_gallop + 2;  // Penalize for leaving gallop mode
    }
    sortState[kMinGallopIdx()] = min_gallop < 1 ? SmiConstant(1) : min_gallop;
    assert(TaggedIsSmi(sortState[kMinGallopIdx()]));

    if (len2 == 1) {
      assert(len1 > 0);
      dest = dest - len1;
      cursor1 = cursor1 - len1;
      let r: Smi = CopyWithinSortArray(
          context, sortState, elements, cursor1 + 1, dest + 1, len1);
      if (r < 0) goto Bailout;
      CallStore(context, sortState, Store, elements, dest, work_array[cursor2])
      otherwise Bailout;
    } else if (len2 == 0) {
      // Comparison function does not behave well.
      // Do nothing.
    } else {
      assert(len1 == 0);
      assert(len2 > 0);
      CopyFromWorkArray(
          context, sortState, elements, dest - (len2 - 1), work_array, 0, len2);
    }
    return kSuccess();
  }

  extern macro FillFixedArrayWithZero(FixedArray, Smi);

  // Examines the stack of runs waiting to be merged and merges adjacent runs
  // until the stack invariants are reestablished:
  //
  //   1. run_lens[i - 3] > run_lens[i - 2] + run_lens[i - 1]
  //   2. run_lens[i - 2] > run_lens[i - 1]
  //
  // This macro is called each time a new run is pushed onto the stack,
  // so the invariants are guaranteed to hold for i < stack_size upon entry
  // of the macro.
  macro MergeCollapse(context: Context, sortState: FixedArray)
  labels Bailout {
    let stack_size: Smi = GetStackSize(sortState);
    let run_lens: FixedArray =
        unsafe_cast<FixedArray>(sortState[kRunLensStackIdx()]);
    while (stack_size > 1) {
      let n: Smi = stack_size - 2;
      assert(n >= 0);

      let rl_n: Smi = unsafe_cast<Smi>(run_lens[n]);
      let rl_np: Smi = unsafe_cast<Smi>(run_lens[n + 1]);
      if (n > 0) {
        let rl_nm: Smi = unsafe_cast<Smi>(run_lens[n - 1]);
        if (rl_nm <= rl_n + rl_np) {
          if (rl_nm < rl_np) n--;
          let r: Smi = MergeAt(context, sortState, n);
          if (r < 0) goto Bailout;
          // Reload because MergeAt might have changed it.
          stack_size = GetStackSize(sortState);
          continue;
        }
      }

      if (rl_n <= rl_np) {
        let r: Smi = MergeAt(context, sortState, n);
        if (r < 0) goto Bailout;
      } else {
        break;  // Invariant is established.
      }

      // Reload because MergeAt might have changed it.
      stack_size = GetStackSize(sortState);
    }
  }

  macro ArrayTimSortImpl(
      context: Context, sortState: FixedArray, fromArg: Smi, toArg: Smi)
  labels Bailout {
    let receiver: Object = sortState[kReceiverIdx()];
    let userCmpFn: Object = sortState[kUserCmpFnIdx()];
    let sortCompare: CompareBuiltinFn =
        unsafe_cast<CompareBuiltinFn>(sortState[kSortComparePtrIdx()]);
    let initialReceiverMap: Object = sortState[kInitialReceiverMapIdx()];
    let initialReceiverLength: Number =
        unsafe_cast<Number>(sortState[kInitialReceiverLengthIdx()]);
    let elements: Object = sortState[kElementsIdx()];

    // This is the minimum sequence that will be merged. Shorter
    // sequences will be lengthened by calling BinaryInsertionSort.
    // This constant should be a tower of 2, otherwise MinRunLength macro
    // must be changed.
    let kMinMerge: int32 = 32;

    let kMinGallop: int32 = 7;
    let kInitialTmpStorageLength: int32 = 256;

    let remaining: Smi = toArg - fromArg;
    if (remaining < 2) return;

    // Use InsertionSort for small arrays.
    if (remaining < convert<Smi>(kMinMerge)) {
      let init_run_len: Smi = CountRunAndMakeAscending(
          context, receiver, elements, initialReceiverMap,
          initialReceiverLength, fromArg, toArg, userCmpFn, sortCompare,
          sortState);
      if (init_run_len < 0) goto Bailout;
      let r: Smi = BinaryInsertionSort(
          context, receiver, elements, initialReceiverMap,
          initialReceiverLength, fromArg, toArg, fromArg + init_run_len,
          userCmpFn, sortCompare, sortState);
      if (r < 0) goto Bailout;
      return;
    }

    let temporary_len: Smi =
        (toArg < convert<Smi>(Int32Constant(2) * kInitialTmpStorageLength)) ?
        toArg >>> 1 :
        convert<Smi>(kInitialTmpStorageLength);
    sortState[kWorkArrayIdx()] =
        AllocateFixedArray(PACKED_ELEMENTS, convert<intptr>(temporary_len));
    sortState[kWorkArraySizeIdx()] = temporary_len;
    sortState[kMinGallopIdx()] = convert<Smi>(kMinGallop);
    FillFixedArrayWithZero(
        unsafe_cast<FixedArray>(sortState[kWorkArrayIdx()]), temporary_len);

    // Allocate runs-to-be-merged stack (which cannot be expanded). The
    // "magic numbers" in the computation below must be changed if kMinMerge
    // is decreased.
    // More explanations are given in section 4 of:
    // http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf
    let stack_len: intptr =
        (toArg < 120 ? 5 : (toArg < 1542 ? 10 : (toArg < 119151 ? 24 : 49)));
    let run_base: FixedArray =
        AllocateFixedArray(PACKED_SMI_ELEMENTS, stack_len);
    FillFixedArrayWithZero(run_base, convert<Smi>(stack_len));

    let run_lens: FixedArray =
        AllocateFixedArray(PACKED_SMI_ELEMENTS, stack_len);
    FillFixedArrayWithZero(run_lens, convert<Smi>(stack_len));

    sortState[kRunBaseStackIdx()] = run_base;
    sortState[kRunLensStackIdx()] = run_lens;
    sortState[kStackSizeIdx()] = kSuccess();

    let from: Smi = fromArg;
    let min_run: Smi = MinRunLength(remaining, convert<Smi>(kMinMerge));
    while (remaining != 0) {
      // Identify next run.
      let run_len: Smi = CountRunAndMakeAscending(
          context, receiver, elements, initialReceiverMap,
          initialReceiverLength, from, toArg, userCmpFn, sortCompare,
          sortState);
      if (run_len < 0) goto Bailout;

      // If run is short, extend to min(minRun, remaining).
      if (run_len < min_run) {
        let force: Smi = min_run < remaining ? min_run : remaining;
        let r: Smi = BinaryInsertionSort(
            context, receiver, elements, initialReceiverMap,
            initialReceiverLength, from, from + force, from + run_len,
            userCmpFn, sortCompare, sortState);
        if (r < 0) goto Bailout;
        run_len = force;
      }

      // Push run onto pending-run stack, and maybe merge.
      let stack_size: Smi = GetStackSize(sortState);
      assert(stack_size >= 0);
      run_base[stack_size] = from;
      run_lens[stack_size] = run_len;
      stack_size++;
      sortState[kStackSizeIdx()] = stack_size;

      MergeCollapse(context, sortState) otherwise Bailout;

      // Advance to find next run.
      from = from + run_len;
      remaining = remaining - run_len;
    }

    // Merge all remaining runs to complete sort.
    assert(from == toArg);
    let stack_size: Smi = GetStackSize(sortState);
    while (stack_size > 1) {
      let n: Smi = stack_size - 2;
      if (n > 0) {
        assert(TaggedIsSmi(run_lens[n - 1]));
        assert(TaggedIsSmi(run_lens[n + 1]));
        let rl_nm: Smi = unsafe_cast<Smi>(run_lens[n - 1]);
        let rl_np: Smi = unsafe_cast<Smi>(run_lens[n + 1]);

        if (rl_nm < rl_np) n--;
      }
      let r: Smi = MergeAt(context, sortState, n);
      if (r < 0) goto Bailout;
      // Reload because MergeAt might have changed it.
      stack_size = GetStackSize(sortState);
    }

    assert(stack_size == 1);
  }

  builtin ArrayTimSort(
      context: Context, sortState: FixedArray, from: Smi, to: Smi): Object {
    try {
      ArrayTimSortImpl(context, sortState, from, to)
      otherwise Slow;
    }
    label Slow {
      if (sortState[kElementsIdx()] == sortState[kReceiverIdx()]) {
        // We already tried the slow path, this must never happen.
        unreachable;
      }
      sortState[kElementsIdx()] = sortState[kReceiverIdx()];
      sortState[kLoadFnIdx()] = Load<GenericElementsAccessor>;
      sortState[kStoreFnIdx()] = Store<GenericElementsAccessor>;
      sortState[kCanUseSameAccessorFnIdx()] =
          CanUseSameAccessor<GenericElementsAccessor>;
      sortState[kBailoutStatusIdx()] = kSuccess();
      ArrayTimSort(context, sortState, from, to);
    }
    return kSuccess();
  }

  // For compatibility with JSC, we also sort elements inherited from
  // the prototype chain on non-Array objects.
  // We do this by copying them to this object and sorting only
  // own elements. This is not very efficient, but sorting with
  // inherited elements happens very, very rarely, if at all.
  // The specification allows "implementation dependent" behavior
  // if an element on the prototype chain has an element that
  // might interact with sorting.
  //
  // We also move all non-undefined elements to the front of the
  // array and move the undefineds after that. Holes are removed.
  // This happens for Array as well as non-Array objects.
  extern runtime PrepareElementsForSort(Context, Object, Number): Smi;

  // https://tc39.github.io/ecma262/#sec-array.prototype.sort
  javascript builtin ArrayPrototypeSort(
      context: Context, receiver: Object, ...arguments): Object {
    // 1. If comparefn is not undefined and IsCallable(comparefn) is false,
    //    throw a TypeError exception.
    let comparefnObj: Object = arguments[0];
    if (comparefnObj != Undefined && !TaggedIsCallable(comparefnObj)) {
      ThrowTypeError(context, kBadSortComparisonFunction, comparefnObj);
    }

    // 2. Let obj be ? ToObject(this value).
    let obj: JSReceiver = ToObject(context, receiver);
    let map: Map = obj.map;

    let sort_state: FixedArray =
        AllocateFixedArray(PACKED_ELEMENTS, kSortStateSize());

    sort_state[kReceiverIdx()] = obj;
    sort_state[kUserCmpFnIdx()] = comparefnObj;
    sort_state[kSortComparePtrIdx()] =
        comparefnObj != Undefined ? SortCompareUserFn : SortCompareDefault;
    sort_state[kInitialReceiverMapIdx()] = map;
    sort_state[kBailoutStatusIdx()] = kSuccess();

    // Initialize the remaining fields with Undefined.
    // Needed for heap verification.
    sort_state[kInitialReceiverLengthIdx()] = Undefined;
    sort_state[kElementsIdx()] = Undefined;
    sort_state[kRunBaseStackIdx()] = Undefined;
    sort_state[kRunLensStackIdx()] = Undefined;
    sort_state[kStackSizeIdx()] = Undefined;
    sort_state[kWorkArrayIdx()] = Undefined;
    sort_state[kWorkArraySizeIdx()] = Undefined;
    sort_state[kMinGallopIdx()] = Undefined;
    sort_state[kLoadFnIdx()] = Undefined;
    sort_state[kStoreFnIdx()] = Undefined;
    sort_state[kCanUseSameAccessorFnIdx()] = Undefined;

    try {
      let a: JSArray = cast<JSArray>(obj) otherwise slow;
      let elementsKind: ElementsKind = map.elements_kind;
      if (!IsFastElementsKind(elementsKind)) goto slow;

      // 3. Let len be ? ToLength(? Get(obj, "length")).
      let len: Smi = a.length_fast;
      if (len < 2) return receiver;

      // TODO(szuend): Investigate performance tradeoff of skipping this step
      //               for PACKED_* and handling Undefineds during sorting.
      let nofNonUndefined: Smi = PrepareElementsForSort(context, obj, len);
      assert(a.map == map);

      sort_state[kInitialReceiverLengthIdx()] = len;
      sort_state[kElementsIdx()] = a.elements;

      if (IsDoubleElementsKind(elementsKind)) {
        sort_state[kLoadFnIdx()] = Load<FastDoubleElements>;
        sort_state[kStoreFnIdx()] = Store<FastDoubleElements>;
        sort_state[kCanUseSameAccessorFnIdx()] =
            CanUseSameAccessor<FastDoubleElements>;
        ArrayTimSort(context, sort_state, 0, nofNonUndefined);
      } else {
        if (elementsKind == PACKED_SMI_ELEMENTS) {
          sort_state[kLoadFnIdx()] = Load<FastPackedSmiElements>;
          sort_state[kStoreFnIdx()] = Store<FastPackedSmiElements>;
          sort_state[kCanUseSameAccessorFnIdx()] =
              CanUseSameAccessor<FastPackedSmiElements>;
          ArrayTimSort(context, sort_state, 0, nofNonUndefined);
        } else {
          sort_state[kLoadFnIdx()] = Load<FastSmiOrObjectElements>;
          sort_state[kStoreFnIdx()] = Store<FastSmiOrObjectElements>;
          sort_state[kCanUseSameAccessorFnIdx()] =
              CanUseSameAccessor<FastSmiOrObjectElements>;
          ArrayTimSort(context, sort_state, 0, nofNonUndefined);
        }
      }
    }
    label slow {
      // 3. Let len be ? ToLength(? Get(obj, "length")).
      let len: Number =
          ToLength_Inline(context, GetProperty(context, obj, 'length'));

      if (len < 2) return receiver;
      let nofNonUndefined: Smi = PrepareElementsForSort(context, obj, len);

      sort_state[kInitialReceiverLengthIdx()] = len;

      // Reload the map, PrepareElementsForSort might have changed the
      // elements kind.
      map = obj.map;

      if (map.elements_kind == DICTIONARY_ELEMENTS && IsExtensibleMap(map) &&
          !IsCustomElementsReceiverInstanceType(map.instance_type)) {
        let jsobj: JSObject = unsafe_cast<JSObject>(obj);
        sort_state[kElementsIdx()] = jsobj.elements;
        sort_state[kLoadFnIdx()] = Load<DictionaryElements>;
        sort_state[kStoreFnIdx()] = Store<DictionaryElements>;
        sort_state[kCanUseSameAccessorFnIdx()] =
            CanUseSameAccessor<DictionaryElements>;
        ArrayTimSort(context, sort_state, 0, nofNonUndefined);
        return receiver;
      }

      sort_state[kElementsIdx()] = obj;
      sort_state[kLoadFnIdx()] = Load<GenericElementsAccessor>;
      sort_state[kStoreFnIdx()] = Store<GenericElementsAccessor>;
      sort_state[kCanUseSameAccessorFnIdx()] =
          CanUseSameAccessor<GenericElementsAccessor>;
      ArrayTimSort(context, sort_state, 0, nofNonUndefined);
    }

    return receiver;
  }
}
