// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-typed-array-gen.h'

namespace typed_array {
  // Naming convention from elements.cc. We have a similar intent but implement
  // fastpaths using generics instead of using a class hierarchy for elements
  // kinds specific implementations.
  type Uint8Elements;
  type Int8Elements;
  type Uint16Elements;
  type Int16Elements;
  type Uint32Elements;
  type Int32Elements;
  type Float32Elements;
  type Float64Elements;
  type Uint8ClampedElements;
  type BigUint64Elements;
  type BigInt64Elements;

  @export
  struct TypedArrayElementsInfo {
    // Calculates the number of bytes required for specified number of elements.
    CalculateByteLength(length: uintptr): uintptr labels IfInvalid {
      // TODO(v8:4153): use kArrayBufferMaxByteLength instead of kSmiMaxValue
      // to allow creation of huge TypedArrays.
      const maxArrayLength = kSmiMaxValue >>> this.sizeLog2;
      if (length > maxArrayLength) goto IfInvalid;
      const byteLength = length << this.sizeLog2;
      return byteLength;
    }

    // Calculates the maximum number of elements supported by a specified number
    // of bytes.
    CalculateLength(byteLength: uintptr): uintptr labels IfInvalid {
      const length = byteLength >>> this.sizeLog2;
      // TODO(v8:4153): use kArrayBufferMaxByteLength instead of kSmiMaxValue
      // to allow creation of huge TypedArrays.
      if (length > kSmiMaxValue) goto IfInvalid;
      return length;
    }

    // Determines if `bytes` (byte offset or length) cannot be evenly divided by
    // element size.
    IsUnaligned(bytes: uintptr): bool {
      // Exploits the fact the element size is a power of 2. Determining whether
      // there is remainder (not aligned) can be achieved efficiently with bit
      // masking. Shift is safe as sizeLog2 can be 3 at most (see
      // ElementsKindToShiftSize).
      return (bytes & ((1 << this.sizeLog2) - 1)) != 0;
    }

    sizeLog2: uintptr;
    kind: ElementsKind;
  }
  extern runtime TypedArraySortFast(Context, JSAny): JSTypedArray;
  extern runtime TypedArrayCopyElements(Context, JSTypedArray, Object, Number):
      void;
  extern macro TypedArrayBuiltinsAssembler::ValidateTypedArray(
      Context, JSAny, constexpr string): JSTypedArray;

  extern macro TypedArrayBuiltinsAssembler::CallCMemcpy(
      RawPtr, RawPtr, uintptr): void;
  extern macro TypedArrayBuiltinsAssembler::CallCMemmove(
      RawPtr, RawPtr, uintptr): void;
  extern macro TypedArrayBuiltinsAssembler::CallCMemset(
      RawPtr, intptr, uintptr): void;
  extern macro TypedArrayBuiltinsAssembler::GetBuffer(
      implicit context: Context)(JSTypedArray): JSArrayBuffer;
  extern macro TypedArrayBuiltinsAssembler::GetTypedArrayElementsInfo(
      JSTypedArray): TypedArrayElementsInfo;
  extern macro TypedArrayBuiltinsAssembler::GetTypedArrayElementsInfo(Map):
      TypedArrayElementsInfo;
  extern macro TypedArrayBuiltinsAssembler::IsBigInt64ElementsKind(
      ElementsKind): bool;
  extern macro LoadFixedTypedArrayElementAsTagged(
      RawPtr, uintptr, constexpr ElementsKind): Numeric;
  extern macro TypedArrayBuiltinsAssembler::StoreJSTypedArrayElementFromNumeric(
      Context, JSTypedArray, uintptr, Numeric, constexpr ElementsKind);
  extern macro TypedArrayBuiltinsAssembler::StoreJSTypedArrayElementFromTagged(
      Context, JSTypedArray, uintptr, JSAny,
      constexpr ElementsKind) labels IfDetached;

  type LoadFn = builtin(Context, JSTypedArray, uintptr) => Numeric;
  type StoreNumericFn = builtin(Context, JSTypedArray, uintptr, Numeric) =>
      JSAny;
  type StoreJSAnyFn = builtin(Context, JSTypedArray, uintptr, JSAny) => JSAny;

  struct LoadStoreFn {
    loadNumericFn: LoadFn;
    storeNumericFn: StoreNumericFn;
    storeJSAnyFn: StoreJSAnyFn;
  }

  macro GetLoadStoreFnForElementsKind(elementsKind: ElementsKind): LoadStoreFn {
    let loadNumericFn: LoadFn;
    let storeNumericFn: StoreNumericFn;
    let storeJSAnyFn: StoreJSAnyFn;

    if (IsElementsKindGreaterThan(elementsKind, UINT32_ELEMENTS)) {
      if (elementsKind == INT32_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Int32Elements>;
        storeNumericFn = StoreTypedElementNumeric<Int32Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Int32Elements>;
      } else if (elementsKind == FLOAT32_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Float32Elements>;
        storeNumericFn = StoreTypedElementNumeric<Float32Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Float32Elements>;
      } else if (elementsKind == FLOAT64_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Float64Elements>;
        storeNumericFn = StoreTypedElementNumeric<Float64Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Float64Elements>;
      } else if (elementsKind == UINT8_CLAMPED_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Uint8ClampedElements>;
        storeNumericFn = StoreTypedElementNumeric<Uint8ClampedElements>;
        storeJSAnyFn = StoreTypedElementJSAny<Uint8ClampedElements>;
      } else if (elementsKind == BIGUINT64_ELEMENTS) {
        loadNumericFn = LoadTypedElement<BigUint64Elements>;
        storeNumericFn = StoreTypedElementNumeric<BigUint64Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<BigUint64Elements>;
      } else if (elementsKind == BIGINT64_ELEMENTS) {
        loadNumericFn = LoadTypedElement<BigInt64Elements>;
        storeNumericFn = StoreTypedElementNumeric<BigInt64Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<BigInt64Elements>;
      } else {
        unreachable;
      }
    } else {
      if (elementsKind == UINT8_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Uint8Elements>;
        storeNumericFn = StoreTypedElementNumeric<Uint8Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Uint8Elements>;
      } else if (elementsKind == INT8_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Int8Elements>;
        storeNumericFn = StoreTypedElementNumeric<Int8Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Int8Elements>;
      } else if (elementsKind == UINT16_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Uint16Elements>;
        storeNumericFn = StoreTypedElementNumeric<Uint16Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Uint16Elements>;
      } else if (elementsKind == INT16_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Int16Elements>;
        storeNumericFn = StoreTypedElementNumeric<Int16Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Int16Elements>;
      } else if (elementsKind == UINT32_ELEMENTS) {
        loadNumericFn = LoadTypedElement<Uint32Elements>;
        storeNumericFn = StoreTypedElementNumeric<Uint32Elements>;
        storeJSAnyFn = StoreTypedElementJSAny<Uint32Elements>;
      } else {
        unreachable;
      }
    }
    return LoadStoreFn{loadNumericFn, storeNumericFn, storeJSAnyFn};
  }

  extern macro TypedArrayBuiltinsAssembler::SetJSTypedArrayOnHeapDataPtr(
      JSTypedArray, ByteArray, uintptr): void;
  extern macro TypedArrayBuiltinsAssembler::SetJSTypedArrayOffHeapDataPtr(
      JSTypedArray, RawPtr, uintptr): void;

  // AttachedJSTypedArray guards that the array's buffer is not detached.
  transient type AttachedJSTypedArray extends JSTypedArray;

  macro EnsureAttached(array: JSTypedArray): AttachedJSTypedArray
      labels Detached {
    if (IsDetachedBuffer(array.buffer)) goto Detached;
    return %RawDownCast<AttachedJSTypedArray>(array);
  }

  struct AttachedJSTypedArrayWitness {
    Get(): AttachedJSTypedArray {
      return this.unstable;
    }

    GetStable(): JSTypedArray {
      return this.stable;
    }

    Recheck() labels Detached {
      if (IsDetachedBuffer(this.stable.buffer)) goto Detached;
      this.unstable = %RawDownCast<AttachedJSTypedArray>(this.stable);
    }

    Load(implicit context: Context)(k: uintptr): JSAny {
      const lf: LoadFn = this.loadfn;
      return lf(context, this.unstable, k);
    }

    stable: JSTypedArray;
    unstable: AttachedJSTypedArray;
    loadfn: LoadFn;
  }

  macro NewAttachedJSTypedArrayWitness(array: AttachedJSTypedArray):
      AttachedJSTypedArrayWitness {
    const kind = array.elements_kind;
    const accessors: LoadStoreFn = GetLoadStoreFnForElementsKind(kind);
    return AttachedJSTypedArrayWitness{
      stable: array,
      unstable: array,
      loadfn: accessors.loadNumericFn
    };
  }

  macro KindForArrayType<T: type>(): constexpr ElementsKind;
  KindForArrayType<Uint8Elements>(): constexpr ElementsKind {
    return UINT8_ELEMENTS;
  }
  KindForArrayType<Int8Elements>(): constexpr ElementsKind {
    return INT8_ELEMENTS;
  }
  KindForArrayType<Uint16Elements>(): constexpr ElementsKind {
    return UINT16_ELEMENTS;
  }
  KindForArrayType<Int16Elements>(): constexpr ElementsKind {
    return INT16_ELEMENTS;
  }
  KindForArrayType<Uint32Elements>(): constexpr ElementsKind {
    return UINT32_ELEMENTS;
  }
  KindForArrayType<Int32Elements>(): constexpr ElementsKind {
    return INT32_ELEMENTS;
  }
  KindForArrayType<Float32Elements>(): constexpr ElementsKind {
    return FLOAT32_ELEMENTS;
  }
  KindForArrayType<Float64Elements>(): constexpr ElementsKind {
    return FLOAT64_ELEMENTS;
  }
  KindForArrayType<Uint8ClampedElements>(): constexpr ElementsKind {
    return UINT8_CLAMPED_ELEMENTS;
  }
  KindForArrayType<BigUint64Elements>(): constexpr ElementsKind {
    return BIGUINT64_ELEMENTS;
  }
  KindForArrayType<BigInt64Elements>(): constexpr ElementsKind {
    return BIGINT64_ELEMENTS;
  }

  builtin LoadTypedElement<T: type>(
      _context: Context, array: JSTypedArray, index: uintptr): Numeric {
    return LoadFixedTypedArrayElementAsTagged(
        array.data_ptr, index, KindForArrayType<T>());
  }

  builtin StoreTypedElementNumeric<T: type>(
      context: Context, typedArray: JSTypedArray, index: uintptr,
      value: Numeric): JSAny {
    StoreJSTypedArrayElementFromNumeric(
        context, typedArray, index, value, KindForArrayType<T>());
    return True;
  }

  // Returns True on sucess or False if the typedArrays was detached.
  builtin StoreTypedElementJSAny<T: type>(
      context: Context, typedArray: JSTypedArray, index: uintptr,
      value: JSAny): JSAny {
    StoreJSTypedArrayElementFromTagged(
        context, typedArray, index, value, KindForArrayType<T>()) otherwise
    return False;
    return True;
  }

  transitioning macro CallCompare(
      implicit context: Context, array: JSTypedArray,
      comparefn: Callable)(a: JSAny, b: JSAny): Number {
    // a. Let v be ? ToNumber(? Call(comparefn, undefined, x, y)).
    const v: Number =
        ToNumber_Inline(context, Call(context, comparefn, Undefined, a, b));

    // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
    if (IsDetachedBuffer(array.buffer)) {
      ThrowTypeError(kDetachedOperation, '%TypedArray%.prototype.sort');
    }

    // c. If v is NaN, return +0.
    if (NumberIsNaN(v)) return 0;

    // d. return v.
    return v;
  }

  // Merges two sorted runs [from, middle) and [middle, to)
  // from "source" into "target".
  transitioning macro
  TypedArrayMerge(
      implicit context: Context, array: JSTypedArray, comparefn: Callable)(
      source: FixedArray, from: uintptr, middle: uintptr, to: uintptr,
      target: FixedArray) {
    let left: uintptr = from;
    let right: uintptr = middle;

    for (let targetIndex: uintptr = from; targetIndex < to; ++targetIndex) {
      if (left < middle && right >= to) {
        // If the left run has elements, but the right does not, we take
        // from the left.
        target.objects[targetIndex] = source.objects[left++];
      } else if (left < middle) {
        // If both have elements, we need to compare.
        const leftElement = UnsafeCast<JSAny>(source.objects[left]);
        const rightElement = UnsafeCast<JSAny>(source.objects[right]);
        if (CallCompare(leftElement, rightElement) <= 0) {
          target.objects[targetIndex] = leftElement;
          left++;
        } else {
          target.objects[targetIndex] = rightElement;
          right++;
        }
      } else {
        // No elements on the left, but the right does, so we take
        // from the right.
        assert(left == middle);
        target.objects[targetIndex] = source.objects[right++];
      }
    }
  }

  transitioning builtin
  TypedArrayMergeSort(implicit context: Context)(
      source: FixedArray, from: uintptr, to: uintptr, target: FixedArray,
      array: JSTypedArray, comparefn: Callable): JSAny {
    assert(to - from > 1);
    const middle: uintptr = from + ((to - from) >>> 1);

    // On the next recursion step source becomes target and vice versa.
    // This saves the copy of the relevant range from the original
    // array into a work array on each recursion step.
    if (middle - from > 1) {
      TypedArrayMergeSort(target, from, middle, source, array, comparefn);
    }
    if (to - middle > 1) {
      TypedArrayMergeSort(target, middle, to, source, array, comparefn);
    }

    TypedArrayMerge(source, from, middle, to, target);

    return Undefined;
  }

  // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
  transitioning javascript builtin TypedArrayPrototypeSort(
      js-implicit context: Context,
      receiver: JSAny)(...arguments): JSTypedArray {
    // 1. If comparefn is not undefined and IsCallable(comparefn) is false,
    //    throw a TypeError exception.
    const comparefnObj: JSAny = arguments.length > 0 ? arguments[0] : Undefined;
    if (comparefnObj != Undefined && !TaggedIsCallable(comparefnObj)) {
      ThrowTypeError(kBadSortComparisonFunction, comparefnObj);
    }

    // 2. Let obj be the this value.
    const obj: JSAny = receiver;

    // 3. Let buffer be ? ValidateTypedArray(obj).
    //    ValidateTypedArray currently returns the array, not the ViewBuffer.
    const array: JSTypedArray =
        ValidateTypedArray(context, obj, '%TypedArray%.prototype.sort');

    // Default sorting is done in C++ using std::sort
    if (comparefnObj == Undefined) {
      return TypedArraySortFast(context, obj);
    }

    // 4. Let len be obj.[[ArrayLength]].
    const len: uintptr = array.length;

    // Arrays of length 1 or less are considered sorted.
    if (len < 2) return array;

    const comparefn: Callable =
        Cast<Callable>(comparefnObj) otherwise unreachable;
    const accessors: LoadStoreFn =
        GetLoadStoreFnForElementsKind(array.elements_kind);
    const loadfn = accessors.loadNumericFn;
    const storefn = accessors.storeNumericFn;

    // Prepare the two work arrays. All numbers are converted to tagged
    // objects first, and merge sorted between the two FixedArrays.
    // The result is then written back into the JSTypedArray.
    const work1: FixedArray = AllocateZeroedFixedArray(Convert<intptr>(len));
    const work2: FixedArray = AllocateZeroedFixedArray(Convert<intptr>(len));

    for (let i: uintptr = 0; i < len; ++i) {
      const element: JSAny = loadfn(context, array, i);
      work1.objects[i] = element;
      work2.objects[i] = element;
    }

    TypedArrayMergeSort(work2, 0, len, work1, array, comparefn);

    // work1 contains the sorted numbers. Write them back.
    for (let i: uintptr = 0; i < len; ++i)
      storefn(context, array, i, UnsafeCast<Numeric>(work1.objects[i]));

    return array;
  }

  type BuiltinsName extends int31 constexpr 'Builtins::Name';
  const kTypedArrayPrototypeValues: constexpr BuiltinsName
  generates 'Builtins::kTypedArrayPrototypeValues';

  extern builtin IterableToList(implicit context: Context)(JSAny, JSAny):
      JSArray;

  // %TypedArray%.from ( source [ , mapfn [ , thisArg ] ] )
  // https://tc39.github.io/ecma262/#sec-%typedarray%.from
  transitioning javascript builtin
  TypedArrayFrom(js-implicit context: Context, receiver: JSAny)(...arguments):
      JSTypedArray {
    const methodName: constexpr string = '%TypedArray%.from';
    try {
      const source: JSAny = arguments[0];

      // 1. Let C be the this value.
      // 2. If IsConstructor(C) is false, throw a TypeError exception.
      const constructor = Cast<Constructor>(receiver) otherwise NotConstructor;

      // 3. If mapfn is present and mapfn is not undefined, then
      //   a. If IsCallable(mapfn) is false, throw a TypeError exception.
      //   b. Let mapping be true.
      // 4. Else, let mapping be false.
      const mapping: bool = arguments.length > 1;
      const mapfnObj: JSAny = mapping ? arguments[1] : Undefined;
      if (mapping && !TaggedIsCallable(mapfnObj)) deferred {
          ThrowTypeError(kCalledNonCallable, mapfnObj);
        }

      // 5. If thisArg is present, let T be thisArg; else let T be undefined.
      const thisArg = arguments.length > 2 ? arguments[2] : Undefined;

      // We split up this builtin differently to the way it is written in the
      // spec. We already have great code in the elements accessor for copying
      // from a JSArray into a TypedArray, so we use that when possible. We only
      // avoid calling into the elements accessor when we have a mapping
      // function, because we can't handle that. Here, presence of a mapping
      // function is the slow path. We also combine the two different loops in
      // the specification (starting at 7.e and 13) because they are essentially
      // identical. We also save on code-size this way.

      let finalLength: uintptr;
      let finalSource: JSAny;

      try {
        // 6. Let usingIterator be ? GetMethod(source, @@iterator).
        // TODO(v8:8996): Use iterator::GetIteratorMethod() once it supports
        // labels.
        const usingIterator = GetMethod(source, IteratorSymbolConstant())
            otherwise IteratorIsUndefined, IteratorNotCallable;

        try {
          // TypedArrays have iterators, so normally we would go through the
          // IterableToList case below, which would convert the TypedArray to a
          // JSArray (boxing the values if they won't fit in a Smi).
          //
          // However, if we can guarantee that the source object has the
          // built-in iterator and that the %ArrayIteratorPrototype%.next method
          // has not been overridden, then we know the behavior of the iterator:
          // returning the values in the TypedArray sequentially from index 0 to
          // length-1.
          //
          // In this case, we can avoid creating the intermediate array and the
          // associated HeapNumbers, and use the fast path in
          // TypedArrayCopyElements which uses the same ordering as the default
          // iterator.
          //
          // Drop through to the default check_iterator behavior if any of these
          // checks fail.
          const sourceTypedArray =
              Cast<JSTypedArray>(source) otherwise UseIterator;
          const sourceBuffer = sourceTypedArray.buffer;
          if (IsDetachedBuffer(sourceBuffer)) goto UseIterator;

          // Check that the iterator function is exactly
          // Builtins::kTypedArrayPrototypeValues.
          const iteratorFn =
              Cast<JSFunction>(usingIterator) otherwise UseIterator;
          if (TaggedEqual(
                  iteratorFn.shared_function_info.function_data,
                  SmiConstant(kTypedArrayPrototypeValues)))
            goto UseIterator;

          // Check that the ArrayIterator prototype's "next" method hasn't been
          // overridden.
          if (IsArrayIteratorProtectorCellInvalid()) goto UseIterator;

          // Source is a TypedArray with unmodified iterator behavior. Use the
          // source object directly, taking advantage of the special-case code
          // in TypedArrayCopyElements
          finalLength = sourceTypedArray.length;
          finalSource = source;
        }
        label UseIterator {
          // 7. If usingIterator is not undefined, then
          //  a. Let values be ? IterableToList(source, usingIterator).
          //  b. Let len be the number of elements in values.
          const values: JSArray = IterableToList(source, usingIterator);

          finalLength = Convert<uintptr>(values.length);
          finalSource = values;
        }
      }
      label IteratorIsUndefined {
        // 8. NOTE: source is not an Iterable so assume it is already an
        // array-like object.

        // 9. Let arrayLike be ! ToObject(source).
        const arrayLike: JSReceiver = ToObject_Inline(context, source);

        // 10. Let len be ? ToLength(? Get(arrayLike, "length")).
        finalLength = Convert<uintptr>(GetLengthProperty(arrayLike));
        finalSource = arrayLike;
      }
      label IteratorNotCallable(_value: JSAny) deferred {
        ThrowTypeError(kIteratorSymbolNonCallable);
      }

      const finalLengthNum = Convert<Number>(finalLength);

      // 7c/11. Let targetObj be ? TypedArrayCreate(C, «len»).
      const targetObj =
          TypedArrayCreateByLength(constructor, finalLengthNum, methodName);

      if (!mapping) {
        // Fast path.
        if (finalLength != 0) {
          // Call runtime.
          TypedArrayCopyElements(
              context, targetObj, finalSource, finalLengthNum);
        }
        return targetObj;
      }
      // Slow path.

      const mapfn: Callable = Cast<Callable>(mapfnObj) otherwise unreachable;
      const accessors: LoadStoreFn =
          GetLoadStoreFnForElementsKind(targetObj.elements_kind);
      const storefn = accessors.storeJSAnyFn;

      // 7d-7e and 12-13.
      // 12. Let k be 0.
      // 13. Repeat, while k < len
      for (let k: uintptr = 0; k < finalLength; k++) {
        // 13a. Let Pk be ! ToString(k).
        const kNum = Convert<Number>(k);

        // 13b. Let kValue be ? Get(arrayLike, Pk).
        const kValue: JSAny = GetProperty(finalSource, kNum);

        let mappedValue: JSAny;
        // 13c. If mapping is true, then
        if (mapping) {
          // i. Let mappedValue be ? Call(mapfn, T, « kValue, k »).
          mappedValue = Call(context, mapfn, thisArg, kValue, kNum);
        } else {
          // 13d. Else, let mappedValue be kValue.
          mappedValue = kValue;
        }

        // 13e. Perform ? Set(targetObj, Pk, mappedValue, true).
        // SetProperty(targetObj, k, mappedValue);
        if (storefn(context, targetObj, k, mappedValue) != True) {
          // Buffer was detached during executing ToNumber/ToBigInt.
          goto OnDetached;
        }
        // 13f. Set k to k + 1. (done by the loop).
      }
      return targetObj;
    }
    label NotConstructor deferred {
      ThrowTypeError(kNotConstructor, receiver);
    }
    label OnDetached deferred {
      ThrowTypeError(kDetachedOperation, methodName);
    }
  }
}
