// Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace array {

const kJSIteratorResultkDoneOffset: constexpr int31
    generates 'JSIteratorResult::kDoneOffset';

extern enum ArrayFromAsyncLabels extends uint31
    constexpr 'ArrayBuiltins::ArrayFromAsyncLabels' {
  kStart,
  kGetIteratorStep,
  kCheckIteratorValueAndMapping,
  kIteratorMapping,
  kGetIteratorValueWithMapping,
  kAddIteratorValueToTheArray,
  kGetArrayLikeValue,
  kCheckArrayLikeValueAndMapping,
  kGetArrayLikeValueWithMapping,
  kAddArrayLikeValueToTheArray,
  kDoneAndResolvePromise,
  kCloseAsyncIterator,
  kRejectPromise
}

struct ArrayFromAsyncResumeState {
  step: ArrayFromAsyncLabels;
  awaitedValue: JSAny;
  len: Number;
  index: Smi;
}

type ArrayFromAsyncResolveContext extends FunctionContext;
extern enum ArrayFromAsyncResolveContextSlots extends intptr
    constexpr 'ArrayBuiltins::ArrayFromAsyncResolveContextSlots' {
  kArrayFromAsyncResolveResumeStateStepSlot:
      Slot<ArrayFromAsyncResolveContext, Smi>,
  kArrayFromAsyncResolveResumeStateAwaitedValueSlot:
      Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveResumeStateLenSlot:
      Slot<ArrayFromAsyncResolveContext, Number>,
  kArrayFromAsyncResolveResumeStateIndexSlot:
      Slot<ArrayFromAsyncResolveContext, Smi>,
  kArrayFromAsyncResolvePromiseSlot:
      Slot<ArrayFromAsyncResolveContext, JSPromise>,
  kArrayFromAsyncResolveResultArraySlot:
      Slot<ArrayFromAsyncResolveContext, JSReceiver>,
  kArrayFromAsyncResolveIteratorSlot:
      Slot<ArrayFromAsyncResolveContext, JSReceiver>,
  kArrayFromAsyncResolveNextMethodSlot:
      Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveArrayLikeSlot:
      Slot<ArrayFromAsyncResolveContext, JSReceiver>,
  kArrayFromAsyncResolveErrorSlot: Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveThisSlot: Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveItemsSlot: Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveMapfnSlot: Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveThisArgSlot: Slot<ArrayFromAsyncResolveContext, JSAny>,
  kArrayFromAsyncResolveLength
}

macro CreateArrayFromAsyncResolveContext(
    implicit context: Context)(resumeState: ArrayFromAsyncResumeState,
    promise: JSPromise, iterator: JSReceiver, next: JSAny,
    arrayLike: JSReceiver, arr: JSReceiver, error: JSAny, c: JSAny,
    items: JSAny, mapfn: JSAny, thisArg: JSAny,
    nativeContext: NativeContext): ArrayFromAsyncResolveContext {
  const resolveContext = %RawDownCast<ArrayFromAsyncResolveContext>(
      AllocateSyntheticFunctionContext(
          nativeContext,
          ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveLength));
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateStepSlot,
      SmiTag<ArrayFromAsyncLabels>(resumeState.step));
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateAwaitedValueSlot,
      resumeState.awaitedValue);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateLenSlot,
      resumeState.len);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateIndexSlot,
      resumeState.index);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolvePromiseSlot,
      promise);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveResultArraySlot,
      arr);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveIteratorSlot,
      iterator);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveNextMethodSlot,
      next);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveArrayLikeSlot,
      arrayLike);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveErrorSlot,
      error);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveThisSlot, c);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveItemsSlot,
      items);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveMapfnSlot,
      mapfn);
  InitContextSlot(
      resolveContext,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveThisArgSlot,
      thisArg);
  return resolveContext;
}

macro AssignIteratorRecordIntoContext(
    implicit context: Context)(
    iteratorRecord: iterator::IteratorRecord): void {
  const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);
  *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveIteratorSlot) =
      iteratorRecord.object;

  *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveNextMethodSlot) =
      iteratorRecord.next;
}

macro GetIteratorRecordFromContext(implicit context: Context)():
    iterator::IteratorRecord {
  const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);
  const iterator = *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveIteratorSlot);

  const nextMethod = *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveNextMethodSlot);

  return iterator::IteratorRecord{object: iterator, next: nextMethod};
}

transitioning macro CreateArrayFromIterableAsynchronously(
    context: ArrayFromAsyncResolveContext): JSAny {
  try {
    const fastIteratorResultMap = GetIteratorResultMap();

    const c = *ContextSlot(
        context,
        ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveThisSlot);

    const mapfn = *ContextSlot(
        context,
        ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveMapfnSlot);

    const thisArg = *ContextSlot(
        context,
        ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveThisArgSlot);

    const arr = *ContextSlot(
        context,
        ArrayFromAsyncResolveContextSlots::
            kArrayFromAsyncResolveResultArraySlot);

    let resumeState = ArrayFromAsyncResumeState{
      step: SmiUntag<ArrayFromAsyncLabels>(
          %RawDownCast<SmiTagged<ArrayFromAsyncLabels>>(*ContextSlot(
              context,
              ArrayFromAsyncResolveContextSlots::
                  kArrayFromAsyncResolveResumeStateStepSlot))),
      awaitedValue: *ContextSlot(
          context,
          ArrayFromAsyncResolveContextSlots::
              kArrayFromAsyncResolveResumeStateAwaitedValueSlot),
      len: *ContextSlot(
          context,
          ArrayFromAsyncResolveContextSlots::
              kArrayFromAsyncResolveResumeStateLenSlot),
      index: *ContextSlot(
          context,
          ArrayFromAsyncResolveContextSlots::
              kArrayFromAsyncResolveResumeStateIndexSlot)
    };

    let mappedValue: JSAny = Undefined;
    let nextValue: JSAny = Undefined;

    // TODO(v8:14290): Replace `if/else` with `switch/case` when the support
    // for `switch` is added.

    while (true) {
      if (resumeState.step == ArrayFromAsyncLabels::kStart) {
        const items = *ContextSlot(
            context,
            ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveItemsSlot);

        if (mapfn != Undefined) {
          // i. If IsCallable(mapfn) is false, throw a TypeError exception.
          if (!Is<Callable>(mapfn)) deferred {
              ThrowTypeError(MessageTemplate::kCalledNonCallable, mapfn);
            }
        }

        let usingAsyncIterator: JSAny = Undefined;
        let usingSyncIterator: JSAny = Undefined;
        try {
          Print('Inside try -------');
          //  c. Let usingAsyncIterator be ?
          //  GetMethod(asyncItems, @@asyncIterator).
          usingAsyncIterator = GetMethod(items, AsyncIteratorSymbolConstant())
              otherwise AsyncIteratorIsUndefined, AsyncIteratorNotCallable;
        } label AsyncIteratorIsUndefined {
          Print('Inside AsyncIteratorIsUndefined -------');
          //  d. If usingAsyncIterator is undefined, then
          //    i. Let usingSyncIterator be ?
          //    GetMethod(asyncItems, @@iterator).

          usingSyncIterator = GetMethod(items, IteratorSymbolConstant())
              otherwise SyncIteratorIsUndefined, SyncIteratorNotCallable;
        } label SyncIteratorIsUndefined deferred {
          Print('Inside SyncIteratorIsUndefined -------');
          //  i. Else, (iteratorRecord is undefined)
          //   i. NOTE: asyncItems is neither an AsyncIterable nor an
          //   Iterable so assume it is an array-like object.
          //   ii. Let arrayLike be ! ToObject(asyncItems).
          const arrayLike = ToObject_Inline(context, items);
          *ContextSlot(
              context,
              ArrayFromAsyncResolveContextSlots::
                  kArrayFromAsyncResolveArrayLikeSlot) = arrayLike;

          //   iii. Let len be ? LengthOfArrayLike(arrayLike).
          resumeState.len = GetLengthProperty(arrayLike);
          *ContextSlot(
              context,
              ArrayFromAsyncResolveContextSlots::
                  kArrayFromAsyncResolveResumeStateLenSlot) = resumeState.len;

          // TODO(v8:13321): Allocate an array with PACKED elements kind for
          // fast-path rather than calling the constructor which creates an
          // array with HOLEY kind.
          let arr: JSReceiver;
          typeswitch (c) {
            case (c: Constructor): {
              //   iv. If IsConstructor(C) is
              //   true, then
              //     1. Let A be ? Construct(C, « 𝔽(len) »).
              arr = Construct(c, resumeState.len);
            }
            case (JSAny): {
              //   v. Else,
              //     1. Let A be ? ArrayCreate(len).
              arr = ArrayCreate(resumeState.len);
            }
          }

          *ContextSlot(
              context,
              ArrayFromAsyncResolveContextSlots::
                  kArrayFromAsyncResolveResultArraySlot) = arr;

          //   vi. Let k be 0.
          resumeState.index = 0;

          resumeState.step = ArrayFromAsyncLabels::kGetArrayLikeValue;
        } label SyncIteratorNotCallable(_value: JSAny)
        deferred {
          Print('Inside SyncIteratorNotCallable -------');
          ThrowTypeError(
              MessageTemplate::kFirstArgumentIteratorSymbolNonCallable,
              'Array.fromAsync');
        } label AsyncIteratorNotCallable(_value: JSAny)
        deferred {
          Print('Inside AsyncIteratorNotCallable -------');
          ThrowTypeError(
              MessageTemplate::kFirstArgumentAsyncIteratorSymbolNonCallable,
              'Array.fromAsync');
        }

        if (resumeState.step != ArrayFromAsyncLabels::kGetArrayLikeValue) {
          //  e. Let iteratorRecord be undefined.
          //  f. If usingAsyncIterator is not undefined, then
          //     i. Set iteratorRecord to ? GetIterator(asyncItems, async,
          // usingAsyncIterator).
          //  g. Else if usingSyncIterator is not undefined, then
          //     i. Set iteratorRecord to ?
          // CreateAsyncFromSyncIterator(GetIterator(asyncItems, sync,
          // usingSyncIterator)).

          const iteratorRecord = (usingAsyncIterator != Undefined) ?
              iterator::GetIterator(items, usingAsyncIterator) :
              iterator::GetIteratorRecordAfterCreateAsyncFromSyncIterator(
                  iterator::GetIterator(items, usingSyncIterator));

          AssignIteratorRecordIntoContext(iteratorRecord);

          //  h. If iteratorRecord is not undefined, then
          //     i. If IsConstructor(C) is true, then
          //       1. Let A be ? Construct(C).
          //     ii. Else,
          //       1. Let A be ! ArrayCreate(0).

          let arr: JSReceiver;
          typeswitch (c) {
            case (c: Constructor): {
              //  e. If IsConstructor(C) is true, then
              //    i. Let A be ? Construct(C).
              arr = Construct(c);
            }
            case (JSAny): {
              //  f. Else,
              //    i. Let A be ! ArrayCreate(0).
              arr = ArrayCreate(0);
            }
          }

          *ContextSlot(
              context,
              ArrayFromAsyncResolveContextSlots::
                  kArrayFromAsyncResolveResultArraySlot) = arr;

          resumeState.step = ArrayFromAsyncLabels::kGetIteratorStep;
        }
      } else if (resumeState.step == ArrayFromAsyncLabels::kGetIteratorStep) {
        const iteratorRecord = GetIteratorRecordFromContext();
        let next: JSAny;
        //    3. Let nextResult be ? Call(iteratorRecord.[[NextMethod]],
        //    iteratorRecord.[[Iterator]]).
        //    4. Set nextResult to ? Await(nextResult).
        next = Call(context, iteratorRecord.next, iteratorRecord.object);

        resumeState.step = ArrayFromAsyncLabels::kCheckIteratorValueAndMapping;
        return ArrayFromAsyncAwaitPoint(resumeState.step, next);
      } else if (
          resumeState.step ==
          ArrayFromAsyncLabels::kCheckIteratorValueAndMapping) {
        //    5. If nextResult is not an Object, throw a TypeError exception.
        const nextJSReceiver = Cast<JSReceiver>(resumeState.awaitedValue)
            otherwise ThrowTypeError(
            MessageTemplate::kIteratorResultNotAnObject, 'Array.fromAsync');

        try {
          //    6. Let done be ? IteratorComplete(nextResult).
          iterator::IteratorComplete(nextJSReceiver, fastIteratorResultMap)
              otherwise Done;

          //    8. Let nextValue be ? IteratorValue(nextResult).
          nextValue =
              iterator::IteratorValue(nextJSReceiver, fastIteratorResultMap);
          let mapping: bool;
          //  a. If mapfn is undefined, let mapping be false.
          if (mapfn == Undefined) {
            mapping = false;
          } else {
            //  b. Else,
            //    i. If IsCallable(mapfn) is false, throw a TypeError exception.
            if (!Is<Callable>(mapfn)) deferred {
                ThrowTypeError(MessageTemplate::kCalledNonCallable, mapfn);
              }
            //    ii. Let mapping be true.
            mapping = true;
          }

          //    9. If mapping is true, then
          if (mapping) {
            resumeState.step = ArrayFromAsyncLabels::kIteratorMapping;
          } else {
            //    10. Else, let mappedValue be nextValue.
            mappedValue = nextValue;
            resumeState.step =
                ArrayFromAsyncLabels::kAddIteratorValueToTheArray;
          }
        } label Done {
          //    7. If done is true,
          //       a. Perform ? Set(A, "length", 𝔽(k), true).
          //       b. Return Completion Record { [[Type]]: return, [[Value]]: A,
          //       [[Target]]: empty }.
          resumeState.step = ArrayFromAsyncLabels::kDoneAndResolvePromise;
        }
      } else if (resumeState.step == ArrayFromAsyncLabels::kIteratorMapping) {
        //      a. Let mappedValue be Call(mapfn, thisArg, « nextValue, 𝔽(k)
        //      »).
        //      b. IfAbruptCloseAsyncIterator(mappedValue,
        //      iteratorRecord).
        const mapResult = Call(
            context, UnsafeCast<Callable>(mapfn), thisArg, nextValue,
            resumeState.index);

        //      c. Set mappedValue to Await(mappedValue).
        //      d. IfAbruptCloseAsyncIterator(mappedValue, iteratorRecord).
        resumeState.step = ArrayFromAsyncLabels::kGetIteratorValueWithMapping;
        return ArrayFromAsyncAwaitPoint(resumeState.step, mapResult);
      } else if (
          resumeState.step ==
          ArrayFromAsyncLabels::kGetIteratorValueWithMapping) {
        mappedValue = resumeState.awaitedValue;
        resumeState.step = ArrayFromAsyncLabels::kAddIteratorValueToTheArray;
      } else if (
          resumeState.step ==
          ArrayFromAsyncLabels::kAddIteratorValueToTheArray) {
        //    11. Let defineStatus be CreateDataPropertyOrThrow(A, Pk,
        //    mappedValue).
        //    12. If defineStatus is an abrupt completion, return ?
        //    AsyncIteratorClose(iteratorRecord, defineStatus).
        FastCreateDataProperty(arr, resumeState.index, mappedValue);

        // 13. Set k to k + 1.
        resumeState.index++;

        *ContextSlot(
            context,
            ArrayFromAsyncResolveContextSlots::
                kArrayFromAsyncResolveResumeStateIndexSlot) = resumeState.index;

        resumeState.step = ArrayFromAsyncLabels::kGetIteratorStep;
      } else if (resumeState.step == ArrayFromAsyncLabels::kGetArrayLikeValue) {
        Print('Inside kGetArrayLikeValue 1 -------');
        // Print(resumeState.index);
        // Print(resumeState.len);
        const arrayLike = *ContextSlot(
            context,
            ArrayFromAsyncResolveContextSlots::
                kArrayFromAsyncResolveArrayLikeSlot);

        //   vii. Repeat, while k < len,
        //     1. Let Pk be ! ToString(𝔽(k)).
        if (resumeState.index < resumeState.len) {
          //     2. Let kValue be ? Get(arrayLike, Pk).
          const kValue = GetProperty(arrayLike, resumeState.index);
          Print('Inside kGetArrayLikeValue 2 -------');
          resumeState.step =
              ArrayFromAsyncLabels::kCheckArrayLikeValueAndMapping;

          //     3. Set kValue to ? Await(kValue).
          return ArrayFromAsyncAwaitPoint(resumeState.step, kValue);
        }
        resumeState.step = ArrayFromAsyncLabels::kDoneAndResolvePromise;
      } else if (
          resumeState.step ==
          ArrayFromAsyncLabels::kCheckArrayLikeValueAndMapping) {
        Print('Inside kCheckArrayLikeValueAndMapping -------');
        if (resumeState.index == resumeState.len) {
          resumeState.step = ArrayFromAsyncLabels::kDoneAndResolvePromise;
        } else {
          let mapping: bool;
          //  a. If mapfn is undefined, let mapping be false.
          if (mapfn == Undefined) {
            mapping = false;
          } else {
            //  b. Else,
            //    i. If IsCallable(mapfn) is false, throw a TypeError exception.
            if (!Is<Callable>(mapfn)) deferred {
                ThrowTypeError(MessageTemplate::kCalledNonCallable, mapfn);
              }
            //    ii. Let mapping be true.
            mapping = true;
          }

          //    4. If mapping is true, then
          if (mapping) {
            resumeState.step =
                ArrayFromAsyncLabels::kGetArrayLikeValueWithMapping;
          } else {
            resumeState.step =
                ArrayFromAsyncLabels::kAddArrayLikeValueToTheArray;
          }
        }
      } else if (
          resumeState.step ==
          ArrayFromAsyncLabels::kGetArrayLikeValueWithMapping) {
        //      a. Let mappedValue be ? Call(mapfn, thisArg, « kValue, 𝔽(k)
        //      »).
        //      b. Set mappedValue to ? Await(mappedValue).
        const mapResult = Call(
            context, UnsafeCast<Callable>(mapfn), thisArg,
            resumeState.awaitedValue, resumeState.index);
        resumeState.step = ArrayFromAsyncLabels::kAddArrayLikeValueToTheArray;
        return ArrayFromAsyncAwaitPoint(resumeState.step, mapResult);
      } else if (
          resumeState.step ==
          ArrayFromAsyncLabels::kAddArrayLikeValueToTheArray) {
        Print('Inside kAddArrayLikeValueToTheArray -------');
        // Print(arr);
        //    5. Else, let mappedValue be kValue.
        //    6. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).
        mappedValue = resumeState.awaitedValue;
        FastCreateDataProperty(arr, resumeState.index, mappedValue);

        resumeState.index++;

        *ContextSlot(
            context,
            ArrayFromAsyncResolveContextSlots::
                kArrayFromAsyncResolveResumeStateIndexSlot) = resumeState.index;

        resumeState.step = ArrayFromAsyncLabels::kGetArrayLikeValue;
      } else if (
          resumeState.step == ArrayFromAsyncLabels::kDoneAndResolvePromise) {
        const promise = *ContextSlot(
            context,
            ArrayFromAsyncResolveContextSlots::
                kArrayFromAsyncResolvePromiseSlot);

        promise::ResolvePromise(promise, arr);
        return Undefined;
      } else if (
          resumeState.step == ArrayFromAsyncLabels::kCloseAsyncIterator) {
        Print('Inside kCloseAsyncIterator -------');
        resumeState.step = ArrayFromAsyncLabels::kRejectPromise;

        const iteratorRecord = GetIteratorRecordFromContext();
        try {
          ArrayFromAsyncAsyncIteratorCloseOnException(iteratorRecord)
              otherwise RejectPromise;
          return Undefined;
        } label RejectPromise {
          Print('Inside kCloseAsyncIterator RejectPromise label-------');
          // Do nothing so the codeflow continues to the kRejectPromise label.
        }
      } else if (resumeState.step == ArrayFromAsyncLabels::kRejectPromise) {
        Print('Inside RejectArrayFromAsyncPromise -------');
        return RejectArrayFromAsyncPromise();
      }
    }
  } catch (e, _message) {
    Print('Inside Catch of body -------');
    *ContextSlot(
        context,
        ArrayFromAsyncResolveContextSlots::
            kArrayFromAsyncResolveResumeStateStepSlot) =
        SmiTag<ArrayFromAsyncLabels>(ArrayFromAsyncLabels::kRejectPromise);
    *ContextSlot(
        context,
        ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveErrorSlot) = e;

    const iteratorRecord = GetIteratorRecordFromContext();
    try {
      ArrayFromAsyncAsyncIteratorCloseOnException(iteratorRecord)
          otherwise RejectPromise;
    } label RejectPromise {
      return RejectArrayFromAsyncPromise();
    }
  }
  return Undefined;
}

transitioning macro ArrayFromAsyncAwaitPoint(
    implicit context: Context)(step: ArrayFromAsyncLabels,
    value: JSAny): JSAny {
  Print('Inside ArrayFromAsyncAwaitPoint 1 ----------');
  const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);
  *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateStepSlot) =
      SmiTag<ArrayFromAsyncLabels>(step);

  const nativeContext = LoadNativeContext(context);
  const promiseFun = *NativeContextSlot(
      nativeContext, ContextSlot::PROMISE_FUNCTION_INDEX);

  // TODO(v8:13321): Add a fast path for values that are already
  // built-in promises.
  const resultPromise = promise::PromiseResolve(promiseFun, value);
  Print('Inside ArrayFromAsyncAwaitPoint 2 ----------');
  const map = *NativeContextSlot(
      nativeContext, ContextSlot::STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX);
  const resolve = promise::AllocateFunctionWithMapAndContext(
      map, ArrayFromAsyncResolveSharedFunConstant(), context);
  const reject = promise::AllocateFunctionWithMapAndContext(
      map, ArrayFromAsyncRejectSharedFunConstant(), context);

  promise::PerformPromiseThenImpl(
      UnsafeCast<JSPromise>(resultPromise), resolve, reject, Undefined);
  Print('Inside ArrayFromAsyncAwaitPoint 3 ----------');
  return Undefined;
}

// `ArrayFromAsyncFulfilled` is the callback function for the fulfilled case of
// the promise in `then` handler.
transitioning javascript builtin ArrayFromAsyncFulfilled(
    js-implicit context: Context, receiver: JSAny, target: JSFunction)(
    result: JSAny): JSAny {
  Print('Inside ArrayFromAsyncFulfilled----------');
  const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);
  *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateAwaitedValueSlot) = result;

  return CreateArrayFromIterableAsynchronously(context);
}

// `ArrayFromAsyncRejected` is the callback function for the rejected case of
// the promise in `then` handler.
transitioning javascript builtin ArrayFromAsyncRejected(
    js-implicit context: Context, receiver: JSAny, target: JSFunction)(
    result: JSAny): JSAny {
  Print('Inside ArrayFromAsyncRejected----------');
  const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);

  *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::
          kArrayFromAsyncResolveResumeStateStepSlot) =
      SmiTag<ArrayFromAsyncLabels>(ArrayFromAsyncLabels::kCloseAsyncIterator);
  *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveErrorSlot) =
      result;

  return CreateArrayFromIterableAsynchronously(context);
}

// This macro reject the promise if any exception occurs in the execution of
// the code.
transitioning macro RejectArrayFromAsyncPromise(
    implicit context: Context)(): JSAny {
  Print('Inside RejectArrayFromAsyncPromise----------');
  const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);
  const error = *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveErrorSlot);
  const promise = *ContextSlot(
      context,
      ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolvePromiseSlot);

  return promise::RejectPromise(promise, error, False);
}

// This is the specialized implementation of `IfAbruptCloseAsyncIterator` for
// Array.FromAsync
// https://tc39.es/proposal-array-from-async/#sec-ifabruptcloseasynciterator
transitioning macro ArrayFromAsyncAsyncIteratorCloseOnException(
    implicit context: Context)(
    iterator: iterator::IteratorRecord): void labels RejectPromise {
  try {
    Print('Inside ArrayFromAsyncAsyncIteratorCloseOnException 1 ----------');
    const context = %RawDownCast<ArrayFromAsyncResolveContext>(context);
    // 3. Let innerResult be GetMethod(iterator, "return").
    const method = GetProperty(iterator.object, kReturnString);
    Print('Inside ArrayFromAsyncAsyncIteratorCloseOnException 2 ----------');
    // 4. If innerResult.[[Type]] is normal, then
    //   a. Let return be innerResult.[[Value]].
    //   b. If return is undefined, return Completion(completion).
    if (method == Undefined || method == Null) {
      Print('Inside ArrayFromAsyncAsyncIteratorCloseOnException 3 ----------');
      goto RejectPromise;
    }

    //   c. Set innerResult to Call(return, iterator).
    // If an exception occurs, the original exception remains bound
    const innerResult = Call(context, method, iterator.object);
    Print('Inside ArrayFromAsyncAsyncIteratorCloseOnException 4 ----------');
    //   d. If innerResult.[[Type]] is normal, set innerResult to
    //   Completion(Await(innerResult.[[Value]])).
    const step = ArrayFromAsyncLabels::kRejectPromise;
    Print('Inside ArrayFromAsyncAsyncIteratorCloseOnException 5 ----------');
    ArrayFromAsyncAwaitPoint(step, innerResult);
  } catch (_e, _message) {
    // Swallow the exception.
  }

  // (5. If completion.[[Type]] is throw) return Completion(completion).
}

// https://tc39.es/proposal-array-from-async/#sec-array.fromAsync
// Array.fromAsync ( asyncItems [ , mapfn [ , thisArg ] ] )
// Since we do not have support for `await` in torque, we handled
// asynchronous execution flow manually in torque. More information
// is available in go/array-from-async-implementation.
transitioning javascript builtin ArrayFromAsync(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): JSAny {
  // 1. Let C be the this value.
  const c = HasBuiltinSubclassingFlag() ? receiver : GetArrayFunction();

  const items = arguments[0];
  const mapfn = arguments[1];
  const thisArg = arguments[2];

  // 2. Let promiseCapability be ? NewPromiseCapability(C).
  const promise = promise::NewJSPromise();

  // 3. Let fromAsyncClosure be a new Abstract Closure with no parameters that
  // captures C, mapfn, and thisArg and performs the following steps when
  // called:

  let resumeState = ArrayFromAsyncResumeState{
    step: ArrayFromAsyncLabels::kStart,
    awaitedValue: Undefined,
    len: 0,
    index: 0
  };

  const arr: JSReceiver = ArrayCreate(0);

  const resolveContext = CreateArrayFromAsyncResolveContext(
      resumeState, promise, arr, Undefined, arr, arr, Undefined, c, items,
      mapfn, thisArg, context);
  try {
    CreateArrayFromIterableAsynchronously(resolveContext);
  } catch (e, _message) {
    Print('Inside Catch of outer -------');
    *ContextSlot(
        resolveContext,
        ArrayFromAsyncResolveContextSlots::
            kArrayFromAsyncResolveResumeStateStepSlot) =
        SmiTag<ArrayFromAsyncLabels>(ArrayFromAsyncLabels::kCloseAsyncIterator);
    *ContextSlot(
        resolveContext,
        ArrayFromAsyncResolveContextSlots::kArrayFromAsyncResolveErrorSlot) = e;
    CreateArrayFromIterableAsynchronously(resolveContext);
  }
  return promise;
}

extern macro ArrayFromAsyncResolveSharedFunConstant(): SharedFunctionInfo;
extern macro ArrayFromAsyncRejectSharedFunConstant(): SharedFunctionInfo;
}
