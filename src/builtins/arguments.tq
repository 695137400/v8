// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

@export
struct Arguments {
  const frame: FrameWithArguments;
  const base: RawPtr;
  const length: intptr;
}

extern operator '[]' macro GetArgumentValue(Arguments, intptr): JSAny;

extern macro GetFrameArguments(FrameWithArguments, intptr): Arguments;

namespace arguments {

  const kParameterMapStart: constexpr int31
  generates 'SloppyArgumentsElements::kParameterMapStart';

  struct ArgumentsIterator {
    Next(): Object labels NoMore {
      if (this.current == this.arguments.length) goto NoMore;
      return this.arguments[this.current++];
    }
    const arguments: Arguments;
    current: intptr;
  }

  struct ParameterMapIterator {
    Next(): Object labels NoMore {
      const currentMapSlotCopy = this.currentMapSlot++;
      if (currentMapSlotCopy > 1) {
        if (this.currentIndex == this.endInterationIndex) goto NoMore;
        this.currentIndex--;
        return this.currentIndex;
      } else if (currentMapSlotCopy == 0) {
        return this.context;
      } else {
        assert(currentMapSlotCopy == 1);
        return this.elements;
      }
    }
    const context: Context;
    const elements: FixedArray;
    currentIndex: Smi;
    const endInterationIndex: Smi;
    currentMapSlot: Smi;
  }

  macro NewParameterMapIterator(
      context: Context, elements: FixedArray, formalParameterCount: intptr,
      mappedCount: intptr): ParameterMapIterator {
    const scopeInfoFlags =
        LoadAndUntagObjectField(context.scope_info, kScopeInfoFlagsOffset);
    const contextExtentionSize =
        DecodeScopeInfoHasContextExtension(scopeInfoFlags);
    const contextHeaderSize = MIN_CONTEXT_SLOTS + contextExtentionSize;
    const afterLastContextIndex = contextHeaderSize + formalParameterCount;
    const firstContextIndex = afterLastContextIndex - mappedCount;
    return ParameterMapIterator{
      context,
      elements,
      currentIndex: Convert<Smi>(afterLastContextIndex),
      endInterationIndex: Convert<Smi>(firstContextIndex),
      currentMapSlot: 0
    };
  }

  struct ParameterValueIterator {
    Next(): Object labels NoMore() {
      if (this.mapped_count != 0) {
        this.mapped_count--;
        return TheHole;
      }
      if (this.current == this.arguments.length) goto NoMore;
      return this.arguments[this.current++];
    }
    mapped_count: intptr;
    const arguments: Arguments;
    current: intptr;
  }

  macro NewParameterValueIterator(mappedCount: intptr, arguments: Arguments):
      ParameterValueIterator {
    return ParameterValueIterator{
      mapped_count: mappedCount,
      arguments,
      current: mappedCount
    };
  }

  struct ArgumentsInfo {
    const frame: FrameWithArguments;
    const argument_count: bint;
    const formal_parameter_count: bint;
  }

  macro NewAllArguments(implicit context: Context)(
      frame: FrameWithArguments, argumentCount: intptr): JSArray {
    const map = GetFastPackedElementsJSArrayMap();
    if (argumentCount == 0) {
      // Handle empty arrays separately so that allocation folding and
      // write barrier elimination can fully apply to the non-empty case
      return NewJSArray(map, kEmptyFixedArray);
    }
    const arguments = GetFrameArguments(frame, argumentCount);
    const i = ArgumentsIterator{arguments, current: 0};
    const length = Convert<Smi>(argumentCount);
    const elements = new FixedArray{map: kFixedArrayMap, length, objects: ...i};
    return NewJSArray(map, elements);
  }

  macro NewRestArguments(implicit context: Context)(info: ArgumentsInfo):
      JSArray {
    const argumentCount = Convert<intptr>(info.argument_count);
    const formalParameterCount = Convert<intptr>(info.formal_parameter_count);
    const map = GetFastPackedElementsJSArrayMap();
    if (formalParameterCount >= argumentCount) {
      // Handle empty arrays separately so that allocation folding and
      // write barrier elimination can fully apply to the non-empty case
      return NewJSArray(map, kEmptyFixedArray);
    }
    const arguments = GetFrameArguments(info.frame, argumentCount);
    const i = ArgumentsIterator{arguments, current: formalParameterCount};
    const length = Convert<Smi>(argumentCount - formalParameterCount);
    const elements = new FixedArray{map: kFixedArrayMap, length, objects: ...i};
    return NewJSArray(map, elements);
  }

  macro NewStrictArguments(implicit context: Context)(info: ArgumentsInfo):
      JSStrictArgumentsObject {
    const argumentCount = Convert<intptr>(info.argument_count);
    if (argumentCount == 0) {
      // Handle empty arrays separately so that allocation folding and
      // write barrier elimination can fully apply to the non-empty case
      return NewJSStrictArgumentsObject(kEmptyFixedArray);
    }
    const arguments = GetFrameArguments(info.frame, argumentCount);
    const i = ArgumentsIterator{arguments, current: 0};
    const length = Convert<Smi>(argumentCount);
    const elements = new FixedArray{map: kFixedArrayMap, length, objects: ...i};
    return NewJSStrictArgumentsObject(elements);
  }

  macro NewSloppyArguments(implicit context: Context)(
      info: ArgumentsInfo, callee: JSFunction): JSSloppyArgumentsObject {
    const argumentCount = Convert<intptr>(info.argument_count);
    if (argumentCount == 0) {
      // Handle empty arrays separately so that allocation folding and
      // write barrier elimination can fully apply to the non-empty case
      return NewJSSloppyArgumentsObject(kEmptyFixedArray, callee);
    }
    const arguments = GetFrameArguments(info.frame, argumentCount);
    const formalParameterCount = Convert<intptr>(info.formal_parameter_count);
    const length = Convert<Smi>(argumentCount);
    if (formalParameterCount == 0) {
      const i = ArgumentsIterator{arguments, current: 0};
      const elements = new
      FixedArray{map: kFixedArrayMap, length, objects: ...i};
      return NewJSSloppyArgumentsObject(elements, callee);
    }
    const mappedCount = IntPtrMin(formalParameterCount, argumentCount);
    const i = NewParameterValueIterator(mappedCount, arguments);
    const parameterValues = new
    FixedArray{map: kFixedArrayMap, length, objects: ...i};
    // Copy the parameter slots and the holes in the arguments.
    // We need to fill in mapped_count slots. They index the context,
    // where parameters are stored in reverse order, at
    //   context_header_size .. context_header_size+argument_count-1
    // The mapped parameter thus need to get indices
    //   context_header_size+parameter_count-1 ..
    //       context_header_size+argument_count-mapped_count
    // We loop from right to left.
    let paramIter = NewParameterMapIterator(
        context, parameterValues, formalParameterCount, mappedCount);
    const elementsLength =
        Convert<Smi>(mappedCount + kSloppyArgumentsParameterMapStart);
    const map = kSloppyArgumentsElementsMap;
    const elements = new
    FixedArray{map, length: elementsLength, objects: ...paramIter};
    return NewJSFastAliasedArgumentsObject(elements, length, callee);
  }

  // Calculates and returns the frame pointer, argument count and formal
  // parameter count to be used to access a function's parameters, taking
  // argument adapter frames into account.
  //
  // TODO(danno):
  // This macro is should only be used in builtins that can be called from
  // interpreted or JITted code, not from CSA/Torque builtins (the number of
  // returned formal parameters would be wrong).
  // It is difficult to actually check/assert this, since interpreted or JITted
  // frames are StandardFrames, but so are hand-written builtins. Doing that
  // more refined check would be prohibitively expensive.
  macro GetArgumentsInfo(implicit context: Context)(): ArgumentsInfo {
    const frame =
        Cast<StandardFrame>(LoadParentFramePointer()) otherwise unreachable;
    const f: JSFunction = frame.function;

    const shared: SharedFunctionInfo = f.shared_function_info;
    const formalParameterCount: bint =
        Convert<bint>(Convert<int32>(shared.formal_parameter_count));
    const argumentCount: bint = formalParameterCount;

    const adaptor = Cast<ArgumentsAdaptorFrame>(frame.caller)
        otherwise return ArgumentsInfo{
      frame,
      argument_count: argumentCount,
      formal_parameter_count: formalParameterCount
    };

    return ArgumentsInfo{
      frame: adaptor,
      argument_count: Convert<bint>(adaptor.length),
      formal_parameter_count: formalParameterCount
    };
  }

  @export
  macro EmitFastNewAllArguments(implicit context: Context)(
      frame: FrameWithArguments, argc: intptr): JSArray {
    return NewAllArguments(frame, argc);
  }

  @export
  macro EmitFastNewRestArguments(implicit context: Context)(_f: JSFunction):
      JSArray {
    const info = GetArgumentsInfo();
    return NewRestArguments(info);
  }

  @export
  macro EmitFastNewStrictArguments(implicit context: Context)(_f: JSFunction):
      JSStrictArgumentsObject {
    const info = GetArgumentsInfo();
    return NewStrictArguments(info);
  }

  @export
  macro EmitFastNewSloppyArguments(implicit context: Context)(f: JSFunction):
      JSSloppyArgumentsObject {
    const info = GetArgumentsInfo();
    return NewSloppyArguments(info, f);
  }
}
