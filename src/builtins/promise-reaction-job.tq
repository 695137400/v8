// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-promise-gen.h'

namespace runtime {
  extern transitioning runtime
  ReportMessage(implicit context: Context)(JSAny): JSAny;
}

namespace promise {

  // https://tc39.es/ecma262/#sec-promisereactionjob
  transitioning
  macro PromiseReactionJob(
      context: Context, argument: JSAny, handler: Callable|Undefined,
      promiseOrCapability: JSPromise|PromiseCapability|Undefined,
      reactionType: constexpr PromiseReactionType): JSAny {
    let handlerResult = argument;
    try {
      if (handler == Undefined) {
        if constexpr (reactionType == kPromiseReactionFulfill) {
          goto Fulfill;
        } else {
          StaticAssert(reactionType == kPromiseReactionReject);
          goto Reject;
        }
      } else {
        try {
          handlerResult =
              Call(context, UnsafeCast<Callable>(handler), Undefined, argument);
          if (promiseOrCapability == Undefined) {
            // There's no [[Capability]] for this promise reaction job, which
            // means that this is a specification-internal operation (aka
            // await) where the result does not matter (see the specification
            // change in https://github.com/tc39/ecma262/pull/1146 for
            // details).
            return Undefined;
          } else {
            goto Fulfill;
          }
        } catch (e) {
          handlerResult = e;
          goto Reject;
        }
      }
    }
    label Fulfill {
      if (IsJSPromise(promiseOrCapability)) {
        // For fast native promises we can skip the indirection via the
        // promiseCapability.[[Resolve]] function and run the resolve logic
        // directly from here.
        return ResolvePromise(
            context, UnsafeCast<JSPromise>(promiseOrCapability), handlerResult);
      } else
        deferred {
          assert(IsPromiseCapability(promiseOrCapability));
          // In the general case we need to call the (user provided)
          // promiseCapability.[[Resolve]] function.
          const promiseCapability =
              UnsafeCast<PromiseCapability>(promiseOrCapability);
          const resolve = UnsafeCast<Callable>(promiseCapability.resolve);
          try {
            handlerResult = Call(context, resolve, Undefined, handlerResult);
          } catch (e) {
            handlerResult = e;
            goto Reject;
          }
          return handlerResult;
        }
    }
    label Reject {
      if (reactionType == kPromiseReactionReject) {
        const reason = handlerResult;
        if (IsJSPromise(promiseOrCapability)) {
          // For fast native promises we can skip the indirection via the
          // promiseCapability.[[Reject]] function and run the resolve logic
          // directly from here.
          return RejectPromise(
              UnsafeCast<JSPromise>(promiseOrCapability), reason, False);
        } else
          deferred {
            assert(IsPromiseCapability(promiseOrCapability));
            // In the general case we need to call the (user provided)
            // promiseCapability.[[Reject]] function.
            try {
              const promiseCapability =
                  UnsafeCast<PromiseCapability>(promiseOrCapability);
              const reject = UnsafeCast<Callable>(promiseCapability.reject);
              return Call(context, reject, Undefined, reason);
            } catch (e) {
              // Swallow the exception here.
              return runtime::ReportMessage(e);
            }
          }
      } else {
        StaticAssert(reactionType == kPromiseReactionFulfill);
        // We have to call out to the dedicated PromiseRejectReactionJob
        // builtin here, instead of just doing the work inline, as otherwise
        // the catch predictions in the debugger will be wrong, which just
        // walks the stack and checks for certain builtins.
        return PromiseRejectReactionJob(
            handlerResult, Undefined, promiseOrCapability);
      }
    }
  }

  transitioning builtin
  PromiseFulfillReactionJob(implicit context: Context)(
      value: JSAny, handler: Callable|Undefined,
      promiseOrCapability: JSPromise|PromiseCapability|Undefined): JSAny {
    return PromiseReactionJob(
        context, value, handler, promiseOrCapability, kPromiseReactionFulfill);
  }

  transitioning builtin
  PromiseRejectReactionJob(implicit context: Context)(
      reason: JSAny, handler: Callable|Undefined,
      promiseOrCapability: JSPromise|PromiseCapability|Undefined): JSAny {
    return PromiseReactionJob(
        context, reason, handler, promiseOrCapability, kPromiseReactionReject);
  }
}
