// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

type FrameBase extends RawPtr
    generates 'TNode<RawPtrT>' constexpr 'void*';
type JavaScriptFrame extends FrameBase
    generates 'TNode<RawPtrT>' constexpr 'void*';
type ArgumentsAdapterFrame extends FrameBase
    generates 'TNode<RawPtrT>' constexpr 'void*';
type Frame = ArgumentsAdapterFrame | JavaScriptFrame;

type FrameType extends Smi
    generates 'TNode<Smi>' constexpr 'StackFrame::Type';
extern macro TaggedToStackFrameType(Object): FrameType labels CastError;
Cast<FrameType>(o: Object): FrameType
    labels CastError {
  return TaggedToStackFrameType(o) otherwise CastError;
}
const ARGUMENTS_ADAPTOR: constexpr FrameType
    generates 'StackFrame::ARGUMENTS_ADAPTOR';

extern macro LoadFramePointer(): Frame;
extern macro LoadParentFramePointer(): Frame;

// Load values from a specified frame by given offset in bytes.
macro LoadObjectFromFrame(f: Frame, o: constexpr int32): Object {
  return LoadBufferObject(f, o);
}
macro LoadPointerFromFrame(f: Frame, o: constexpr int32): RawPtr {
  return LoadBufferPointer(f, o);
}
macro LoadSmiFromFrame(f: Frame, o: constexpr int32): Smi {
  return LoadBufferSmi(f, o);
}

const kStandardFrameFunctionOffset: constexpr int31
    generates 'StandardFrameConstants::kFunctionOffset';
operator '.function' macro LoadFunctionFromFrame(f: Frame): JSFunction {
  // TODO(danno): Use RawCast here in order to avoid passing the implicit
  // context, since this accessor is used in legacy CSA code through
  // LoadTargetFromFrame
  const result: Object = LoadObjectFromFrame(f, kStandardFrameFunctionOffset);
  return %RawCast<JSFunction>(result);
}
extern operator '.caller' macro LoadCallerFromFrame(Frame): Frame;
extern operator '.length' macro LoadLengthFromAdapterFrame(
    ArgumentsAdapterFrame): Smi;

type ContextOrFrameType = Context | FrameType;
extern operator '.context_or_frame_type'
    macro LoadContextOrFrameTypeFromFrame(Frame): ContextOrFrameType;

macro FromConstexpr<A: type>(e: constexpr FrameType): A;
extern macro StackFrameTypeConstant(constexpr FrameType): FrameType;
FromConstexpr<FrameType>(t: constexpr FrameType): FrameType {
  return StackFrameTypeConstant(t);
}

operator '==' macro FrameTypeEquals(f1: FrameType, f2: FrameType): bool {
  return WordEqual(f1, f2);
}

macro Cast<A: type>(implicit context: Context)(o: Frame): A labels CastError;
Cast<JavaScriptFrame>(implicit context: Context)(f: Frame):
    JavaScriptFrame labels CastError {
  const o: HeapObject =
      Cast<HeapObject>(f.context_or_frame_type) otherwise CastError;
  if (IsContext(o)) {
    return %RawCast<JavaScriptFrame>(f);
  }
  goto CastError;
}

Cast<ArgumentsAdapterFrame>(implicit context: Context)(f: Frame):
    ArgumentsAdapterFrame labels CastError {
  const t: FrameType =
      Cast<FrameType>(f.context_or_frame_type) otherwise CastError;
  if (t == ARGUMENTS_ADAPTOR) {
    return %RawCast<ArgumentsAdapterFrame>(f);
  }
  goto CastError;
}

// Load target function from the current JS frame.
// This is an alternative way of getting the target function in addition to
// Parameter(Descriptor::kJSTarget). The latter should be used near the
// beginning of builtin code while the target value is still in the register
// and the former should be used in slow paths in order to reduce register
// pressure on the fast path.
macro LoadTargetFromFrame(): JSFunction {
  return LoadFramePointer().function;
}
