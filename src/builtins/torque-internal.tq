// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace torque_internal {
  // TODO(gsps): Synthesize SizeOf<T> in the compiler
  // TODO(gsps): Add failure labels to Next() and Access()

  macro SizeOf<T: type>(): constexpr int31;
  SizeOf<Smi>(): constexpr int31 {
    return kTaggedSize;
  }

  struct Unsafe {}

  struct Reference<T: type> {
    const object: HeapObject;
    const offset: intptr;
    unsafeMarker: Unsafe;
  }

  macro UnsafeNewReference<T: type>(object: HeapObject, offset: intptr):&T {
    return Reference<T>{
      object: object,
      offset: offset,
      unsafeMarker: Unsafe {}
    };
  }

  struct Slice<T: type> {
    Access(index: intptr):&T {
      if (index < this.length) {
        return UnsafeNewReference<T>(
            this.base.object, this.base.offset + index * SizeOf<T>());
      } else {
        unreachable;
      }
    }

    NonEmpty(): bool {
      return 0 < this.length;
    }

    Next():&T {
      if (this.NonEmpty()) {
        const result = this.base;
        this.base = UnsafeNewReference<T>(
            this.base.object, this.base.offset + SizeOf<T>());
        this.length -= 1;
        return result;
      } else {
        unreachable;
      }
    }

    base:&T;
    length: intptr;
    unsafeMarker: Unsafe;
  }

  macro UnsafeNewSlice<T: type>(base: Reference<T>, length: intptr): Slice<T> {
    return Slice{base: base, length: length, unsafeMarker: Unsafe {}};
  }

}  // namespace torque_internal
