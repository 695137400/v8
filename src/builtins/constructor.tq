// Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace runtime {
extern runtime
NewObject(implicit context: Context)(JSFunction, JSReceiver): JSObject;
}

extern builtin FastNewObject(Context, JSFunction, JSReceiver): JSObject;

namespace constructor {

/*
macro EmitFastNewObject(context: Context, target: JSFunction, newTarget:
JSReceiver): JSObject { try { return EmitFastNewObjectInternal(target,
newTarget) otherwise CallRuntime; } label CallRuntime { return
runtime::NewObject(target, newTarget);
  }
}

macro EmitFastNewObjectInternal(target: JSFunction, newTarget: JSReceiver):
JSObject labels CallRuntime {
  // Verify that the new target is a JSFunction.
  const newTargetFunc: JSFunctionWithPrototypeSlot =
      HeapObjectToJSFunctionWithPrototypeSlot(newTarget) otherwise CallRuntime;
  // Fast path.
  // Load the initial map and verify that it's in fact a map.
  const initialMapOrProto: JSReceiver | Map =
LoadJSFunctionPrototypeOrInitialMap(newTargetFunc); const initialMap: Map =
Cast<Map>(initialMapOrProto) otherwise CallRuntime;

  // Fall back to runtime if the target differs from the new target's initial
  // map constructor.
  if (target != initialMap.constructor_or_back_pointer_or_native_context) goto
CallRuntime;

  const properties: NameDictionary | EmptyFixedArray =
      IsDictionaryMap(initialMap) ?
      EmptyFixedArrayConstant() :
      AllocateNameDictionary(kNameDictionaryInitialCapacity);
  return AllocateJSObjectFromMap(initialMap, properties, kEmptyFixedArray,
                               AllocationFlag::kNone,
                               SlackTrackingMode::kWithSlackTracking);
}

builtin FastNewObject(context: Context, target: JSFunction, newTarget:
JSReceiver): JSObject { try { return EmitFastNewObjectInternal(target,
newTarget) otherwise CallRuntime; } label CallRuntime { return
runtime::NewObject(target, newTarget);
  }
}
*/

// ES #sec-number-constructor
transitioning javascript builtin
NumberConstructor(
    js-implicit context: NativeContext, receiver: JSAny, newTarget: JSAny,
    target: JSFunction)(...arguments): JSAny {
  try {
    // 1. If no arguments were passed to this function invocation, let n be +0.
    if (arguments.length == 0) goto NLoaded(0);

    const value = arguments[0];
    // 2. Else,
    //    a. Let prim be ? ToNumeric(value).
    //    b. If Type(prim) is BigInt, let n be the Number value for prim.
    //    c. Otherwise, let n be prim.
    goto NLoaded(ToNumber_Inline(value));
  } label NLoaded(n: Number) {
    // 3. If NewTarget is undefined, return n.
    if (newTarget == Undefined) return n;

    // 4. Let O be ? OrdinaryCreateFromConstructor(NewTarget,
    //    "%NumberPrototype%", « [[NumberData]] »).
    // 5. Set O.[[NumberData]] to n.
    // 6. Return O.

    // We are not using the normal target parameter and loading the value
    // from the current frame here in order to reduce register pressure on the
    // fast path.
    const target: JSFunction = LoadTargetFromFrame();
    const result = UnsafeCast<JSPrimitiveWrapper>(
        FastNewObject(context, target, UnsafeCast<JSReceiver>(newTarget)));
    result.value = n;
    return result;
  }
}

/*
TF_BUILTIN(NumberConstructor, ConstructorBuiltinsAssembler) {
  TNode<Context> context = CAST(Parameter(Descriptor::kContext));
  TNode<IntPtrT> argc = ChangeInt32ToIntPtr(
      UncheckedCast<Int32T>(Parameter(Descriptor::kJSActualArgumentsCount)));
  CodeStubArguments args(this, argc);

  // 1. If no arguments were passed to this function invocation, let n be +0.
  TVARIABLE(Number, var_n, SmiConstant(0));
  Label if_nloaded(this, &var_n);
  GotoIf(IntPtrEqual(argc, IntPtrConstant(0)), &if_nloaded);

  // 2. Else,
  //    a. Let prim be ? ToNumeric(value).
  //    b. If Type(prim) is BigInt, let n be the Number value for prim.
  //    c. Otherwise, let n be prim.
  TNode<Object> value = args.AtIndex(0);
  var_n = ToNumber(context, value, BigIntHandling::kConvertToNumber);
  Goto(&if_nloaded);

  BIND(&if_nloaded);
  {
    // 3. If NewTarget is undefined, return n.
    TNode<Number> n_value = var_n.value();
    TNode<Object> new_target = CAST(Parameter(Descriptor::kJSNewTarget));
    Label return_n(this), constructnumber(this, Label::kDeferred);
    Branch(IsUndefined(new_target), &return_n, &constructnumber);

    BIND(&return_n);
    { args.PopAndReturn(n_value); }

    BIND(&constructnumber);
    {
      // 4. Let O be ? OrdinaryCreateFromConstructor(NewTarget,
      //    "%NumberPrototype%", « [[NumberData]] »).
      // 5. Set O.[[NumberData]] to n.
      // 6. Return O.

      // We are not using Parameter(Descriptor::kJSTarget) and loading the value
      // from the current frame here in order to reduce register pressure on the
      // fast path.
      TNode<JSFunction> target = LoadTargetFromFrame();
      TNode<HeapObject> result = CAST(
          CallBuiltin(Builtins::kFastNewObject, context, target, new_target));
      StoreObjectField(result, JSPrimitiveWrapper::kValueOffset, n_value);
      args.PopAndReturn(result);
    }
  }
}
*/

transitioning javascript builtin
GenericLazyDeoptContinuation(js-implicit context: NativeContext)(result: JSAny):
    JSAny {
  return result;
}

}  // namespace constructor
