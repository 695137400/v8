{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4a217aa3_ed231817",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2022-11-11T19:43:50Z",
      "side": 1,
      "message": "Hello Leszek, would you please take a look? Thanks!",
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee31c335_f9ad1270",
        "filename": "include/v8-script.h",
        "patchSetId": 1
      },
      "lineNbr": 503,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-11-14T12:13:41Z",
      "side": 1,
      "message": "Streaming compilation happens, in practice, at the same time as resource loading, so SourceTextAvailable will not normally be called before streaming completes.\n\nWith this in mind, I\u0027m wondering if it wouldn\u0027t be preferable to do the isolate cache lookup internally, as part of `ScriptCompiler::Compile(StreamedSource*,...)`, rather than exposing the more complex API.\n\nOTOH, the symmetry with ConsumeCachedCode is valuable, and this API does provide more flexibility (e.g. for inline script streaming). I\u0027m wondering what your design thoughts here are.",
      "range": {
        "startLine": 503,
        "startChar": 9,
        "endLine": 503,
        "endChar": 28
      },
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2845af49_37bc9be9",
        "filename": "include/v8-script.h",
        "patchSetId": 1
      },
      "lineNbr": 503,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2022-11-14T15:49:59Z",
      "side": 1,
      "message": "Interesting idea! Are you suggesting merging on the main thread during ScriptCompiler::Compile, or starting a background task at that time? If it\u0027s a background task, how would the embedder know when it\u0027s done?\n\nMy goal here was to avoid main-thread work as much as possible. Merging new content into an existing Script\u0027s object graph is cheap compared to parsing or deserialization, but it can still take multiple milliseconds for large scripts. If the embedder is to do something useful on the main thread during that time, then I think this API must expose a lot of detail so that the embedder knows what is going on. Otherwise, if we tried to hide the background work internally within V8, then we might end up blocking the main thread anyway if the embedder tries to call something which requires the result from the background thread.\n\nHere\u0027s a CL which implements the Blink side for using this API: https://chromium-review.googlesource.com/c/chromium/src/+/4023989 . It makes ScriptStreamer act like ScriptCacheConsumer from the perspective of ClassicPendingScript, which calls NotifyClientWaiting and awaits a callback to NotifyScriptProcessingFinished. As you mentioned, the script streaming task is already complete by the time we get to the point that calls ScriptStreamer::NotifyClientWaiting, so the state management in ScriptStreamer is rather simpler than ScriptCacheConsumer.",
      "parentUuid": "ee31c335_f9ad1270",
      "range": {
        "startLine": 503,
        "startChar": 9,
        "endLine": 503,
        "endChar": 28
      },
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3995c4f7_ef93facb",
        "filename": "include/v8-script.h",
        "patchSetId": 1
      },
      "lineNbr": 503,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-11-14T16:00:39Z",
      "side": 1,
      "message": "Right, the issue with doing this in ClassicPendingScript is that the ScriptResource is not considered to have finished loading until the streaming completes, so in practice you won\u0027t call SourceTextAvailable until the streaming task has ended.",
      "parentUuid": "2845af49_37bc9be9",
      "range": {
        "startLine": 503,
        "startChar": 9,
        "endLine": 503,
        "endChar": 28
      },
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f0213c3_d34f3b09",
        "filename": "include/v8-script.h",
        "patchSetId": 1
      },
      "lineNbr": 503,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2022-11-14T16:48:59Z",
      "side": 1,
      "message": "Sorry, I don\u0027t think I\u0027m understanding your suggestion. If we can\u0027t call SourceTextAvailable until after the streaming task has ended, does that mean it\u0027s not worth posting a second background task to run MergeWithExistingScript? ScriptCompiler::Compile returns a MaybeLocal\u003cScript\u003e, which the embedder can immediately run, so we can\u0027t easily hide background processing within it. Should ScriptCompiler::Compile do any necessary merging synchronously before it returns? I like the simplicity of merging on the main thread, but you advised in [1] to put the merge work on a background thread.\n\n[1] https://docs.google.com/document/d/1UksB5Vm7TT1-f3S9W1dK_rP9jKn_ly0WVm_UDPpWuBw/edit#",
      "parentUuid": "3995c4f7_ef93facb",
      "range": {
        "startLine": 503,
        "startChar": 9,
        "endLine": 503,
        "endChar": 28
      },
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c21001a1_41725136",
        "filename": "include/v8-script.h",
        "patchSetId": 1
      },
      "lineNbr": 503,
      "author": {
        "id": 1175774
      },
      "writtenOn": "2022-11-14T16:56:27Z",
      "side": 1,
      "message": "For deserialization, yes, because the source text is available independently of the deserialization completing. Here, it\u0027s dependent on the streaming completeing.\n\nIt might be good for interactivity reasons to post a BG task for merging, but it introduces some amount of latency because at this point Blink is waiting for that script to be compiled and executed.\n\nMaybe we could access the V8 Isolate cache from the background thread, to keep the merge part of the BG streaming task?",
      "parentUuid": "6f0213c3_d34f3b09",
      "range": {
        "startLine": 503,
        "startChar": 9,
        "endLine": 503,
        "endChar": 28
      },
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13e1b94d_758c6050",
        "filename": "include/v8-script.h",
        "patchSetId": 1
      },
      "lineNbr": 503,
      "author": {
        "id": 1325508
      },
      "writtenOn": "2022-11-14T20:05:17Z",
      "side": 1,
      "message": "\u003e Maybe we could access the V8 Isolate cache from the background thread, to keep the merge part of the BG streaming task?\n\nI think that this API would become much more complex if we wanted to support compilation cache lookup from a background thread. This CL\u0027s version of SourceTextAvailable takes a `Local\u003cString\u003e source_text`, but to get such a string, the embedder must call `String::NewFromOneByte`, `String::NewFromTwoByte`, or some similar allocation function. As far as I understand, those allocation functions must be called on the main thread. So if we wanted to avoid any main-thread activity after the resource has finished loading, this API would have to expose ways for the embedder to directly pass the underlying string data (in various possible formats) rather than a Local\u003cString\u003e object.\n\nFurthermore, lookup in the Isolate compilation cache requires some other data about the script, which is encapsulated in ScriptOrigin. Currently, ClassicScript is responsible for creating the ScriptOrigin, but we\u0027d have to create it before starting the streaming task, if the background thread accesses the Isolate cache. I think the necessary data is all available by then, but I\u0027m not sure where to produce the ScriptOrigin without introducing layering violations in Blink.\n\nGiven the level of complexity involved in background lookup, and the extra latency introduced by a main-thread lookup which then posts a second background task, I prefer your original recommendation of doing the extra work within `ScriptCompiler::Compile`. This requires some main-thread time to perform the merge, but merging is pretty fast and the vast majority of compilations don\u0027t require merging. Thanks a lot for the advice! ðŸ˜Š",
      "parentUuid": "c21001a1_41725136",
      "range": {
        "startLine": 503,
        "startChar": 9,
        "endLine": 503,
        "endChar": 28
      },
      "revId": "aa6f3df00194e8c94842023ea364f8474d73c745",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}