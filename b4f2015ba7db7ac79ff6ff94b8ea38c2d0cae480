{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e75e6ea9_31f9ef8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2024-01-15T11:31:30Z",
      "side": 1,
      "message": "WDYT?",
      "revId": "b4f2015ba7db7ac79ff6ff94b8ea38c2d0cae480",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97bf8041_9ce24db1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2024-01-15T11:48:14Z",
      "side": 1,
      "message": "I think this lg as it\u0027s an improvement to the current state. I wonder if we should set up an OOM handler to also be able to yield to the embedder properly.\n\nWhy not generallize the `FatalOutOfMemoryHandler`? It solves this issue by delegating to the V8-specific callback.\n\nhttps://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/cppgc/platform.h;l\u003d18;drc\u003d98a01e556dc3c775db2a129120504518b3e9b7e0;bpv\u003d1;bpt\u003d1\n\nhttps://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/cppgc-js/cpp-heap.cc;drc\u003d98a01e556dc3c775db2a129120504518b3e9b7e0;bpv\u003d1;bpt\u003d1;l\u003d239",
      "revId": "b4f2015ba7db7ac79ff6ff94b8ea38c2d0cae480",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3d54a425_687e3d2b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2024-01-17T13:19:16Z",
      "side": 1,
      "message": "As discussed offline, let\u0027s go with this implementation for now, but I left a longer comment in FatalOOM about the drawbacks and how it could be improved.",
      "parentUuid": "97bf8041_9ce24db1",
      "revId": "b4f2015ba7db7ac79ff6ff94b8ea38c2d0cae480",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64e6a813_0b910620",
        "filename": "src/base/logging.h",
        "patchSetId": 7
      },
      "lineNbr": 95,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2024-01-15T11:48:14Z",
      "side": 1,
      "message": "fwiw, `v8::SourceLocation` can be used to propagate file/line information. Can this be useful here?",
      "range": {
        "startLine": 95,
        "startChar": 33,
        "endLine": 95,
        "endChar": 41
      },
      "revId": "b4f2015ba7db7ac79ff6ff94b8ea38c2d0cae480",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "563f6a6c_0cb0c561",
        "filename": "src/base/logging.h",
        "patchSetId": 7
      },
      "lineNbr": 95,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2024-01-17T13:19:16Z",
      "side": 1,
      "message": "Ah that\u0027s a neat trick! But I think I will go with Clemens\u0027 suggestion and just call `PrintError` + `Abort` directly from here since we already basically have source location information through the message. This also works nicely with the fuzzing case where we want to ignore OOMs completely and so just `_exit(1)` here, but it\u0027s still nice to print the error message first.",
      "parentUuid": "64e6a813_0b910620",
      "range": {
        "startLine": 95,
        "startChar": 33,
        "endLine": 95,
        "endChar": 41
      },
      "revId": "b4f2015ba7db7ac79ff6ff94b8ea38c2d0cae480",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}