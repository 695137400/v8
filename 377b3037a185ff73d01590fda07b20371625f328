{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b9098abc_d638adab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T12:30:42Z",
      "side": 1,
      "message": "As a high-level comment for the failing `for..in` on external objects - are they actually supposed to have their properties enumerable like on regular JSObjects? If not, maybe we should allocate them in a way that all properties are not enumerable?",
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a02fcbf2_c78b2dd3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-24T13:47:55Z",
      "side": 1,
      "message": "They have no enumerable properties and no prototype set (so they look equal to an object created through `Object.create(null)`).",
      "parentUuid": "b9098abc_d638adab",
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a36751b_286a8216",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T13:50:58Z",
      "side": 1,
      "message": "Ah, I see. But for..in shouldn\u0027t crash indeed. Did you check if it works now?",
      "parentUuid": "a02fcbf2_c78b2dd3",
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fd1ccb5_6eef8b37",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T12:30:42Z",
      "side": 1,
      "message": "Should be Type::Uint32.",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e77b1ffe_911eb860",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-24T13:47:55Z",
      "side": 1,
      "message": "That would be for sandboxed code only, right? Non-sandboxed code will still save an external pointer I think?",
      "parentUuid": "9fd1ccb5_6eef8b37",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "642fde23_43cfdc92",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T13:50:58Z",
      "side": 1,
      "message": "Yeah, I guess. But Samuel assumed that maybe you wouldn\u0027t be using sandboxed mode at all.",
      "parentUuid": "e77b1ffe_911eb860",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0652268d_e51cfed9",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T14:54:23Z",
      "side": 1,
      "message": "@Samuel again interestingly this seems to work better with `ExternalPointer`, since it later gets replaced by memory lowering. The only thing that we\u0027re not doing 100% correct in this case is maybe setting some bit on the object\u0027s map to tell it to not have enumerable properties.\n\nCan you dig out the link of the CL that removed the external pointer support in generated code, which you mentioned today? Thanks!",
      "parentUuid": "642fde23_43cfdc92",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e126c5e2_9f830bfc",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2022-10-24T16:31:30Z",
      "side": 1,
      "message": "Ah yeah, for loading ExternalPointers this needs to be `Type::ExternalPointer()` since then memory-lowering adds the necessary logic. Memory-lowering does not have the logic needed to store ExternalPointers though (that\u0027s why there\u0027s that DCHECK). So if we need to support this, then either that logic needs to be added (probably to memory-lowering, but then effect-control-linearizer still needs to write the ExternalPointerHandle [the 32-bit index] into the object first), or it could be performed by the C++ function (can we pass the allocated object to it and have it initialize it?).\n\nThere was never ExternalPointerTable allocation support in Turbofan, but we used to have it in CSA: https://chromium.googlesource.com/v8/v8.git/+/8a59678b8335ae8c3fa237317aa8ae6cb281efa2",
      "parentUuid": "0652268d_e51cfed9",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1ea2fb4_d9ef806d",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-25T10:12:37Z",
      "side": 1,
      "message": "I would suppose that memory-lowering would be changed in such a way that ECL simply calls `__ StoreField(ForJSExternalObjectValue(), external, pointer)` and ML changes the StoreField to actually store the pointer in the external table, get the handle and finally store the handle in the external object. I don\u0027t see how ECL would need to write the handle into the object first, if ML is the one doing the storing anyway: ECL wouldn\u0027t even see or know the handle, so how could it store it?\n\nI\u0027ll take a look at the CSA code later to see if I can adapt it to TF. So far trying to write C++ functions for the allocation + initialization has run into one of two issues:\n1. If creating a Builtin, it requires passing the parameters using V8 wrappers (handles etc). This seems terribly inefficient and I\u0027d like to avoid such useless waste of performance, as both the original TF code and the receiving C++ code just want the raw data and not some wrapped up indirection.\n2. If creating an ExternalReference to the function, which would allow calling with the raw data, it\u0027s apparently not possible to return eg. a Handle. So the ExternalReference to the function cannot do the allocation as it would need to return a Handle to the allocated object, and the ExternalReference macro forbids that.",
      "parentUuid": "e126c5e2_9f830bfc",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f616369_6054a30d",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2022-10-25T10:57:35Z",
      "side": 1,
      "message": "So storing and initializing an external pointer field are two different things. With the sandbox enabled, storing means:\n- Read the ExternalPointerHandle (the 32-bit table index) from the object\n- Store the pointer into the table at the loaded index\n\nInitializing means:\n- Allocate an entry in the ExternalPointerTable\n- Store the handle to that entry into the object\n\nThere\u0027s an invariant that an external pointer field must never be initialized twice, i.e. the handle must never change again, only the content in the table is allowed to change.\n\nLoading and storing of external pointers can (should?) happen in memory-lowering, but I\u0027m not sure what the best place for initializing is. Probably wherever the JSExternalObject is allocated? I\u0027m not a Turbofan expert though, so I\u0027m not sure what the best way to implement this would be :/",
      "parentUuid": "a1ea2fb4_d9ef806d",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7f9375c_01081ff4",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-26T10:12:29Z",
      "side": 1,
      "message": "I tend to think that initializing the external pointer in ML sounds reasonable. But then it needs to happen before ECL stores it into the object, right? Another option is to do both the initialization and the storing in ML, which is I believe what Aapo is suggesting with the `__ StoreField` call in ECL.\n\nAnd I agree that creating a Handle just to call a builtin might not make sense, since the whole purpose of the fast API is to pass data unhandlified. How about changing the ExternalReference macro to allow passing a Handle as a return value?",
      "parentUuid": "3f616369_6054a30d",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84b842c4_a0966c8b",
        "filename": "src/compiler/access-builder.cc",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-11-01T15:37:32Z",
      "side": 1,
      "message": "So, if I\u0027m reading this right the play-by-play guide to getting a pointer into the table should be:\n1. Allocate a heap object of type W (for us an `External`) for a given pointer W*.\n2. Allocate an entry E in the ExternalPointerTable, receiving a handle.\n3. Store the handle into the heap object.\n5. Store the pointer W* into the table using the handle, adding the tag for type W.",
      "parentUuid": "f7f9375c_01081ff4",
      "range": {
        "startLine": 36,
        "startChar": 12,
        "endLine": 36,
        "endChar": 27
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46480391_57d81af5",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T12:30:42Z",
      "side": 1,
      "message": "Do you actually use the sandbox mode in Deno?\n  - If not, Samuel suggested that we remove the if-section (or replace it with an UNIMPLEMENTED() basically) and only have the non-sandboxed version with doesn\u0027t store in the external pointer table. Same goes for loading too.\n  - If you do need the sandbox mode, then let\u0027s create a C++ (prob. static) function that allocates and initializes the JSExternalObject with a given pointer value (mostly what is already there in factory.cc), which will also allow us to not have an AccessBuilder helper.",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63e1faf6_99ae0854",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-24T13:47:55Z",
      "side": 1,
      "message": "AccessBuilder is sill needed for parameter side (unless done manually).\n\nI\u0027m... not sure if Deno disables sandbox or not, honestly. If we\u0027re not using it yet, I\u0027d expect we\u0027d want to use it eventually...\n\nBut yeah, it does seem like Deno does disable the sandbox: https://github.com/denoland/rusty_v8/blob/c89ae9453bc18919a2b5dd8e714b9f8358ee27a5/.gn#L33\n\nStill, do we really want to implement this feature with only Deno in mind and make it non-sandboxed only?",
      "parentUuid": "46480391_57d81af5",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58fe348b_debdd930",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T13:50:58Z",
      "side": 1,
      "message": "Well, currently Chromium doesn\u0027t use it, and it\u0027s the only embedder (we know of) that enables the sandbox. In ideal world we\u0027d want to support both modes, but then I agree with Samuel\u0027s suggestion to move the allocation and pointer registration in the table to a C++ function. It can also branch based on the ENABLE_SANDBOX macro.",
      "parentUuid": "63e1faf6_99ae0854",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef63791d_5ba46c16",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-24T13:54:58Z",
      "side": 1,
      "message": "I started making an ExternalReference C++ function that would handle the both the allocation and pointer registration, but it would have to return a Local or Handle (not quite sure which), and ExternalReference is apparently not allowed to return those.",
      "parentUuid": "58fe348b_debdd930",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76632aef_30642915",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T14:01:19Z",
      "side": 1,
      "message": "Since it\u0027s internal only, returning Handle should be fine. But why would it return an ExternalReference and not a Handle\u003cJSExternalObject\u003e? It\u0027s what the `Node* external` currently holds, right?",
      "parentUuid": "ef63791d_5ba46c16",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efe82f02_ee022bc6",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-24T14:08:31Z",
      "side": 1,
      "message": "ExternalReference is a class used to give pointers to the JIT code, so eg. isolate_address or such. Or so I think. If my understanding is correct, it\u0027s required to give the function to the TurboFan code, but the macro that creates ExternalReferences didn\u0027t allow returning a Local, nor a Handle either if memory serves.",
      "parentUuid": "76632aef_30642915",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1fa156a7_edbcffc3",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1283477
      },
      "writtenOn": "2022-10-24T14:20:57Z",
      "side": 1,
      "message": "Ah, I see what you mean. Yeah, ExternalReference is needed to call a C function from generated code. Then maybe we still need a Builtin, as they can return Object (or anything that inherits from it), e.g. BUILTIN_CALL_PAIR.\n@Samuel do you think the function storing an external pointer in the table and allocating the JSExternalObject can actually be a builtin? I guess with C++ linkage?",
      "parentUuid": "efe82f02_ee022bc6",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d891a7e_306942fc",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2022-10-24T16:31:30Z",
      "side": 1,
      "message": "I am a bit worried that we\u0027re adding (more) code that cannot currently be used securely when the sandbox is enabled (see other comment about needing unique ExternalPointerTags for it to be secure). So if this is only used by Deno (for now), I\u0027d prefer not adding the logic at all so it cannot be accidentally misused in the future (the feature is then essentially incompatible with the Sandbox).\n\nThe sandbox only has security benefits for an Embedder like Chromium that runs untrusted JavaScript code. IIUC, for Deno (and Node.js, etc.) this is not the case, so the sandbox provides no security benefits but only causes (small) performance regressions.",
      "parentUuid": "1fa156a7_edbcffc3",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcae4a5a_1eebf300",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-10-25T10:12:37Z",
      "side": 1,
      "message": "I\u0027d argue that all code should always be untrusted :) Deno also opts into a browser-like permissions model, where all code is considered unsafe and is disallowed from doing anything that would escape the V8 sandbox unless explicitly allowed. There are commercial users who explicitly use Deno to run user code (thus unsafe) as an edge computing platform, and for them the sandbox would definitely be a security benefit.\n\nThough I do not quite understand some of the proposed / required security guarantees of the sandboxed pointers. Them being outside the actual V8 heap and thus not followable or corruptable I understand, and that makes a lot of sense. Non-interchangeability makes some sense for an embedder as it gives essentially run-time type safety to pointer usage. What I don\u0027t understand is how interchangeability of external pointers allows for breaking out of the sandbox, not directly anyway. Of course, if you can forge your own external pointers and access an API to get the pointer value with your forged external pointer tag, you can get the pointer values of other external pointers with the same tag and then follow those pointers. But that sort of an API is probably not normally offered?\n\nAdditionally, I do not understand how V8 intends to guarantee the live-ness of pointers in the pointer table. For eg. ArrayBuffers and so on I understand: You can control how/when they\u0027re allocated into the pointer table, but for external pointers I simply do not understand how this is meant to work. The only feature that points towards this is FinalizationRegistries, but you\u0027re not required to use those with `External`.\n\nI\u0027ve personally viewed the `External` object as the, well, external (void*) pointer of V8: The engine (language / API) can give no guarantees about the validity of pointer, or what it is pointing to and instead it is up to the embedder / user to guarantee the safe usage of these.",
      "parentUuid": "1d891a7e_306942fc",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45d17fc4_0b15c4a8",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1519522
      },
      "writtenOn": "2022-10-25T10:57:35Z",
      "side": 1,
      "message": "```\nWhat I don\u0027t understand is how interchangeability of external pointers allows for breaking out of the sandbox, not directly anyway\n```\nThe scenario its trying to avoid is something like this:\n- Embedder code creates the C++ objects A of class ClassA and B of class ClassB\n- Embedder code creates two V8 wrapper objects, WA and WB, and stores the pointers to A and B in them respectively, using the same external pointer tag\n- Embedder code later on loads the native pointer from WA and essentially does a \"reinterpret_cast\u003cClassA*\u003e(value)\" on it, then goes on to use it as a ClassA instance\n\nHere the interchangeability requirement is violated: WA and WB both use the same tag, but their external pointers are not interchangeable: doing so will cause a type confusion in the Embedder, likely causing memory corruption and allowing an attacker to escape from the sandbox. \n\n\n```\nAdditionally, I do not understand how V8 intends to guarantee the live-ness of pointers in the pointer table\n```\nThe rough idea is that the table is garbage-collected, and we keep the pointed-to objects alive as long as there\u0027s an entry for them in the table. Once an external object is no longer referenced from V8, its entry will be freed by the GC, at which point we can also free the external object (unless there are other references to it). So basically all external objects either need to the statically allocated (and never be freed), or be uniquely owned by the table, or use some sort of reference counting.\n\n\n```\nI\u0027ve personally viewed the External object as the, well, external (void*) pointer of V8: The engine (language / API) can give no guarantees about the validity of pointer, or what it is pointing to and instead it is up to the embedder / user to guarantee the safe usage of these.\n```\nYeah that works. Maybe we should just add some comments that clarify this to avoid misuse in the future and then just keep using kExternalObjectValueTag for now.\n\nHope that helps!",
      "parentUuid": "dcae4a5a_1eebf300",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ec2d66e_445e3505",
        "filename": "src/compiler/effect-control-linearizer.cc",
        "patchSetId": 5
      },
      "lineNbr": 6900,
      "author": {
        "id": 1558499
      },
      "writtenOn": "2022-11-01T15:37:32Z",
      "side": 1,
      "message": "\u003e Re: External Pointer Table and GC\n\nFor ownership including pointers this is definitely reasonable, `External` is just a notable exception to this as it does not carry ownership (at a language level) and does not require or offer any means of bolting into the GC of its own.\n\nSo, sounds reasonable to me to add comments about this as an \"escape hatch\" of sorts. The `kExternalObjectValueTag` is definitely a risk compared to compile-time constexpr tags \"built to purpose\" but it is also possibly the only thing available under some circumstances. Any ideas where such comments should be added? Would this extend all the way to the `External` class\u0027 public API documents?",
      "parentUuid": "45d17fc4_0b15c4a8",
      "range": {
        "startLine": 6900,
        "startChar": 7,
        "endLine": 6900,
        "endChar": 24
      },
      "revId": "377b3037a185ff73d01590fda07b20371625f328",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}