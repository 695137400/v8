{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9d126bd4_ceea69be",
        "filename": "src/compiler/machine-operator-reducer.cc",
        "patchSetId": 13
      },
      "lineNbr": 1860,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2022-03-17T12:13:37Z",
      "side": 1,
      "message": "Tobias, can you check if this is correct, or if we need a Word32-\u003eWord64 propagation of the Word32And?",
      "revId": "702abb2412a992e44c2d21e09e515706ded3a997",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e6c71f4_30ba5602",
        "filename": "src/compiler/machine-operator-reducer.cc",
        "patchSetId": 13
      },
      "lineNbr": 1860,
      "author": {
        "id": 1180419
      },
      "writtenOn": "2022-03-18T14:07:42Z",
      "side": 1,
      "message": "We normally do use the ChangeUint32ToUint64 operator to explicitly zero-extend a value for 64bit.\nI don\u0027t think this is the right place to do this optimization. Many TurboFan optimizations don\u0027t work properly if we mix operators of different bit-width, and this would introduce such a change. I think it would make more sense to match this pattern in platform-specific InstructionSelector code, where we can replace it with the `andl` instruction.\nIn this particular case, bitwise-and with 0xffffffff can be expressed even more concisely as a 32-bit `mov` instruction, which encodes as only 2 bytes.",
      "parentUuid": "9d126bd4_ceea69be",
      "revId": "702abb2412a992e44c2d21e09e515706ded3a997",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}