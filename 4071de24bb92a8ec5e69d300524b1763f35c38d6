{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "079a527e_735e16bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2021-12-09T10:41:26Z",
      "side": 1,
      "message": "PTAL, thanks! (For some reason it seems the updates are in patch set 1..3)",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d57b175d_5a49d56c",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-12-09T12:12:56Z",
      "side": 1,
      "message": "You can deserialize shared_info-\u003eouter_scope_info() to get the class scope?",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8dd89e36_0d0eef92",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2021-12-09T13:31:48Z",
      "side": 1,
      "message": "The deserialization is already done by DeserializeScopeChain() earlier, but it seems during error rendering, in the test cases at least, shared_info-\u003eGetOuterScopeInfo() becomes the script scope instead of the class scope, so that\u0027s what gets deserialized.\n\n0x16f608295bd5: [ScopeInfo] in OldSpace\n - map: 0x16f6080025d5 \u003cMap\u003e\n - parameters: 0\n - context locals : 2\n - scope type: SCRIPT_SCOPE\n - language mode: strict\n - declaration scope\n - function name(UNUSED): 0x16f608002501 \u003cString[0]: #\u003e\n - function kind: NormalFunction\n - function name: 0x16f608002501 \u003cString[0]: #\u003e\n - start position: 0\n - end position: 418\n - length: 11\n - context slots {\n    - 0: 0x16f608295ad9 \u003cString[1]: #C\u003e\n    - 1: 0x16f608295b39 \u003cString[1]: #D\u003e\n  }\n\nThis seems to be a strict mode thing, in sloppy mode the outer scope info comes from the class scope and original_scope_-\u003eis_class_scope() is true here.",
      "parentUuid": "d57b175d_5a49d56c",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01da06ac_baf300be",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2021-12-09T13:59:13Z",
      "side": 1,
      "message": "hmm, I remembered why, the class scope doesn\u0027t need the context in the test cases (those are public field initializers, not private) so no scope infos are allocated. When the scope infos are allocated e.g. when there are private fields, original_scope_-\u003eis_class_scope() would still be true here.",
      "parentUuid": "8dd89e36_0d0eef92",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2302e9c0_87a74aec",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2021-12-09T14:15:53Z",
      "side": 1,
      "message": "It seems in the case of snapshots (at least in the tests in test-serialize.cc), the scope chain is preserved, so the tests with only public fields pass just fine, but in the case of error rendering the scope chain is optimized to remove any scopes that don\u0027t need the ScopeInfo. In that case I think we can just insert a new class scope into the scope chain - there shouldn\u0027t be any variables to allocate in this kind of empty class scopes anyway, so we can just skip the allocation fixup in ReplaceReparsedClassScope.",
      "parentUuid": "01da06ac_baf300be",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05cd8d32_30b767cc",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-12-09T14:44:44Z",
      "side": 1,
      "message": "Mmh, doesn\u0027t that mean that we\u0027ll call DoParseFunction for such classes if we were to age the code?\n\nWhat about making the code below resilient to not having an outer context if none is needed?\n\nI\u0027m also worried that we might have a class that needs it with a class that doesn\u0027t need it embedded into it, causing us to deserialize the wrong scope. E.g. something like:\n\nclass A {\n  #a;\n  b \u003d class B { c \u003d 1; }\n}\n\nThe outer scope for the initializer for B will the class scope for A (since it has a private name). It would seem like the initializer itself should know whether it references private names.\n\nIs it only private names btw? If so: why do we currently eagerly deserialize both? Couldn\u0027t we lazily deserialize non-private names during scope resolution?",
      "parentUuid": "2302e9c0_87a74aec",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8bca1f8_a6c317f0",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1288325
      },
      "writtenOn": "2021-12-09T15:15:13Z",
      "side": 1,
      "message": "I wonder if we can repurpose the private_name_lookup_skips_outer_class bit on SFI and ScopeInfo to indicate a more general case where a scopes\u0027s outer scope isn\u0027t what it was originally (even if no private name lookup is necessary - for now it\u0027s only set when there\u0027s private name lookup). Then in those cases, we just insert a new class scope here. Private name resolution should also work fine as long as that bit is taken care of.\n\n\u003e Is it only private names btw? If so: why do we currently eagerly deserialize both? Couldn\u0027t we lazily deserialize non-private names during scope resolution?\n\nThe names will always be declared by the parser during reparsing, we are only restoring their context indicies. If we want to restore the indicies lazily, then we need to introduce linear lookups on the ScopeInfo during scope resolution. Right now they only fall back to the scope info if the variables does not exist - we had to introduce logic to handle the case where the variable does exist but it\u0027s lacking allocation info that you\u0027d get from a real LookupInScopeInfo call, which seems to introduce more complexity to the lookups than just looping over the variables from the scope info in one go before resolution.",
      "parentUuid": "05cd8d32_30b767cc",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ed3a34c_56265951",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 3
      },
      "lineNbr": 1043,
      "author": {
        "id": 1184114
      },
      "writtenOn": "2021-12-09T17:13:37Z",
      "side": 1,
      "message": "First part: I don\u0027t think it\u0027s possible to reuse that bit for an orthogonal purpose without breaking one of the usecases. They also overlap. E.g., class A { #a; x \u003d class B { c \u003d ...#a } }; here the initializer for B shouldn\u0027t skip A simply because \"class B\"\u0027s scope isn\u0027t the outer scope of the initializer for B; that would mean it wouldn\u0027t see #a anymore.\n\nI also don\u0027t think we need it in general. We just need to know whether this initializer accesses private names or not; and if it does the outer scope has to be its outer class scope.\n\nSecond part: ah right, that\u0027s fine.",
      "parentUuid": "f8bca1f8_a6c317f0",
      "revId": "4071de24bb92a8ec5e69d300524b1763f35c38d6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}