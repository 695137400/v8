{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9b21e09e_93aa1e9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2021-06-14T08:39:28Z",
      "side": 1,
      "message": "ptal (this is on top of a few other CLs)",
      "revId": "dc731b53e52bc0db874a5c7a577c02aa6d09a365",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e5e38d9_4222f109",
        "filename": "src/compiler/heap-refs.cc",
        "patchSetId": 1
      },
      "lineNbr": 4601,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2021-06-15T08:25:33Z",
      "side": 1,
      "message": "Creating a Ref here isn\u0027t necessary, I think. Even below it isn\u0027t.\nI\u0027d just do\n\nreturn *object() !\u003d object()-\u003eglobal_proxy().map().prototype()\n\nThen the type can stay bool.",
      "revId": "dc731b53e52bc0db874a5c7a577c02aa6d09a365",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cee3d40b_c5fd0f17",
        "filename": "src/compiler/heap-refs.cc",
        "patchSetId": 1
      },
      "lineNbr": 4601,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2021-06-17T05:06:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1e5e38d9_4222f109",
      "revId": "dc731b53e52bc0db874a5c7a577c02aa6d09a365",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ee89a41_d36a2f89",
        "filename": "src/compiler/js-native-context-specialization.cc",
        "patchSetId": 1
      },
      "lineNbr": 1183,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2021-06-17T05:06:30Z",
      "side": 1,
      "message": "Looking at this again, I wonder how/if we protect from concurrent changes that\u0027d change the IsDetached result (i.e. what if IsDetached returns false here, but that changes later while we\u0027re still compiling).",
      "revId": "dc731b53e52bc0db874a5c7a577c02aa6d09a365",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58a5db92_35db6dfc",
        "filename": "src/compiler/js-native-context-specialization.cc",
        "patchSetId": 1
      },
      "lineNbr": 1183,
      "author": {
        "id": 1119597
      },
      "writtenOn": "2021-06-23T08:15:12Z",
      "side": 1,
      "message": "Here\u0027s how this works (I will add a comment to the code):\n\n- We must not use the property cell (or its value) when IsDetached becomes true.\n- When IsDetached changes from false to true, the map of the global proxy changes (see Bootstrapper::DetachGlobal).\n- When we take this path in TF, ReduceGlobalAccess will emit a deopting-check that the incoming object\u0027s map is the global proxy\u0027s (compile-time) map. Hence we will deopt when IsDetached changes after compilation.\n- Regarding concurrency, no additional changes are needed as long as the global-proxy\u0027s (compile-time) map is cached.",
      "parentUuid": "2ee89a41_d36a2f89",
      "revId": "dc731b53e52bc0db874a5c7a577c02aa6d09a365",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4729372a_ed0895d0",
        "filename": "src/compiler/js-native-context-specialization.cc",
        "patchSetId": 1
      },
      "lineNbr": 1184,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2021-06-14T08:39:28Z",
      "side": 1,
      "message": "Only this is new, the rest is pure refactoring.",
      "range": {
        "startLine": 1182,
        "startChar": 0,
        "endLine": 1184,
        "endChar": 60
      },
      "revId": "dc731b53e52bc0db874a5c7a577c02aa6d09a365",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}