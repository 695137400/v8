{
  "comments": [
    {
      "key": {
        "uuid": "433f84fb_d87cb94e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-07-23T11:47:40Z",
      "side": 1,
      "message": "I revised this CL from last week.\nIt had issues around finalizing marking and GCs.\nShould be fixed now.",
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcd7a8d3_7903f10b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-07-23T12:24:49Z",
      "side": 1,
      "message": "First round of high level comments",
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5e32bbe_32580d6c",
        "filename": "src/heap/cppgc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 107,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-07-23T12:24:49Z",
      "side": 1,
      "message": "Not a huge fan of the CollectGarbage call that can deal with every scenario. I would rewrite this (adjusting function parameters as needed) as follows:\n- CollectGarbage(): This call finalizes any existing marking that is already running. It always invokes the atomic pause.\n- StartIncrementalMarking(): Starts incremental marking if not already running.\n\nAssuming that we keep the CollectGarbage() call that can do everything, I would avoid the conditional StartMarking() but rather have\n  marker_-\u003eStartMarking()\n  if (config... \u003d\u003d incremental)\n    return;\n\nand\n  void MarkerBase::StartMarking(...) {\n    if (already marking) return;\n    // Ensure marking is started properly wrt. marking config.\n  }\n\nThis would mean the following post conditions for MarkerBase::StartMarking():\n- Incremental: Marking is always on and prepared for incremental\n- Atomic: Marking is always on and prepared for atomic (which means stack has been scanned)\n\n(I found it really hard to interpret StartMarking() \u003d\u003d false \u003d\u003e incremental marking was started successfully.)",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 36
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a5494d8e_0143438d",
        "filename": "src/heap/cppgc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 107,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-07-24T20:45:42Z",
      "side": 1,
      "message": "I think for the standalone library it would make sense to:\n1) Set the default config according to what the platform provides (e.g. if the platform provides a foreground task runner use incremental, if it supports jobs use concurrent marking, etc.)\n2) Have a single call that does whatever is needed based on the config.\n\nYou will probably say that CollectGarbage is not on the user visible api. That is true but I still think this kind of design makes sense for the library as a single bottleneck for starting garbage collection and a separation of responsibilities (e.g. not have the Heap involved in scheduling incremental tasks).\n\nAs for the return value, I agree that it is not optimal.\nThe reason I added it is because I wanted to avoid having the Heap aware of marking internals, specifically making decisions based on marking type. I would like to keep all the decision encapsulated in Marker.\nWhat I was trying to do is have the return value signify whether or not Heap should finalize GC immediately (which correlates with whether incremental marking is running, but semantically is a bit different).\nI guess that meaning isn\u0027t conveyed well by the code, so I\u0027m happy to explore alternatives.\n\nAnother option I thought of is for StartMarking, in case of atomic marking, to call a finalization method in the Heap. I think it would be similar to the finalization task, but just not as a task.\nIt might require having another virtual method on the marker, but I don\u0027t think that\u0027s too bad.\nwdyt?",
      "parentUuid": "d5e32bbe_32580d6c",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 36
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "010b5f02_fa7b4951",
        "filename": "src/heap/cppgc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 107,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-07-24T22:30:20Z",
      "side": 1,
      "message": "Heap (internal or external) is our bottleneck for communicating things like \"do GC\", \"start marking\", \"finalize already running GC\", and so on. This is not interfering with responsibilities of e.g. scheduling a marking task.\n\nHeap definitely has high-level knowledge of phases (e.g. marking, or sweeping) and configurations (incremental vs atomic).\n\nThe default GCs should be covered by our GC invoker (or similar) that knows what kind of GC it can trigger.\n\nI think the V8 API makes a lot of sense in this regard:\n- CollectGarbage() this call will invoke a GC finalization independent of whether marking is running.\n- StartMarking() for just starting GC\n- FinalizeGCIfRunning() (or similar): Finalize a GC that is already running.\n\nWhat I think we should avoid:\n- CollectGarbage() god call that is used for everything\n- CollectGarbage() figuring out on its own what type it should be\n- Calls like StartMarking() that internally already finish marking",
      "parentUuid": "a5494d8e_0143438d",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 36
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4326cc46_09fdfed2",
        "filename": "src/heap/cppgc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 107,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-07-28T16:08:11Z",
      "side": 1,
      "message": "I\u0027m actually leaning in a different direction.\n\nAs I mentioned in my previous reply, I\u0027m aware that none of this is on the api and should not be directly accessed by users. However, for the standalone open-source library I still think it makes sense to encapsulate all marking decisions in the marker and keep the internal api simpler.\n\nHeap has knowledge of the GC phases (marking, sweeping) but it doesn\u0027t really need to know how each phase is implemented (atomic, incremental, concurrent). For the Heap it should suffice to have an api to start GC and to force GC finalization, but everything else can be hidden away. Knowing that marking is incremental or concurrent doesn\u0027t give the Heap anything.\n\nI think that a CollectGarbage \"god\" call would actually be a good way to encapsulate everything and make the heap indifferent to marking/sweeping specifics.\nIn my code, cppgc\u0027s CollectMarking and ForceFinalizeGarabageColllection are equivalent to v8\u0027s StartMarking and FinalizeGCIfRunning respectively. The v8 api seems redundant since CollectGarbage is covered by StartMarking and FinalizeGCIfRunning (based on the descriptions you gave) and I don\u0027t think we need a third call.\nI agree that CollectGarbage should not decide on it\u0027s own what type of marking it should do and when it should finish marking, which is why I suggested either a return value or having Marker call a method of Heap as needed (in both cases Marker is the one that makes the decision).\n(The call to StartMarking that finishes marking if needed is similar to our call to Sweeper::Start that finishes sweeping if sweeping is atomic.)\n\nAs for the configs, whether the default config is determined according to what the  platform provides, or a GC invoker creates a config based on the platform and passes it to CollectGarbage, the bottom line remains the same. Most users of the standalone library won\u0027t care whether marking/sweeping is incremental/concurrent or not (they care in terms of performance, not in terms of understanding what it means). As long as it\u0027s hidden from users I guess it\u0027s fine. If we\u0027re using a GC invoker (which I don\u0027t think we have right now, it sounds different than the heap growing strategy) and that sets the config, than I think we can drop the \"default\" config entirely.",
      "parentUuid": "010b5f02_fa7b4951",
      "range": {
        "startLine": 107,
        "startChar": 4,
        "endLine": 107,
        "endChar": 36
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b27b15a5_d307ff95",
        "filename": "src/heap/cppgc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 131,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-07-23T12:24:49Z",
      "side": 1,
      "message": "I think this can be avoided, see below.",
      "range": {
        "startLine": 131,
        "startChar": 11,
        "endLine": 131,
        "endChar": 56
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edf9a6dd_d5d78109",
        "filename": "src/heap/cppgc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 131,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-07-24T20:45:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b27b15a5_d307ff95",
      "range": {
        "startLine": 131,
        "startChar": 11,
        "endLine": 131,
        "endChar": 56
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1552c79b_557fe7d9",
        "filename": "src/heap/cppgc/marker.cc",
        "patchSetId": 8
      },
      "lineNbr": 130,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-07-23T12:24:49Z",
      "side": 1,
      "message": "Finalization tasks can only be posted for the stand-alone library. I would model that differently in having a task that knows that it doesn\u0027t have HeapBase but rather Heap, so that we can avoid the empty virtual call on the base class.\n\nI see two options:\n1. Split the task in a step and finalization task\n2. Keep the task but only use it for the stand-alone library. Unified heap would be marked through V8 and doesn\u0027t need separate scheduling.\n\n2. is probably okay as we anyways want to avoid the ping-pong between tasks for unified heap.",
      "range": {
        "startLine": 130,
        "startChar": 20,
        "endLine": 130,
        "endChar": 65
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86aa7786_7d37bb75",
        "filename": "src/heap/cppgc/marker.cc",
        "patchSetId": 8
      },
      "lineNbr": 130,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-07-24T20:45:42Z",
      "side": 1,
      "message": "I split it into 2 tasks.\n\nI initially wanted to avoid it because I didn\u0027t want to cast HeapBase to Heap. It could work since Marker is always initialized with Heap, but there were no guarantees that wouldn\u0027t break in the future. Then I realized that Marker could simply take Heap and UnifiedHeapMarker could take CppHeap (MarkerBase still takes HeapBase) and then it\u0027s safe to cast.",
      "parentUuid": "1552c79b_557fe7d9",
      "range": {
        "startLine": 130,
        "startChar": 20,
        "endLine": 130,
        "endChar": 65
      },
      "revId": "db2d21bfe27362b8d0b17b849cfd9395c93fbd8f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}