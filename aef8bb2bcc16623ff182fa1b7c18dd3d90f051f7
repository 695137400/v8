{
  "comments": [
    {
      "key": {
        "uuid": "c9fcd739_3650f4eb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Spelling, remove the extra \"e\" from \"assignments\"",
      "range": {
        "startLine": 7,
        "startChar": 69,
        "endLine": 7,
        "endChar": 81
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b91c640_cc9ed731",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 940,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Can you explain why this is necessary for the repro but not for examples that aren\u0027t also inside another pattern? E.g., the following prints \"42\" on trunk:\n\nprint(((y \u003d {foo: x} \u003d {foo: 42}) \u003d\u003e { return y.foo })())\n\nAlso, it seems like this is papering over a more worrisome issue: there are two FunctionStates for the same function when lazily parsing arrow functions. That makes me wonder if there are more bugs lurking, and if we can fix that instead of adding this extra call.",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33772265_42ba910e",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 940,
      "author": {
        "id": 1147189
      },
      "writtenOn": "2017-03-25T01:32:43Z",
      "side": 1,
      "message": "Although I\u0027m not very confident about this, I tend to agree with Adam.  I believe that the problem is caused by the FunctionState in ParseArrowFunctionLiteral (line parser-base.h:4179) being set up too early, before the rewriting of the destructuring assignments (line 4276).  I tried moving the line \"impl()-\u003eRewriteDestructuringAssignments();\" from 4276 to 4179 (just before the FunctionState), but it\u0027s not so easy.  This problem seems to be fixed but some other tests break.",
      "parentUuid": "1b91c640_cc9ed731",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b360ba68_e040da6e",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 13,
        "startChar": 47,
        "endLine": 13,
        "endChar": 57
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a07ec710_d26d950c",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Not sure it makes sense to pass judgment on destructuring assigment\u0027s syntax here. Maybe leave this out?",
      "range": {
        "startLine": 13,
        "startChar": 9,
        "endLine": 13,
        "endChar": 14
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fbbca44_2d6294d1",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "I can see how these would be useful during development, but do you think we need them in the test once it\u0027s checked in? I don\u0027t think we usually pair all asserts with an assert that they ran.",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f52284e_ed4f48fe",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Note that side_assignment_thing is on the global scope, so either you need to reset it to be sure that the code worked, or need to wrap each of these cases somehow (you could use a block with a let-declared some_side_assignment_thing, for example).",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ee63700_f44ca274",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Nit: typo (also, 80 chars)",
      "range": {
        "startLine": 36,
        "startChar": 33,
        "endLine": 36,
        "endChar": 43
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43e82d8d_88416475",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "I\u0027d like to understand this, too. It looks to me from a few examples that we for some reason treat arrow functions that have a concise body (just an expression) the same way as other expressions (they get eager-compiled), but for some reason we\u0027re treating those with a full body (surrounded by braces) differently.",
      "range": {
        "startLine": 37,
        "startChar": 13,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}