{
  "comments": [
    {
      "key": {
        "uuid": "c9fcd739_3650f4eb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Spelling, remove the extra \"e\" from \"assignments\"",
      "range": {
        "startLine": 7,
        "startChar": 69,
        "endLine": 7,
        "endChar": 81
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b91c640_cc9ed731",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 940,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Can you explain why this is necessary for the repro but not for examples that aren\u0027t also inside another pattern? E.g., the following prints \"42\" on trunk:\n\nprint(((y \u003d {foo: x} \u003d {foo: 42}) \u003d\u003e { return y.foo })())\n\nAlso, it seems like this is papering over a more worrisome issue: there are two FunctionStates for the same function when lazily parsing arrow functions. That makes me wonder if there are more bugs lurking, and if we can fix that instead of adding this extra call.",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33772265_42ba910e",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 940,
      "author": {
        "id": 1147189
      },
      "writtenOn": "2017-03-25T01:32:43Z",
      "side": 1,
      "message": "Although I\u0027m not very confident about this, I tend to agree with Adam.  I believe that the problem is caused by the FunctionState in ParseArrowFunctionLiteral (line parser-base.h:4179) being set up too early, before the rewriting of the destructuring assignments (line 4276).  I tried moving the line \"impl()-\u003eRewriteDestructuringAssignments();\" from 4276 to 4179 (just before the FunctionState), but it\u0027s not so easy.  This problem seems to be fixed but some other tests break.",
      "parentUuid": "1b91c640_cc9ed731",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbac1a70_13b14bce",
        "filename": "src/parsing/parser.cc",
        "patchSetId": 1
      },
      "lineNbr": 940,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "Adamk: I think that\u0027s because in your case, the \u003d {Â } is a default parameter for a function and the ParameterInitializerThing kicks in... but I need to investigate that a bit more - I ran out of time today.\n\nHowever, I think the \"two functionstates\" situation emulates the eager case pretty well - there we also parse the params in a different functionstate too.\n\nNikolaos: The \"problem\" is that the destructuring assignments are in two different functionstates. But that\u0027s the case for eager arrow functions too: the destructuring assignments from the params are in the parent functionstate and the destructuring assignments from the body are in the function\u0027s functionstate. So it\u0027s not enough to just move the RewriteDestructuringAssignments call around.\n\nHowever, when eager parsing arrow funcs, the destructuring assignments are also in two functionstates too. It works because we eventually call RewriteDestructuringAssignments for both.",
      "parentUuid": "33772265_42ba910e",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b360ba68_e040da6e",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 13,
        "startChar": 47,
        "endLine": 13,
        "endChar": 57
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a07ec710_d26d950c",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Not sure it makes sense to pass judgment on destructuring assigment\u0027s syntax here. Maybe leave this out?",
      "range": {
        "startLine": 13,
        "startChar": 9,
        "endLine": 13,
        "endChar": 14
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f20eb53a_49d85728",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b360ba68_e040da6e",
      "range": {
        "startLine": 13,
        "startChar": 47,
        "endLine": 13,
        "endChar": 57
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "32858bf3_52b87c82",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a07ec710_d26d950c",
      "range": {
        "startLine": 13,
        "startChar": 9,
        "endLine": 13,
        "endChar": 14
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8fbbca44_2d6294d1",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "I can see how these would be useful during development, but do you think we need them in the test once it\u0027s checked in? I don\u0027t think we usually pair all asserts with an assert that they ran.",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "393731fe_32721e05",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "I\u0027m just so skeptical towards tests and here it\u0027s easy to accidentally forget to call the function...",
      "parentUuid": "8fbbca44_2d6294d1",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f52284e_ed4f48fe",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Note that side_assignment_thing is on the global scope, so either you need to reset it to be sure that the code worked, or need to wrap each of these cases somehow (you could use a block with a let-declared some_side_assignment_thing, for example).",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9894b17_c4484723",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 30,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "Ah, right, I had overlooked that. Nullified it in the global scope...",
      "parentUuid": "5f52284e_ed4f48fe",
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ee63700_f44ca274",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "Nit: typo (also, 80 chars)",
      "range": {
        "startLine": 36,
        "startChar": 33,
        "endLine": 36,
        "endChar": 43
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9631d628_2b155f2e",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7ee63700_f44ca274",
      "range": {
        "startLine": 36,
        "startChar": 33,
        "endLine": 36,
        "endChar": 43
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "43e82d8d_88416475",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1115851
      },
      "writtenOn": "2017-03-24T21:20:28Z",
      "side": 1,
      "message": "I\u0027d like to understand this, too. It looks to me from a few examples that we for some reason treat arrow functions that have a concise body (just an expression) the same way as other expressions (they get eager-compiled), but for some reason we\u0027re treating those with a full body (surrounded by braces) differently.",
      "range": {
        "startLine": 37,
        "startChar": 13,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "79d34e39_3e8d9716",
        "filename": "test/mjsunit/regress/regress-704811.js",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1115961
      },
      "writtenOn": "2017-03-27T14:49:40Z",
      "side": 1,
      "message": "Arrow functions with a concise body are never lazy. (Doesn\u0027t really make sense to parse one expression lazily.) But non-concise arrow functions can be lazy. The logic is in ParserBase::ParseArrowFunctionLiteral.\n\n\n(Not sure if I understood what you were asking...)",
      "parentUuid": "43e82d8d_88416475",
      "range": {
        "startLine": 37,
        "startChar": 13,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "aef8bb2bcc16623ff182fa1b7c18dd3d90f051f7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}