{
  "comments": [
    {
      "key": {
        "uuid": "9c3db0bb_e1849c9e",
        "filename": "src/builtins/builtins.cc",
        "patchSetId": 8
      },
      "lineNbr": 326,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2018-08-24T14:12:11Z",
      "side": 1,
      "message": "I didn\u0027t notice this earlier, but the BUILTIN_LIST_BYTECODE_HANDLERS should be a flat list of all builtins, i.e. one entry per bytecode per operand scale. We rely on this assumption all over the place and manually expanding BCH entries at each use feels wrong. \n\nI do realize that it\u0027s a bit inconvenient since the BYTECODE_LIST doesn\u0027t have this format and AFAICT there\u0027s no easy way to do this with macro magic. Maybe we could generate handler lists during the build?\n\nWdyt?",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bb8d85f_4b00ff0b",
        "filename": "src/builtins/builtins.cc",
        "patchSetId": 8
      },
      "lineNbr": 326,
      "author": {
        "id": 1204345
      },
      "writtenOn": "2018-08-24T15:01:01Z",
      "side": 1,
      "message": "Bear in mind that BUILTIN_LIST always needs to be supplied with a BCH macro which is responsible for doing the expansion.\n\nI should probably update https://cs.chromium.org/chromium/src/v8/src/builtins/builtins-definitions.h?q\u003dbuiltins-defini\u0026sq\u003dpackage:chromium\u0026l\u003d28 to say this.\n\nIf we wanted to go down the header file generation route, we could eliminate a lot of list macros across the code base, but I was told this approach was not popular...",
      "parentUuid": "9c3db0bb_e1849c9e",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75729f05_2fe46b82",
        "filename": "src/builtins/builtins.cc",
        "patchSetId": 8
      },
      "lineNbr": 326,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2018-08-24T15:33:34Z",
      "side": 1,
      "message": "Would a second, dedicated handler list be an option? The list could be expanded for all widths, and could omit bytecodes/scale combinations without a handler.",
      "parentUuid": "9bb8d85f_4b00ff0b",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "258e5527_f7d943ce",
        "filename": "src/builtins/builtins.cc",
        "patchSetId": 8
      },
      "lineNbr": 326,
      "author": {
        "id": 1204345
      },
      "writtenOn": "2018-08-24T16:06:28Z",
      "side": 1,
      "message": "What would this second handler list be used for? I think it would just create confusion. You couldn\u0027t easily go back and forth between the two lists for instance (without an expensive mapping).",
      "parentUuid": "75729f05_2fe46b82",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "189d98ba_1f88d4e2",
        "filename": "src/builtins/setup-builtins-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 255,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2018-08-24T14:12:11Z",
      "side": 1,
      "message": "Could we initialize with kIllegal instead to avoid snapshotting placeholder objects?",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4aa3db01_c8f18a33",
        "filename": "src/builtins/setup-builtins-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 255,
      "author": {
        "id": 1204345
      },
      "writtenOn": "2018-08-24T15:01:01Z",
      "side": 1,
      "message": "Two problems:\nFirst AddBuiltin will DCHECK that code-\u003ebuiltin_index \u003d\u003d index\nSecondly the BuiltinSerializer expects that every object in the builtins table is unique, I think. So when it sees one again it complains that LookupReference() returns something. I had a play with trying to work around this, by calling SerializeBuiltinReference, but ultimately couldn\u0027t get it to work.\n\nHow about I add a TODO here to revisit this?",
      "parentUuid": "189d98ba_1f88d4e2",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e42c6f21_b80cc323",
        "filename": "src/builtins/setup-builtins-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 255,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2018-08-24T15:33:34Z",
      "side": 1,
      "message": "I see, a TODO sounds good. For the builtins list / table, it\u0027d be nice to have each entry be a real builtin and not have slots taken up by unused dummy objects.",
      "parentUuid": "4aa3db01_c8f18a33",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "756ff422_76cfbcc6",
        "filename": "src/builtins/setup-builtins-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 255,
      "author": {
        "id": 1204345
      },
      "writtenOn": "2018-08-24T16:06:28Z",
      "side": 1,
      "message": "TODO added.\n\nI don\u0027t really see the utility of a builtins list without dummy objects. Sure you save a little memory (but not much), but at the cost of having to map back and forth.\n\nPossibly it would be better to just retain the dispatch table as the source of truth, but that has its own issues...",
      "parentUuid": "e42c6f21_b80cc323",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42f7b4d0_c61811fb",
        "filename": "src/builtins/setup-builtins-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 255,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2018-08-28T08:49:49Z",
      "side": 1,
      "message": "What I\u0027m concerned about is that the new BCH builtins change two properties of the builtins list:\n\n 1. The BUILTIN_LIST is flat and can be passed e.g. \n\n   #define CASE(Name, ...) case k##Name:\n\n    helpers which will be applied once to each builtin.\n\n 2. Each builtin ID is a real builtin. We don\u0027t expose placeholder code objects created during mksnapshot. At the moment we\u0027d have 64 such empty pseudo-builtins.\n\nThe first point is mainly a usability nit - if someone sees the BUILTIN_LIST for the first time, they will not expect it to be a nested list construct.\n\nThe second is the bigger issue to me. It wastes space in the builtins table, in the snapshot, in .text, and it generates unused code objects and associated metadata. In general it feels weird to have unused builtins.\n\nMy idea would be a new flat BYTECODE_HANDLER_LIST(V) that explicitly lists all real handlers. The list basically associates a bytecode with an operand scale. It would be used for handler setup in the builtins table.\n\nEverything else (dispatch table setup, dispatch logic) remains unmodified. The only time a mapping is needed is during dispatch table setup, and that can be done through macro magic.\n\nThe list could be something like this:\n\n  #define ONLY_SINGLE(V, Name) V(Name, kSingle)\n  \n  #define ALL_SCALES(V, Name)           \\\n    V(Name##Handle, Name, kSingle)      \\\n    V(Name##WideHandler, Name, kDouble) \\\n    V(Name##ExtraWideHandler, Name, kQuadruple)\n  \n  #define BYTECODE_HANDLER_LIST(V) \\\n    ALL_SCALES(Wide)               \\\n    ONLY_SINGLE(ExtraWide)         \\\n    /* ... */\n\nYes, it\u0027s one extra spot to touch when modifying a bytecode, but otherwise I think it\u0027s a cleaner solution for handler builtins. Wdyt?",
      "parentUuid": "756ff422_76cfbcc6",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ff8f26a_5c853a5d",
        "filename": "src/builtins/setup-builtins-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 255,
      "author": {
        "id": 1002763
      },
      "writtenOn": "2018-08-28T09:32:18Z",
      "side": 1,
      "message": "I talked with Dan a bit about this when he was working on this, I\u0027d really prefer not to have a seperate list which encodes whether a bytecode is scalable or not. Currently that logic is encoded in the bytecode operands (if any of them are scalable), and I would prefer to avoid weird errors if someone removes or adds an operand but doesn\u0027t move it from the ONLY_SINGLE to ALL_SCALES list.\n\nRegarding the 64 empty builtins - currently we have empty placeholder objects but I think the plan is to avoid this (and either have them nulled out or point to the same invalid bytecode handler) - as such this is only wasting 64 words, and looking forward, once all builtins are embedded we could have the builtin table eventually point to raw instruction streams, at which point it could be used directly as the interpreter dispatch table if we allow these gaps, which would end up saving ~600 words.",
      "parentUuid": "42f7b4d0_c61811fb",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0b1bc9de_f79db417",
        "filename": "src/interpreter/setup-interpreter-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 87,
      "author": {
        "id": 1162439
      },
      "writtenOn": "2018-08-24T14:12:11Z",
      "side": 1,
      "message": "Nit: We have Builtins::kNoBuiltinId for this purpose. Just fyi. Not important here since I assume this will go away in the follow-up.",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8c74c4e_f9dc7404",
        "filename": "src/interpreter/setup-interpreter-internal.cc",
        "patchSetId": 8
      },
      "lineNbr": 87,
      "author": {
        "id": 1204345
      },
      "writtenOn": "2018-08-24T15:01:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0b1bc9de_f79db417",
      "revId": "365b89ab1e10581ad0484d7d3d2c6684f0e633ba",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}