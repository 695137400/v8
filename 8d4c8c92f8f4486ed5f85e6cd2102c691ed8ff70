{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "19180d34_3b776288",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-13T14:26:26Z",
      "side": 1,
      "message": "It seems the node CI doesn\u0027t manage to build addons: see end of https://logs.chromium.org/logs/node-ci/buildbucket/cr-buildbucket/8748068638469800017/+/u/build/compile/stdout.  No idea why as it doesn\u0027t seem to expose the logs!",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "643cbefc_ce35aed1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1231371
      },
      "writtenOn": "2024-05-14T06:28:39Z",
      "side": 1,
      "message": "Drive-by comment: Incase it helps, addon build step happens via the target https://chromium.googlesource.com/v8/node-ci/+/refs/heads/main/node_tests/BUILD.gn#104 and it relies on node binary built from this change https://github.com/v8/node/blob/b5a7a8ad3b09405e5523f8da35bc3f393db79dcc/tools/build_addons.py#L30. There is a crash on startup of the binary. You can repro the issue by setting up https://chromium.googlesource.com/v8/node-ci/+/refs/heads/main#checking-out-source and replacing v8 checkout with this change, followed by\n\n```\n\u003e ./tools/gn-gen.py out/Release \n\u003e ninja -C out/Release node_tests:node_test_addons_build\n```",
      "parentUuid": "19180d34_3b776288",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc09ab1c_40609bcd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-17T13:23:01Z",
      "side": 1,
      "message": "Firstly -- thank you Deepak !!!  A very helpful hint.  I can reproduce this locally now.  The issue is basic, that calling toString on a node buffer fails somewhere, causing a segfault.  Probably has to do with one-byte external strings.\n\nStill figuring out how to get a debug build; passing --debug to gn-gen.py does residualize is_debug\u003dtrue but somehow that doesn\u0027t translate to the binaries.  Will keep at it.",
      "parentUuid": "643cbefc_ce35aed1",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24db7b37_5f6c6a3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-28T14:28:23Z",
      "side": 1,
      "message": "Poking at this again: the node failure manifests itself as an EPT entry having the wrong type.  The segfault occurs here: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/builtins/x64/builtins-x64.cc;l\u003d4523, which loads the callback for a FunctionTemplateInfo.  Still poking to find how this happened.",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ec183dc_e81c8358",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-29T14:47:47Z",
      "side": 1,
      "message": "Somehow the EmbedderDataArray of node\u0027s NativeContext is corrupted when it is deserialized, containing non-null ExternalPointerHandles in it.  Later writes to those context fields during node boot end up overwriting the handle that was correctly allocated when deserializing the FunctionTemplateInfo instance.  Still poking; very perplexing.",
      "parentUuid": "24db7b37_5f6c6a3d",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cfc2b28d_c921ac80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-29T14:47:47Z",
      "side": 1,
      "message": "It would seem that the problem is that the",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5de84a08_596938f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-30T08:47:45Z",
      "side": 1,
      "message": "Funny.  So what happens is that the `NativeContext` gets deserialized, along with its `EmbedderDataArray`, which has 40 slots.  Each slot is `EmbedderDataSlot`, with two 32-bit words.  There is special post-processing for a context\u0027s `EmbedderDataArray` in `context-deserializer.cc` but that doesn\u0027t occur in this case because Node doesn\u0027t yet support custom context serialization/deserialization.  Each slot in the array can have a heap object or an external pointer.  Those external pointer slots are lazily initialized, so the first write to them should allocate an EPT slot.  However the bug is that the `EmbedderDataArray` is getting deserialized with non-null EPT handles!\n\nThe bug occurs because in the serializer we skip over `ExternalPointerSlot` values for `EmbedderDataArray` and other types: https://source.chromium.org/chromium/chromium/src/+/main:v8/src/snapshot/serializer.cc;l\u003d1156\n\nThis causes the `bytes_processed_so_far_` to not advance when visiting the EPT slot, indicating these values will be filled in by copying, via `OutputRawData`.  But of course this ends up copying a raw EPT handle from the serializer to the deserializer, leading to aliasing of the EPT handle and eventual stompling.\n\nThe way this works for other data types is that we null out the external pointer fields before writing.  Perhaps that is what needs to happen with embedder fields on the context as well.",
      "parentUuid": "cfc2b28d_c921ac80",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "692b45b6_d215ab83",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1118571
      },
      "writtenOn": "2024-05-30T08:52:33Z",
      "side": 1,
      "message": "I should add that this doesn\u0027t happen in the existing +pc,-sandbox configuration because serializing a raw pointer does not appear to be a problem, if that pointer is always overwritten after deserialization.  The problem is that if we serialize a raw EPT handle, it\u0027s an indirect write that aliases a storage location owned by something else.",
      "parentUuid": "5de84a08_596938f1",
      "revId": "8d4c8c92f8f4486ed5f85e6cd2102c691ed8ff70",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}