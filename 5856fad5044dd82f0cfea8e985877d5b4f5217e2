{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "fbdcf143_e875ca31",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-03-02T13:59:29Z",
      "side": 1,
      "message": "ptal.\nUnfortunately we cannot enforce this with a DCHECK since the owning heap (and its spaces/pages) maybe be gone if that heap terminates.",
      "revId": "5856fad5044dd82f0cfea8e985877d5b4f5217e2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e6225ef_13c76aac",
        "filename": "include/cppgc/cross-thread-persistent.h",
        "patchSetId": 1
      },
      "lineNbr": 442,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-03-02T14:38:39Z",
      "side": 1,
      "message": "This really holds for all managed pointers that we have so far (BasicMember, BasicPersistent).\n\nI think we\u0027ve said so far: Anything that wants compaction is a special case and not the other way round.",
      "range": {
        "startLine": 442,
        "startChar": 5,
        "endLine": 442,
        "endChar": 9
      },
      "revId": "5856fad5044dd82f0cfea8e985877d5b4f5217e2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b2eba7d_1c210dd3",
        "filename": "include/cppgc/cross-thread-persistent.h",
        "patchSetId": 1
      },
      "lineNbr": 442,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-03-02T14:52:02Z",
      "side": 1,
      "message": "Indeed, members and persistents don\u0027t prevent moving, but that won\u0027t be concurrent.\n\nAssume you\u0027ve registered the slots as movable references and generally did everything correctly. With members and persistents you should still be safe to use the reference because you know that if you could move the object than it wasn\u0027t being used during the GC (i.e. no stack).\nWith CT(W)P that doesn\u0027t hold. You could be accessing the object and half way through another thread moves it. I think that\u0027s only possible with CT(W)Ps, and thus worth an extra warning. wdyt?",
      "parentUuid": "3e6225ef_13c76aac",
      "range": {
        "startLine": 442,
        "startChar": 5,
        "endLine": 442,
        "endChar": 9
      },
      "revId": "5856fad5044dd82f0cfea8e985877d5b4f5217e2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "723ef3da_8feb6ee8",
        "filename": "include/cppgc/cross-thread-persistent.h",
        "patchSetId": 1
      },
      "lineNbr": 442,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2022-03-02T15:04:58Z",
      "side": 1,
      "message": "`Member\u003c\u003e` doesn\u0027t automatically register a slot as movable reference but that happens manually in all collections (that don\u0027t even use a Member). So, just having `Member\u003cFoo\u003e` where `Foo` moves breaks the same way as `CTP`. With `CTP` you have additional concurrency on top (which is what you described).\n\nI am not sure it causes more confusion that it helps explaining.\n\nFeel free to land if you think it helps.",
      "parentUuid": "1b2eba7d_1c210dd3",
      "range": {
        "startLine": 442,
        "startChar": 5,
        "endLine": 442,
        "endChar": 9
      },
      "revId": "5856fad5044dd82f0cfea8e985877d5b4f5217e2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5daef9eb_cf0a5928",
        "filename": "include/cppgc/cross-thread-persistent.h",
        "patchSetId": 1
      },
      "lineNbr": 442,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2022-03-02T15:42:11Z",
      "side": 1,
      "message": "I think it\u0027s worth having this discussion.\n\nI didn\u0027t mean that Member registers the slot as movable. I meant that in the scenario I described, you would explicitly register the slot as movable, trace everything, etc... (i.e. \"you did everything correctly\"). Then compaction happens.\nIf your slot is a Member, you\u0027re safe as you know you can\u0027t access the object while it is compacted. Thus I believe we could support atomic compaction of members in the future.\n\nMy point was that with CTP you don\u0027t have these guarantees. Even if you did everything right, and registered the CTP slot as movable, compaction can happen concurrently to accessing the object and you are never safe. I don\u0027t think we could ever support compaction of objects in CTP (without forcing all threads into a safepoint or something like that).\n\nDid I manage to clarify why I think the cases of Member/Persistent and CTP are not equivalent?\nDo you think making this distinction is not beneficial?\nIs the problem the phrasing or the content?",
      "parentUuid": "723ef3da_8feb6ee8",
      "range": {
        "startLine": 442,
        "startChar": 5,
        "endLine": 442,
        "endChar": 9
      },
      "revId": "5856fad5044dd82f0cfea8e985877d5b4f5217e2",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}