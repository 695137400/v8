{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e92d7755_a36e4d89",
        "filename": "/COMMIT_MSG",
        "patchSetId": 20
      },
      "lineNbr": 27,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2023-07-04T13:56:35Z",
      "side": 1,
      "message": "Just\nBug: chromium:1204540, v8:9343",
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9340654_dbbde579",
        "filename": "/COMMIT_MSG",
        "patchSetId": 20
      },
      "lineNbr": 27,
      "author": {
        "id": 1559107
      },
      "writtenOn": "2023-07-06T09:56:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e92d7755_a36e4d89",
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c5d815ea_f937fd12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 20
      },
      "lineNbr": 0,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2023-07-04T13:56:35Z",
      "side": 1,
      "message": "overall looks good modulo `kIgnoreSlackTracking`",
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c4ac2cd_d440747c",
        "filename": "src/ic/accessor-assembler.cc",
        "patchSetId": 20
      },
      "lineNbr": 5139,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2023-07-04T13:56:35Z",
      "side": 1,
      "message": "I\u0027m afraid there might be a window when the slack tracking is not over yet and thus not filling the object slack with one-pointer fillers might confuse GC once the slack tracking will be finished (GC will not expect to see undefined values after this object shrinks).\n\nWe should either use `kWithSlackTracking` version or ensure that the `result_map` is guaranteed to have a completed slack tracking (presumably during handler creation) and use `kNoSlackTracking`.\n\nWhile we are here... note that `Factory::ObjectLiteralMapFromCache()` currently \"inherits\" slack tracking state from `object_function()-\u003einitial_map()` even when it creates new maps. We might want to explicitly finish slack tracking for them or start it for newly created maps.",
      "range": {
        "startLine": 5139,
        "startChar": 31,
        "endLine": 5139,
        "endChar": 70
      },
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d3ab0b8_d49453e7",
        "filename": "src/ic/accessor-assembler.cc",
        "patchSetId": 20
      },
      "lineNbr": 5139,
      "author": {
        "id": 1559107
      },
      "writtenOn": "2023-07-06T09:56:10Z",
      "side": 1,
      "message": "uhm, awesome comment! Agreed, the whole approach here was kinda questionable.\n\nI think there are two cases:\n\n1. we clone objects and the clones have a root map. -\u003e we can just normally participate in the slack tracking.\n2. we clone objects and reuse the source map 1:1. this mostly (only?) happens for constructors. -\u003e here we can\u0027t do slack tracking as we don\u0027t start with a root map. probably the best approach is to eagerly finish slack tracking and decide on a final size. if not, we would have to pick a different (root) map...\n\nI now switched to this approach, wdyt?",
      "parentUuid": "6c4ac2cd_d440747c",
      "range": {
        "startLine": 5139,
        "startChar": 31,
        "endLine": 5139,
        "endChar": 70
      },
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4033fce7_cf19b83d",
        "filename": "src/ic/accessor-assembler.cc",
        "patchSetId": 20
      },
      "lineNbr": 5139,
      "author": {
        "id": 1559107
      },
      "writtenOn": "2023-07-06T10:01:08Z",
      "side": 1,
      "message": "I guess the non-root case can also happen for object literals (and not just constructors). it might be bad to prematurely end slack tracking. maybe it would be better to not re-use the source map if it is still slack tracking and instead use one from the map cache?",
      "parentUuid": "1d3ab0b8_d49453e7",
      "range": {
        "startLine": 5139,
        "startChar": 31,
        "endLine": 5139,
        "endChar": 70
      },
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4dad7760_82fdc55e",
        "filename": "src/ic/accessor-assembler.cc",
        "patchSetId": 20
      },
      "lineNbr": 5139,
      "author": {
        "id": 1183889
      },
      "writtenOn": "2023-07-06T11:41:55Z",
      "side": 1,
      "message": "Ah, right! It\u0027s even more complicated than I thought.\n\nThere are the following options to address issues with (2):\na) ensure that the `result_map` has completed slack tracking (and then you can use `kNoSlackTracking` mode here),\nb) respect the slack tracking state of `result_map` but don\u0027t perform a slack tracking step,\nc) respect the slack tracking state of `result_map` and perform a slack tracking step on the `result_map`\u0027s root map which is either\n  c.1) found dynamically by walking back the `result_map`\u0027s transition tree or\n  c.2) cached in the CloneIC handler in addition to `result_map`.\n\nFor the case (1) where the `result_map` is the root map any of the options above should work fine.\n\n\n(a) is the easiest approach, but I agree that it seems like an overkill which will affect things outside CloneIC.\n(b) easy enough to support, the only drawback is that there might be nobody to complete slack tracking for maps taken from the MapCache. But in this case we can ensure that the all the maps created in `Factory::ObjectLiteralMapFromCache()` has a finished slack tracking.\n(c) most precise option but messy.\n\nI\u0027m leaning towards (b) + `Factory::ObjectLiteralMapFromCache()` fix for this CL as it\u0027s easy enough and doesn\u0027t affect things outside CloneIC. And later we can consider (c) based on CloneIC usage stats on the benchmarks.",
      "parentUuid": "1d3ab0b8_d49453e7",
      "range": {
        "startLine": 5139,
        "startChar": 31,
        "endLine": 5139,
        "endChar": 70
      },
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a18664d0_14277f33",
        "filename": "src/ic/accessor-assembler.cc",
        "patchSetId": 20
      },
      "lineNbr": 5139,
      "author": {
        "id": 1559107
      },
      "writtenOn": "2023-07-06T13:43:52Z",
      "side": 1,
      "message": "ok, as discussed offline this goes with your approach (b) and the maps from the cache are already finished slack tracking.",
      "parentUuid": "4dad7760_82fdc55e",
      "range": {
        "startLine": 5139,
        "startChar": 31,
        "endLine": 5139,
        "endChar": 70
      },
      "revId": "7c243b40d8eb7dc99676f0b1067709b7bfa754bc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}