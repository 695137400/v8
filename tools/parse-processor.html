<html>
<!--
Copyright 2016 the V8 project authors. All rights reserved.  Use of this source
code is governed by a BSD-style license that can be found in the LICENSE file.
-->

<head>
<style>
  html {
    font-family: monospace;
  }

  .parse {
    background-color: red;
    border: 1px red solid;
  }

  .preparse {
    background-color: orange;
    border: 1px orange solid;
  }

  .resolution {
    background-color: green;
    border: 1px green solid;
  }

  .execution {
    background-color: black;
    border-left: 2px black solid;
    z-index: -1;
  }

  .script {
    margin-top: 1em;
    overflow: visible;
    clear: both;
      border-top: 2px black dotted;
  }
  .script h3 {
    height: 20px;
    margin-bottom: 0.5em;
    white-space: nowrap;
  }

  .script-details {
    float: left;
  }

  .chart {
    float: left;
    margin-right: 2em;
  }

  .funktion-list {
    float: left;
    height: 400px;
  }

  .funktion-list > ul {
    height: 80%;
    overflow-y: scroll;
  }


  .funktion {
  }

</style>
<script src="./splaytree.js" type="text/javascript"></script>
<script src="./codemap.js" type="text/javascript"></script>
<script src="./csvparser.js" type="text/javascript"></script>
<script src="./consarray.js" type="text/javascript"></script>
<script src="./profile.js" type="text/javascript"></script>
<script src="./profile_view.js" type="text/javascript"></script>
<script src="./logreader.js" type="text/javascript"></script>
<script src="./parse-processor.js" type="text/javascript"></script>
<script src="./SourceMap.js" type="text/javascript"></script>
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script type="text/javascript">
"use strict"
google.charts.load('current', {packages: ['corechart']});


function $(query) {
  return document.querySelector(query);
}


function loadFile() {
  let files = $('#uploadInput').files;

  let file = files[0];
  let reader = new FileReader();

  reader.onload = function(evt) {
    const kTimerName = 'parse log file';
    console.time(kTimerName);
    let parseProcessor = new ParseProcessor();
    parseProcessor.processString(this.result);
    console.timeEnd(kTimerName);
    renderParseResults(parseProcessor);
    document.parseProcessor = parseProcessor;
  }
  reader.readAsText(file);
}

function escapeHtml(unsafe) {
  if (!unsafe) return "";
  return unsafe.toString()
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function handleOnLoad() {
  document.querySelector("#uploadInput").focus();
}

function createNode(tag, classNames) {
  let node = document.createElement(tag);
  if (classNames) {
    if (Array.isArray(classNames)) {
      node.classList.add(...classNames);
    } else {
      node.className = classNames;
    }
  }
  return node;
}

function div() {
  return createNode('div', ...arguments);
}

function h1(string) {
  let node = createNode('h1');
  node.appendChild(text(string));
  return node;
}

function h3(string, ...args) {
  let node = createNode('h3', ...args);
  if (string) node.appendChild(text(string));
  return node;
}

function a(href, string, ...args) {
  let link = createNode('a', ...args);
  link.href = href;
  if (string) link.appendChild(text(string));
  return link;
}

function text(string) {
  return document.createTextNode(string);
}

function delay(t) {
   return new Promise(function(resolve) { 
       setTimeout(resolve, t)
   });
}

function renderParseResults(parseProcessor) {
  let result = $('#result');
  // clear out all existing result pages;
  result.innerHTML = '';
  const start = parseProcessor.firstEvent;
  const end = parseProcessor.lastEvent;

  renderScript(result, parseProcessor.totalScript, start, end, false);
  // Build up the graphs lazily to keep the page responsive.
  parseProcessor.scripts.forEach(script =>
     delay(1).then(() => renderScript(result, script, start, end, true)));
  console.log('starting to add graphs');
}

const kTimeFactor = 10;
const kHeight = 20;
const kFunktionTopOffset = 50;

function renderScript(result, script, start, end, lazyGraph) {
  if (script.isEmpty() || script.lastParseEvent == 0) return;

  let scriptDiv = div('script');
  scriptDiv.script = script;

  let scriptTitle = h3();
  if (script.file) scriptTitle.appendChild(a(script.file, script.file));
  scriptTitle.appendChild(text(' id=' + script.id));
  scriptDiv.appendChild(scriptTitle);
  let summary = createNode('pre', 'script-details');
  summary.appendChild(text(script.summary));
  scriptDiv.appendChild(summary);

  if (!lazyGraph) appendGraph(script, scriptDiv, start, end);
  result.appendChild(scriptDiv);
}

const kMaxX = 1000;
const kMaxY = 200;
const kSecondsToMillis = 1000;
const kMaxTime = 30 * kSecondsToMillis;
const kTimeIncrement = 25;
const kLabelHeight = 15;
const kLabelMargin = 20;
const kGraphHeight = kMaxY - kLabelHeight;
const series = [
    ['firstParseEvent', 'Any Parse Event'],
    ['parse', 'Parsing'],
    ['preparse', 'Preparsing'],
    ['resolution', 'Preparsing with Var. Resolution'],
    ['lazyCompile', 'Lazy Compilation'],
    ['execution', 'First Execution'],
];


function appendGraph(script, parentNode, start, end) {
  const timerLabel = 'graph script=' + script.id;
  // TODO(cbruni): add support for network events

  console.time(timerLabel);
  let data = new google.visualization.DataTable();
  data.addColumn('number', 'Time');
  series.forEach(each => data.addColumn('number', each[1]));
  let metrics = series.map(each => each[0]);
  const maxTime = Math.min(kMaxTime, end);
  data.addRows(
      script.getAccumulatedTimeMetrics(metrics, 0, maxTime, kTimeIncrement));

  let options = {
    // title: 'Parse Metrics',
    // curveType: 'function',
    legend: { position: 'right' },
    explorer: {},
    hAxis: {
      format: '#,###.#s'
    },
    vAxis: { 
      title: 'Bytes Processed',
      format: 'short',
    },
    height: 400,
    width: 1000,
    chartArea: {left: '10%', top: '3%', width: "70%", height: "90%" },
    // The first series should be a area chart (total bytes touched),
    series: { 
      0: {type: 'area'}
    },
    // everthing else is a line.
    seriesType: 'line'
  };
  let graphNode = createNode('div', 'chart');
  let listNode = createNode('div', 'funktion-list');
  parentNode.appendChild(graphNode);
  parentNode.appendChild(listNode);
  let chart = new google.visualization.ComboChart(graphNode);
  google.visualization.events.addListener(chart, 'select', 
      () => selectGraphPointHandler(chart, data, script, parentNode));
  chart.draw(data, options);
  console.timeEnd(timerLabel);
}


function selectGraphPointHandler(chart, data, script, parentNode) {
  let selection = chart.getSelection();
  if (selection.length <= 0) return;
  // Display a list of funktions with events at the given time.
  let {row, column} = selection[0];
  if (row === null|| column === null) return;
  let name = series[column-1][0];
  let time = data.getValue(row, 0);
  let funktions = script.getFunktionsAtTime(
        time * kSecondsToMillis, 2 * kTimeIncrement, name);
  let oldList = parentNode.querySelector('.funktion-list');
  parentNode.replaceChild(createFunktionList(time, funktions), oldList);
}

function createFunktionList(time, funktions) {
  let container = createNode('div', 'funktion-list');
  container.appendChild(h3('Functions changed at ' + time + 's: ' + funktions.length));
  let listNode = createNode('ul');
  funktions.forEach(funktion => {
    let node = createNode('li', 'funktion');
    node.funktion = funktion;
    node.appendChild(text(funktion.toString()));
    listNode.appendChild(node);
  });
  container.appendChild(listNode);
  return container;
}


</script>
</head>

<body onload="handleOnLoad()">
  <h1>BEHOLD, THIS IS PARSEROR!</h1>

  <h2>Usage</h2> Run your script with <code>--trace-parse</code> and/or <code>--trace-preparse</code> and upload <code>v8.log</code> on this page:<br/>
  <code>/path/to/d8 --trace-parse --trace-preparse --log your_script.js</code>

  <h2>Data</h2>
  <form name="fileForm">
    <p>
      <input id="uploadInput" type="file" name="files" onchange="loadFile();"> trace entries: <span id="count">0</span>
    </p>
  </form>

  <h2>Result</h2>
  <div id="result">
  </div>
</body>

</html>
