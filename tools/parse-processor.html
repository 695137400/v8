<html>
<!--
Copyright 2016 the V8 project authors. All rights reserved.  Use of this source
code is governed by a BSD-style license that can be found in the LICENSE file.
-->

<head>
<style>
  html {
    font-family: monospace;
  }

  .funktion {
    height: 18px;
    position: absolute;
    text-align: center;
    overflow: hidden;
  }

  .parse {
    background-color: red;
    border: 1px red solid;
  }

  .preparse {
    background-color: orange;
    border: 1px orange solid;
  }

  .resolution {
    background-color: green;
    border: 1px green solid;
  }

  .execution {
    background-color: black;
    border-left: 2px black solid;
    z-index: -1;
  }

  .script {
    margin-top: 1em;
    overflow: visible;
  }
  .script h3 {
    height: 20px;
    margin-bottom: 0.5em;
    white-space: nowrap;
  }

</style>
<script src="./splaytree.js" type="text/javascript"></script>
<script src="./codemap.js" type="text/javascript"></script>
<script src="./csvparser.js" type="text/javascript"></script>
<script src="./consarray.js" type="text/javascript"></script>
<script src="./profile.js" type="text/javascript"></script>
<script src="./profile_view.js" type="text/javascript"></script>
<script src="./logreader.js" type="text/javascript"></script>
<script src="./parse-processor.js" type="text/javascript"></script>
<script src="./SourceMap.js" type="text/javascript"></script>

<script>
"use strict"

function $(query) {
  return document.querySelector(query);
}


function loadFile() {
  let files = $('#uploadInput').files;

  let file = files[0];
  let reader = new FileReader();

  reader.onload = function(evt) {
    const kTimerName = 'parse log file';
    console.time(kTimerName);
    let parseProcessor = new ParseProcessor();
    parseProcessor.processString(this.result);
    console.timeEnd(kTimerName);
    renderParseResults(parseProcessor);
  }
  reader.readAsText(file);
}

function escapeHtml(unsafe) {
  if (!unsafe) return "";
  return unsafe.toString()
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function handleOnLoad() {
  document.querySelector("#uploadInput").focus();
}

function createNode(tag, classNames) {
  let node = document.createElement(tag);
  if (classNames) {
    if (Array.isArray(classNames)) {
      node.classList.add(...classNames);
    } else {
      node.className = classNames;
    }
  }
  return node;
}

function div() {
  return createNode('div', ...arguments);
}

function h1(string) {
  let node = createNode('h1');
  node.appendChild(text(string));
  return node;
}

function h3(string, ...args) {
  let node = createNode('h3', ...args);
  if (string) node.appendChild(text(string));
  return node;
}

function a(href, string, ...args) {
  let link = createNode('a', ...args);
  link.href = href;
  if (string) link.appendChild(text(string));
  return link;
}

function text(string) {
  return document.createTextNode(string);
}

function renderParseResults(parseProcessor) {
  let result = $('#result');
  // clear out all existing result pages;
  result.innerHTML = '';
  let start = parseProcessor.firstParseEvent;

  renderScript(result, parseProcessor.totalScript, start);
  parseProcessor.scripts.forEach(script =>
     Promise.resolve().then(() => renderScript(result, script, start)));
  console.log('starting to add graphs');
}

const kTimeFactor = 10;
const kHeight = 20;
const kFunktionTopOffset = 50;

function renderScript(result, script, start) {
  if (script.isEmpty() || script.lastParseEvent == 0) return;

  let scriptDiv = div('script');
  scriptDiv.script = script;
  let style = scriptDiv.style;
  // style.height = (
  //     (script.maxNestingLevel + 1) * kHeight + kFunktionTopOffset) + 'px';
  style.width = (script.lastParseEvent * kTimeFactor) + 'px';

  let scriptTitle = h3();
  if (script.file) scriptTitle.appendChild(a(script.file, script.file));
  scriptTitle.appendChild(text(' id=' + script.id));
  scriptDiv.appendChild(scriptTitle);
  let summary = createNode('pre');
  summary.appendChild(text(script.summary));
  scriptDiv.appendChild(summary);

 /*
  script.funktions.forEach(funktion => {
    addParseStep(scriptDiv, funktion, 'preparse', start);
    addParseStep(scriptDiv, funktion, 'parse', start);
    addParseStep(scriptDiv, funktion, 'resolution', start);
    addParseStep(scriptDiv, funktion, 'execution', start);
  });
  */
  appendGraph(script, scriptDiv);
  result.appendChild(scriptDiv);

}

function addParseStep(parent, funktion, name, shift) {
  let start = funktion[name + 'Timestamp'] - shift;
  let width = funktion[name + 'Time'];
  if (name == 'execution') width = 0.00001; 
  if (!start || !width) return;

  let fnDiv = div(['funktion', name]);
  fnDiv.funktion = funktion;
  fnDiv.appendChild(text(funktion.name));

  let style = fnDiv.style;
  style.left = (start * kTimeFactor) + 'px';
  style.width = (width * kTimeFactor) + 'px';
  style.top = (funktion.nestingLevel * kHeight + kFunktionTopOffset) + 'px';

  parent.appendChild(fnDiv);
}

const kMaxX = 1000;
const kMaxY = 200;
const kMaxTime = 30*1000;
const kLabelHeight = 15;
const kLabelMargin = 20;
const kGraphHeight = kMaxY - kLabelHeight;


function appendGraph(script, parentNode) {
  const timerLabel = 'graph script=' + script.id;
  const series = [
      ['firstParse', '#AAA', true],
      ['parse', '#3366CC'],
      ['preparse', '#DC3912'],
      ['resolution', '#88BB00'],
      ['execution', '#DD4477'],
  ];
  let canvas = document.createElement('canvas');
  canvas.width = kMaxX;
  canvas.height = kMaxY;

  console.time(timerLabel);
  let ctx = canvas.getContext('2d');
  ctx.save();
  ctx.translate(0.5, 0.5);

  ctx.globalAlpha = 0.8;
  ctx.lineWidth = 2;
  series.forEach(args => plotMetric(script, ctx, ...args));
  ctx.globalAlpha = 1;

  ctx.lineWidth = 1;
  ctx.lineStyle = '#888';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  // Draw horizonal byte-percent grid.
  for (let percent = 10; percent < 100; percent += 10) {
    let y = Math.round(kGraphHeight * (100 - percent) / 100);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(kMaxX-30, y);
    ctx.stroke();
    ctx.fillText(percent + '%', kMaxX, y)
  }
  // Draw vertical time grid
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for (let ms = 500; ms < kMaxTime; ms += 500) {
    let x = Math.round(ms / kMaxTime * kMaxX);
    ctx.beginPath();
    ctx.moveTo(x, 15);
    ctx.lineTo(x, kGraphHeight);
    ctx.stroke();
    let s = Math.round(ms / 100) / 10;
    ctx.fillText(s + 's', x, 0)
  }

  // Plot series labels
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 1;
  ctx.textAlign = 'left';
  for (let i =0; i < series.length; i++) {
    const kBoxSize = 10;
    const kLabelWidth = 120;
    let [name, color] = series[i];
    let x = 10 + i * kLabelWidth;
    let y = kMaxY - kLabelHeight;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, kBoxSize, kBoxSize);
    ctx.strokeRect(x, y, kBoxSize, kBoxSize);
    ctx.fillStyle = '#000';
    ctx.fillText('% bytes ' + name, x + kBoxSize * 1.5, y)
  }

  ctx.restore();
  parentNode.appendChild(canvas);

  console.timeEnd(timerLabel);
}

function plotMetric(script, ctx, metric, color, fill) {
  ctx.strokeStyle = color;
  ctx.fillStyle= color;
  ctx.beginPath();
  let x = 0;
  ctx.moveTo(x, kGraphHeight);
  for (; x < kMaxX - kLabelMargin; x+=10) {
    let time = x / kMaxX * kMaxTime;
    let y = script.getAccumulatedMetric(metric, time);
    y = kGraphHeight - (y / script.bytesTotal * kGraphHeight);
    ctx.lineTo(x, y);
  }
  ctx.stroke();
  if (fill === true) {
    ctx.lineTo(x-10, kGraphHeight);
    ctx.fill();
  }
}

</script>
</head>

<body onload="handleOnLoad()">
  <h1>BEHOLD, THIS IS PARSEROR!</h1>

  <h2>Usage</h2> Run your script with <code>--trace-parse</code> and/or <code>--trace-preparse</code> and upload <code>v8.log</code> on this page:<br/>
  <code>/path/to/d8 --trace-parse --trace-preparse --log your_script.js</code>

  <h2>Data</h2>
  <form name="fileForm">
    <p>
      <input id="uploadInput" type="file" name="files" onchange="loadFile();"> trace entries: <span id="count">0</span>
    </p>
  </form>

  <h2>Result</h2>
  <div id="result">
  </div>
</body>

</html>
