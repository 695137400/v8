// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Imagine this file is generated by mkgrokdump, similar to the existing file
// v8heapconst.py. This version is based on x64 without pointer compression.

#include "heap-constants.h"
#include "src/globals.h"

namespace d = v8::debug_helper;

namespace v8 {
namespace debug_helper_internal {

std::string FindKnownObjectInMapSpace(uintptr_t offset) {
  switch (offset) {
    case 0x00139:
      return "ExternalMap";
    case 0x00189:
      return "JSMessageObjectMap";
    default:
      return "";
  }
}

std::string FindKnownObjectInReadOnlySpace(uintptr_t offset) {
  switch (offset) {
    case 0x00139:
      return "FreeSpaceMap";
    case 0x00189:
      return "MetaMap";
    case 0x00209:
      return "NullMap";
    case 0x00271:
      return "DescriptorArrayMap";
    case 0x002d1:
      return "WeakFixedArrayMap";
    case 0x00321:
      return "OnePointerFillerMap";
    case 0x00371:
      return "TwoPointerFillerMap";
    case 0x003f1:
      return "UninitializedMap";
    case 0x00461:
      return "OneByteInternalizedStringMap";
    case 0x00501:
      return "UndefinedMap";
    case 0x00561:
      return "HeapNumberMap";
    case 0x005e1:
      return "TheHoleMap";
    case 0x00689:
      return "BooleanMap";
    case 0x00761:
      return "ByteArrayMap";
    case 0x007b1:
      return "FixedArrayMap";
    case 0x00801:
      return "FixedCOWArrayMap";
    case 0x00851:
      return "HashTableMap";
    case 0x008a1:
      return "SymbolMap";
    case 0x008f1:
      return "OneByteStringMap";
    case 0x00941:
      return "ScopeInfoMap";
    case 0x00991:
      return "SharedFunctionInfoMap";
    case 0x009e1:
      return "CodeMap";
    case 0x00a31:
      return "FunctionContextMap";
    case 0x00a81:
      return "CellMap";
    case 0x00ad1:
      return "GlobalPropertyCellMap";
    case 0x00b21:
      return "ForeignMap";
    case 0x00b71:
      return "TransitionArrayMap";
    case 0x00bc1:
      return "FeedbackVectorMap";
    case 0x00c61:
      return "ArgumentsMarkerMap";
    case 0x00d01:
      return "ExceptionMap";
    case 0x00da1:
      return "TerminationExceptionMap";
    case 0x00e49:
      return "OptimizedOutMap";
    case 0x00ee9:
      return "StaleRegisterMap";
    case 0x00f59:
      return "NativeContextMap";
    case 0x00fa9:
      return "ModuleContextMap";
    case 0x00ff9:
      return "EvalContextMap";
    case 0x01049:
      return "ScriptContextMap";
    case 0x01099:
      return "AwaitContextMap";
    case 0x010e9:
      return "BlockContextMap";
    case 0x01139:
      return "CatchContextMap";
    case 0x01189:
      return "WithContextMap";
    case 0x011d9:
      return "DebugEvaluateContextMap";
    case 0x01229:
      return "ScriptContextTableMap";
    case 0x01279:
      return "ClosureFeedbackCellArrayMap";
    case 0x012c9:
      return "FeedbackMetadataArrayMap";
    case 0x01319:
      return "ArrayListMap";
    case 0x01369:
      return "BigIntMap";
    case 0x013b9:
      return "ObjectBoilerplateDescriptionMap";
    case 0x01409:
      return "BytecodeArrayMap";
    case 0x01459:
      return "CodeDataContainerMap";
    case 0x014a9:
      return "FixedDoubleArrayMap";
    case 0x014f9:
      return "GlobalDictionaryMap";
    case 0x01549:
      return "ManyClosuresCellMap";
    case 0x01599:
      return "ModuleInfoMap";
    case 0x015e9:
      return "MutableHeapNumberMap";
    case 0x01639:
      return "NameDictionaryMap";
    case 0x01689:
      return "NoClosuresCellMap";
    case 0x016d9:
      return "NumberDictionaryMap";
    case 0x01729:
      return "OneClosureCellMap";
    case 0x01779:
      return "OrderedHashMapMap";
    case 0x017c9:
      return "OrderedHashSetMap";
    case 0x01819:
      return "OrderedNameDictionaryMap";
    case 0x01869:
      return "PreparseDataMap";
    case 0x018b9:
      return "PropertyArrayMap";
    case 0x01909:
      return "SideEffectCallHandlerInfoMap";
    case 0x01959:
      return "SideEffectFreeCallHandlerInfoMap";
    case 0x019a9:
      return "NextCallSideEffectFreeCallHandlerInfoMap";
    case 0x019f9:
      return "SimpleNumberDictionaryMap";
    case 0x01a49:
      return "SloppyArgumentsElementsMap";
    case 0x01a99:
      return "SmallOrderedHashMapMap";
    case 0x01ae9:
      return "SmallOrderedHashSetMap";
    case 0x01b39:
      return "SmallOrderedNameDictionaryMap";
    case 0x01b89:
      return "StringTableMap";
    case 0x01bd9:
      return "UncompiledDataWithoutPreparseDataMap";
    case 0x01c29:
      return "UncompiledDataWithPreparseDataMap";
    case 0x01c79:
      return "WeakArrayListMap";
    case 0x01cc9:
      return "EphemeronHashTableMap";
    case 0x01d19:
      return "EmbedderDataArrayMap";
    case 0x01d69:
      return "WeakCellMap";
    case 0x01db9:
      return "NativeSourceStringMap";
    case 0x01e09:
      return "StringMap";
    case 0x01e59:
      return "ConsOneByteStringMap";
    case 0x01ea9:
      return "ConsStringMap";
    case 0x01ef9:
      return "ThinOneByteStringMap";
    case 0x01f49:
      return "ThinStringMap";
    case 0x01f99:
      return "SlicedStringMap";
    case 0x01fe9:
      return "SlicedOneByteStringMap";
    case 0x02039:
      return "ExternalStringMap";
    case 0x02089:
      return "ExternalOneByteStringMap";
    case 0x020d9:
      return "UncachedExternalStringMap";
    case 0x02129:
      return "InternalizedStringMap";
    case 0x02179:
      return "ExternalInternalizedStringMap";
    case 0x021c9:
      return "ExternalOneByteInternalizedStringMap";
    case 0x02219:
      return "UncachedExternalInternalizedStringMap";
    case 0x02269:
      return "UncachedExternalOneByteInternalizedStringMap";
    case 0x022b9:
      return "UncachedExternalOneByteStringMap";
    case 0x02309:
      return "FixedUint8ArrayMap";
    case 0x02359:
      return "FixedInt8ArrayMap";
    case 0x023a9:
      return "FixedUint16ArrayMap";
    case 0x023f9:
      return "FixedInt16ArrayMap";
    case 0x02449:
      return "FixedUint32ArrayMap";
    case 0x02499:
      return "FixedInt32ArrayMap";
    case 0x024e9:
      return "FixedFloat32ArrayMap";
    case 0x02539:
      return "FixedFloat64ArrayMap";
    case 0x02589:
      return "FixedUint8ClampedArrayMap";
    case 0x025d9:
      return "FixedBigUint64ArrayMap";
    case 0x02629:
      return "FixedBigInt64ArrayMap";
    case 0x02679:
      return "SelfReferenceMarkerMap";
    case 0x026e1:
      return "EnumCacheMap";
    case 0x02781:
      return "ArrayBoilerplateDescriptionMap";
    case 0x02ad1:
      return "InterceptorInfoMap";
    case 0x052a9:
      return "AccessCheckInfoMap";
    case 0x052f9:
      return "AccessorInfoMap";
    case 0x05349:
      return "AccessorPairMap";
    case 0x05399:
      return "AliasedArgumentsEntryMap";
    case 0x053e9:
      return "AllocationMementoMap";
    case 0x05439:
      return "AsmWasmDataMap";
    case 0x05489:
      return "AsyncGeneratorRequestMap";
    case 0x054d9:
      return "ClassPositionsMap";
    case 0x05529:
      return "DebugInfoMap";
    case 0x05579:
      return "FunctionTemplateInfoMap";
    case 0x055c9:
      return "FunctionTemplateRareDataMap";
    case 0x05619:
      return "InterpreterDataMap";
    case 0x05669:
      return "ModuleInfoEntryMap";
    case 0x056b9:
      return "ModuleMap";
    case 0x05709:
      return "ObjectTemplateInfoMap";
    case 0x05759:
      return "PromiseCapabilityMap";
    case 0x057a9:
      return "PromiseReactionMap";
    case 0x057f9:
      return "PrototypeInfoMap";
    case 0x05849:
      return "ScriptMap";
    case 0x05899:
      return "SourcePositionTableWithFrameCacheMap";
    case 0x058e9:
      return "StackFrameInfoMap";
    case 0x05939:
      return "StackTraceFrameMap";
    case 0x05989:
      return "Tuple2Map";
    case 0x059d9:
      return "Tuple3Map";
    case 0x05a29:
      return "WasmCapiFunctionDataMap";
    case 0x05a79:
      return "WasmDebugInfoMap";
    case 0x05ac9:
      return "WasmExceptionTagMap";
    case 0x05b19:
      return "WasmExportedFunctionDataMap";
    case 0x05b69:
      return "CallableTaskMap";
    case 0x05bb9:
      return "CallbackTaskMap";
    case 0x05c09:
      return "PromiseFulfillReactionJobTaskMap";
    case 0x05c59:
      return "PromiseRejectReactionJobTaskMap";
    case 0x05ca9:
      return "PromiseResolveThenableJobTaskMap";
    case 0x05cf9:
      return "FinalizationGroupCleanupJobTaskMap";
    case 0x05d49:
      return "AllocationSiteWithWeakNextMap";
    case 0x05d99:
      return "AllocationSiteWithoutWeakNextMap";
    case 0x05de9:
      return "LoadHandler1Map";
    case 0x05e39:
      return "LoadHandler2Map";
    case 0x05e89:
      return "LoadHandler3Map";
    case 0x05ed9:
      return "StoreHandler0Map";
    case 0x05f29:
      return "StoreHandler1Map";
    case 0x05f79:
      return "StoreHandler2Map";
    case 0x05fc9:
      return "StoreHandler3Map";
    case 0x001d9:
      return "NullValue";
    case 0x00259:
      return "EmptyDescriptorArray";
    case 0x002c1:
      return "EmptyWeakFixedArray";
    case 0x003c1:
      return "UninitializedValue";
    case 0x004d1:
      return "UndefinedValue";
    case 0x00551:
      return "NanValue";
    case 0x005b1:
      return "TheHoleValue";
    case 0x00649:
      return "HoleNanValue";
    case 0x00659:
      return "TrueValue";
    case 0x00709:
      return "FalseValue";
    case 0x00751:
      return "empty_string";
    case 0x00c11:
      return "EmptyScopeInfo";
    case 0x00701:  // The value from a ptr-compr build, just for testing.
      return "EmptyFixedArray";
    case 0x00c31:
      return "ArgumentsMarker";
    case 0x00cd1:
      return "Exception";
    case 0x00d71:
      return "TerminationException";
    case 0x00e19:
      return "OptimizedOut";
    case 0x00eb9:
      return "StaleRegister";
    case 0x026c9:
      return "EmptyEnumCache";
    case 0x02731:
      return "EmptyPropertyArray";
    case 0x02741:
      return "EmptyByteArray";
    case 0x02751:
      return "EmptyObjectBoilerplateDescription";
    case 0x02769:
      return "EmptyArrayBoilerplateDescription";
    case 0x027d1:
      return "EmptyClosureFeedbackCellArray";
    case 0x027e1:
      return "EmptyFixedUint8Array";
    case 0x02801:
      return "EmptyFixedInt8Array";
    case 0x02821:
      return "EmptyFixedUint16Array";
    case 0x02841:
      return "EmptyFixedInt16Array";
    case 0x02861:
      return "EmptyFixedUint32Array";
    case 0x02881:
      return "EmptyFixedInt32Array";
    case 0x028a1:
      return "EmptyFixedFloat32Array";
    case 0x028c1:
      return "EmptyFixedFloat64Array";
    case 0x028e1:
      return "EmptyFixedUint8ClampedArray";
    case 0x02901:
      return "EmptyFixedBigUint64Array";
    case 0x02921:
      return "EmptyFixedBigInt64Array";
    case 0x02941:
      return "EmptySloppyArgumentsElements";
    case 0x02961:
      return "EmptySlowElementDictionary";
    case 0x029a9:
      return "EmptyOrderedHashMap";
    case 0x029d1:
      return "EmptyOrderedHashSet";
    case 0x029f9:
      return "EmptyFeedbackMetadata";
    case 0x02a09:
      return "EmptyPropertyCell";
    case 0x02a31:
      return "EmptyPropertyDictionary";
    case 0x02a81:
      return "NoOpInterceptorInfo";
    case 0x02b21:
      return "EmptyWeakArrayList";
    case 0x02b39:
      return "InfinityValue";
    case 0x02b49:
      return "MinusZeroValue";
    case 0x02b59:
      return "MinusInfinityValue";
    case 0x02b69:
      return "SelfReferenceMarker";
    case 0x02bc1:
      return "OffHeapTrampolineRelocationInfo";
    case 0x02bd9:
      return "TrampolineTrivialCodeDataContainer";
    case 0x02bf1:
      return "TrampolinePromiseRejectionCodeDataContainer";
    case 0x02c09:
      return "HashSeed";
    default:
      return "";
  }
}

std::string FindKnownObjectInOldSpace(uintptr_t offset) {
  switch (offset) {
    case 0x00139:
      return "ArgumentsIteratorAccessor";
    case 0x001a9:
      return "ArrayLengthAccessor";
    case 0x00219:
      return "BoundFunctionLengthAccessor";
    case 0x00289:
      return "BoundFunctionNameAccessor";
    case 0x002f9:
      return "ErrorStackAccessor";
    case 0x00369:
      return "FunctionArgumentsAccessor";
    case 0x003d9:
      return "FunctionCallerAccessor";
    case 0x00449:
      return "FunctionNameAccessor";
    case 0x004b9:
      return "FunctionLengthAccessor";
    case 0x00529:
      return "FunctionPrototypeAccessor";
    case 0x00599:
      return "StringLengthAccessor";
    case 0x00609:
      return "InvalidPrototypeValidityCell";
    case 0x00619:
      return "EmptyScript";
    case 0x00699:
      return "ManyClosuresCell";
    case 0x006b1:
      return "ArrayConstructorProtector";
    case 0x006c1:
      return "NoElementsProtector";
    case 0x006e9:
      return "IsConcatSpreadableProtector";
    case 0x006f9:
      return "ArraySpeciesProtector";
    case 0x00721:
      return "TypedArraySpeciesProtector";
    case 0x00749:
      return "RegExpSpeciesProtector";
    case 0x00771:
      return "PromiseSpeciesProtector";
    case 0x00799:
      return "StringLengthProtector";
    case 0x007a9:
      return "ArrayIteratorProtector";
    case 0x007d1:
      return "ArrayBufferDetachingProtector";
    case 0x007f9:
      return "PromiseHookProtector";
    case 0x00821:
      return "PromiseResolveProtector";
    case 0x00831:
      return "MapIteratorProtector";
    case 0x00859:
      return "PromiseThenProtector";
    case 0x00881:
      return "SetIteratorProtector";
    case 0x008a9:
      return "StringIteratorProtector";
    case 0x008d1:
      return "SingleCharacterStringCache";
    case 0x010e1:
      return "StringSplitCache";
    case 0x018f1:
      return "RegExpMultipleCache";
    case 0x02101:
      return "BuiltinsConstantsTable";
    default:
      return "";
  }
}

std::string FindKnownObject(uintptr_t address, const d::Roots& roots) {
  uintptr_t containing_page = address & ~i::kPageAlignmentMask;
  uintptr_t offset_in_page = address & i::kPageAlignmentMask;

  // If there's a match with a known root, then search only that page.
  if (containing_page == roots.map_space) {
    return FindKnownObjectInMapSpace(offset_in_page);
  }
  if (containing_page == roots.old_space) {
    return FindKnownObjectInOldSpace(offset_in_page);
  }
  if (containing_page == roots.read_only_space) {
    return FindKnownObjectInReadOnlySpace(offset_in_page);
  }

  // For any unknown roots, compile a list of things this object might be.
  std::string result;
  if (roots.map_space == 0) {
    std::string sub_result = FindKnownObjectInMapSpace(offset_in_page);
    if (!sub_result.empty()) {
      result += "maybe " + sub_result;
    }
  }
  if (roots.old_space == 0) {
    std::string sub_result = FindKnownObjectInOldSpace(offset_in_page);
    if (!sub_result.empty()) {
      result = (result.empty() ? "" : result + ", ") + "maybe " + sub_result;
    }
  }
  if (roots.read_only_space == 0) {
    std::string sub_result = FindKnownObjectInReadOnlySpace(offset_in_page);
    if (!sub_result.empty()) {
      result = (result.empty() ? "" : result + ", ") + "maybe " + sub_result;
    }
  }

  return result;
}

uint16_t FindKnownMapInstanceType(uintptr_t address, const d::Roots& roots) {
  // TODO, map instance data is also available via mkgrokdump.
  return 0;
}

}  // namespace debug_helper_internal
}  // namespace v8
