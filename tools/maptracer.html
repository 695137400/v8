<!DOCTYPE html>
<html>
  <!--
  Copyright 2016 the V8 project authors. All rights reserved.  Use of this source
  code is governed by a BSD-style license that can be found in the LICENSE file.
  -->
<head>
<meta charset="UTF-8">
<style>
html, body {
  font-family: sans-serif;
  padding: 0px;
  margin: 0px;
}
h1, h2, h3, section {
  padding-left: 15px;
}
#stats table {
  display: inline-block;
  padding-right: 50px;
}
#stats .transitionTable {
  max-height: 200px;
  overflow-y: scroll;
}
#timeline {
  position: relative;
  height: 300px;
  overflow-y: hidden;
  overflow-x: scroll;
  user-select: none;
}
#timelineChunks {
  height: 250px;
  position: absolute;
  margin-right: 100px;
}
#timelineCanvas {
  height: 250px;
  position: relative;
  overflow: visible;
  pointer-events: none;
}
.chunk {
  width: 6px;
  border: 0px white solid;
  border-width: 0 2px 0 2px;
  position: absolute;
  background-size: 100% 100%;
  image-rendering: pixelated;
  bottom: 0px;
}
.timestamp {
  height: 250px;
  width: 100px;
  border-left: 1px black dashed;
  padding-left: 4px;
  position: absolute;
  pointer-events: none;
  font-size: 10px;
  opacity: 0.5;
}
#timelineOverview {
  width: 100%;
  height: 50px;
  position: relative;
  margin-top: -50px;
  margin-bottom: 10px;
  background-size: 100% 100%;
  border: 1px black solid;
  border-width: 1px 0 1px 0;
  overflow: hidden;
}
#timelineOverviewIndicator {
  height: 100%;
  position: absolute;
  box-shadow: 0px 2px 20px -5px black inset;
  top: 0px;
  cursor: ew-resize;
}
#timelineOverviewIndicator .leftMask,
#timelineOverviewIndicator .rightMask {
  background-color: rgba(200, 200, 200, 0.5);
  width: 10000px;
  height: 100%;
  position: absolute;
  top: 0px;
}
#timelineOverviewIndicator .leftMask {
  right: 100%;
}
#timelineOverviewIndicator .rightMask {
  left: 100%;
}
#mapDetails {
  font-family: monospace;
  white-space: pre;
}
#transitionView {
  overflow-x: scroll;
  white-space: nowrap;
  min-height: 50px;
  max-height: 200px;
  padding: 50px 0 0 0;
  margin-top: -25px;
  width: 100%;
}
.map {
  width: 20px;
  height: 20px;
  display: inline-block;
  border-radius: 50%;
  background-color: black;
  border: 4px solid white;
  font-size: 10px;
  text-align: center;
  line-height: 18px;
  color: white;
  vertical-align: top;
  margin-top: -13px;
  /* raise z-index */
  position: relative;
  z-index: 2;
  cursor: pointer;
}
.map.selected {
  border-color: black;
}
.transitions {
  display: inline-block;
  margin-left: -15px;
}
.transition {
  min-height: 55px;
  margin: 0 0 -2px 2px;
}
/* gray out deprecated transitions */
.deprecated > .transitionEdge,
.deprecated > .map {
  opacity: 0.5;
}
.deprecated > .transition {
  border-color: rgba(0, 0, 0, 0.5);
}
/* Show a border for all but the first transition */
.transition:nth-of-type(2),
.transition:nth-last-of-type(n+2) {
  border-left: 2px solid;
  margin-left: 0px;
}
/* special case for 2 transitions */
.transition:nth-last-of-type(1) {
  border-left: none;
}
/* topmost transitions are not related */
#transitionView > .transition {
  border-left: none;
}
/* topmost transition edge needs initial offset to be aligned */
#transitionView > .transition  > .transitionEdge {
  margin-left: 13px;
}
.transitionEdge {
  height: 2px;
  width: 80px;
  display: inline-block;
  margin: 0 0 2px 0;
  background-color: black;
  vertical-align: top;
  padding-left: 15px;
}
.transitionLabel {
  color: black;
  transform: rotate(-15deg);
  transform-origin: top left;
  margin-top: -10px;
  font-size: 10px;
  white-space: normal;
  word-break: break-all;
  background-color: rgba(255,255,255,0.5);
}
.red {
  background-color: red;
}
.green {
  background-color: green;
}
.yellow {
  background-color: yellow;
  color: black;
}
.blue {
  background-color: blue;
}
.orange {
  background-color: orange;
}
.violet {
  background-color: violet;
  color: black;
}
.showSubtransitions {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 10px solid black;
  cursor: zoom-in;
  margin: 4px 0 0 4px;
}
.showSubtransitions.opened {
  border-top: none;
  border-bottom: 10px solid black;
  cursor: zoom-out;
}
#tooltip {
  position: absolute;
  width: 10px;
  height: 10px;
  background-color: red;
  pointer-events: none;
  z-index: 100;
  display: none;
}
</style>
<script src="./splaytree.js"></script>
<script src="./codemap.js"></script>
<script src="./csvparser.js"></script>
<script src="./consarray.js"></script>
<script src="./profile.js"></script>
<script src="./profile_view.js"></script>
<script src="./logreader.js"></script>
<script src="./SourceMap.js"></script>
<script src="./map-processor.js"></script>
<script>
"use strict"
// =========================================================================
const kChunkHeight = 250;
const kChunkWidth = 10;

class State {
  constructor() {
    this._nofChunks = 400;
    this._map = undefined;
    this._timeline = undefined;
    this._chunks = undefined;
    this._view = new View(this);
    this._navigation = new Navigation(this, this.view);
  }
  get timeline() { return this._timeline }
  set timeline(value) {
    this._timeline = value;
    this.updateChunks();
    this.view.updateTimeline();
    this.view.updateStats();
  }
  get chunks() { return this._chunks }
  get nofChunks() { return this._nofChunks }
  set nofChunks(count) {
    this._nofChunks = count;
    this.updateChunks();
    this.view.updateTimeline();
  }
  get view() { return this._view }
  get navigation() { return this._navigation }
  get map() { return this._map }
  set map(value) {
    this._map = value;
    this._navigation.updateUrl();
    this.view.updateMapDetails();
    this.view.redraw();
  }
  updateChunks() {
    this._chunks = this._timeline.chunks(this._nofChunks);
  }
  get entries() {
    if (!this.map) return {};
    return {
      map: this.map.id,
      time: this.map.time
    }
  }
}

// =========================================================================
// DOM Helper
function $(id) {
  return document.getElementById(id)
}

function removeAllChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

function selectOption(select, match) {
  var options = select.options;
  for (var i = 0; i < options.length; i++) {
    if (match(i, options[i])) {
      select.selectedIndex = i;
      return;
    }
  }
}

function div(classes) {
  let node = document.createElement('div');
  if (classes !== void 0) {
    if (typeof classes == "string") {
      node.classList.add(classes);
    } else {
      classes.forEach(cls => node.classList.add(cls));
    }
  }
  return node;
}

function table(className) {
  let node = document.createElement("table")
  if (className) node.classList.add(className)
  return node;
}
function td(text) {
  let node = document.createElement("td");
  node.innerText = text;
  return node;
}
function tr() {
  let node = document.createElement("tr");
  return node;
}

function define(prototype, name, fn) {
  Object.defineProperty(prototype, name, {value:fn, enumerable:false});
}

define(Array.prototype, "max", function(fn) {
  if (this.length == 0) return undefined;
  if (fn == undefined) fn = (each) => each;
  let max = fn(this[0]);
  for (let i = 1; i < this.length; i++) {
    max = Math.max(max, fn(this[i]));
  }
  return max;
})
define(Array.prototype, "histogram", function(mapFn) {
  let histogram = [];
  for (let i = 0; i < this.length; i++) {
    let value = this[i];
    let index = Math.round(mapFn(value))
    let bucket = histogram[index];
    if (bucket !== undefined) {
      bucket.push(value);
    } else {
      histogram[index] = [value];
    }
  }
  for (let i = 0; i < histogram.length; i++) {
    histogram[i] = histogram[i] || [];
  }
  return histogram;
});

define(Array.prototype, "first", function() { return this[0] });
define(Array.prototype, "last", function() { return this[this.length - 1] });

// =========================================================================
// EventHandlers
function handleBodyLoad() {
  $('uploadInput').focus();
  document.state = new State();
  $("transitionView").addEventListener("mousemove", e => {
    let tooltip = $("tooltip");
    tooltip.style.left = e.pageX + "px";
    tooltip.style.top = e.pageY + "px";
    let map = e.target.map;
    if (map) {
      $("tooltipContents").innerText = map.description.join("\n");
    }

    console.log(e)
  });
}

function handleLoadFile() {
  var files = document.getElementById("uploadInput").files;
  var file = files[0];
  var reader = new FileReader();

  reader.onload = function(evt) {
    handleLoadText(this.result);
  }
  reader.readAsText(file);
}

function handleLoadText(text) {
  document.state.timeline = new InputReader(text).read();
}

function handleKeyDown(event) {
  let nav = document.state.navigation;
  switch(event.key) {
    case "ArrowUp":
      event.preventDefault();
      if (event.shiftKey) {
        nav.selectPrevEdge();
      } else {
        nav.moveInChunk(-1);
      }
      return false;
    case "ArrowDown":
      event.preventDefault();
      if (event.shiftKey) {
        nav.selectNextEdge();
      } else {
        nav.moveInChunk(1);
      }
      return false;
    case "ArrowLeft":
      nav.moveInChunks(false);
      break;
    case "ArrowRight":
      nav.moveInChunks(true);
      break;
    case "+":
      nav.increaseTimelineResolution();
      break;
    case "-":
      nav.decreaseTimelineResolution();
      break;
  }
};
document.onkeydown = handleKeyDown;

function handleTimelineIndicatorMove(event) {
  if (event.buttons == 0) return;
  let timelineTotalWidth = $("timelineCanvas").offsetWidth;
  let factor = $("timelineOverview").offsetWidth / timelineTotalWidth;
  $("timeline").scrollLeft += event.movementX / factor;
}

// =========================================================================
class Navigation {
  constructor(state, view) {
    this.state = state;
    this.view = view;
  }
  get map() { return this.state.map }
  set map(value) { this.state.map = value }
  get chunks() { return this.state.chunks }

  increaseTimelineResolution() {
    this.state.nofChunks *= 1.5;
  }

  decreaseTimelineResolution() {
    this.state.nofChunks /= 1.5;
  }

  selectNextEdge() {
    if (!this.map) return;
    if (this.map.children.length != 1) return;
    this.map = this.map.children[0].to;
  }

  selectPrevEdge() {
    if (!this.map) return;
    if (!this.map.parent()) return;
    this.map = this.map.parent();
  }

  selectDefaultMap() {
      this.map = this.chunks[0].at(0);
  }
  moveInChunks(next) {
    if (!this.map) return this.selectDefaultMap();
    let chunkIndex = this.map.chunkIndex(this.chunks);
    let chunk = this.chunks[chunkIndex];
    let index = chunk.indexOf(this.map);
    if (next) {
      chunk = chunk.next(this.chunks);
    } else {
      chunk = chunk.prev(this.chunks);
    }
    if (!chunk) return;
    index = Math.min(index, chunk.size()-1);
    this.map = chunk.at(index);
  }

  moveInChunk(delta) {
    if (!this.map) return this.selectDefaultMap();
    let chunkIndex = this.map.chunkIndex(this.chunks)
    let chunk = this.chunks[chunkIndex];
    let index = chunk.indexOf(this.map) + delta;
    let map;
    if (index < 0) {
      map = chunk.prev(this.chunks).last();
    } else if (index >= chunk.size()) {
      map = chunk.next(this.chunks).first()
    } else {
      map = chunk.at(index);
    }
    this.map = map;
  }

  updateUrl() {
    let params = new URLSearchParams(this.state.entries);
    window.history.pushState(state, "", "?" + params.toString());
  }
}

class View {
  constructor(state) {
    this.state = state;
    setInterval(this.updateOverviewWindow, 50);
    this.backgroundCanvas = document.createElement("canvas");
    this.transitionView = new TransitionView(state, $("transitionView"));
    this.statsView = new StatsView(state, $("stats"));
    this.isLocked = false;
  }
  get chunks() { return this.state.chunks }
  get timeline() { return this.state.timeline }
  get map() { return this.state.map }

  updateStats() {
    this.statsView.update();
  }

  updateMapDetails() {
    let details = "";
    if (this.map) {
      details += "ID: " + this.map.id;
      details += "\n" + this.map.description.join("\n")
    }
    $("mapDetails").innerText = details;
    this.transitionView.showMap(this.map);
  }

  updateTimeline() {
    let chunksNode = $("timelineChunks");
    removeAllChildren(chunksNode);
    let chunks = this.chunks;
    let max = chunks.max(each => each.size());
    let start = this.timeline.startTime;
    let end = this.timeline.endTime;
    let duration = end - start;
    const timeToPixel = chunks.length * kChunkWidth / duration;
    let addTimestamp = (time, name) => {
      console.log(time, name);
      let timeNode = div("timestamp");
      timeNode.innerText = name;
      timeNode.style.left = ((time-start) * timeToPixel) + "px";
      chunksNode.appendChild(timeNode);
    };
    for (let i = 0; i < chunks.length; i++) {
      let chunk = chunks[i];
      let height = (chunk.size() / max * kChunkHeight);
      chunk.height = height;
      if (chunk.isEmpty()) continue;
      let node = div();
      node.className = "chunk";
      node.style.left = (i * kChunkWidth) + "px";
      node.style.height = height + "px";
      node.chunk = chunk;
      node.addEventListener("mousemove", e => this.handleChunkMouseMove(e));
      node.addEventListener("click", e => this.handleChunkClick(e));
      node.addEventListener("dblclick", e => this.handleChunkDoubleClick(e));
      this.setTimelineChunkBackground(chunk, node);
      chunksNode.appendChild(node);
      chunk.markers.forEach(marker => addTimestamp(marker.time, marker.name));
    }
    // Put a time marker roughly every 20 chunks.
    let expected  = duration / chunks.length * 20;
    let interval = (10 ** Math.floor(Math.log10(expected)));
    let correction = Math.log10(expected / interval);
    correction = (correction < 0.33) ? 1 : (correction < 0.75) ? 2.5 : 5;
    interval *= correction;

    let time = start;
    while (time < end) {
      addTimestamp(time, ((time-start) / 1000) + " ms");
      time += interval;
    }
    this.drawOverview();
    this.drawHistograms();
    this.redraw();
  }

  handleChunkMouseMove(event) {
    if (this.isLocked) return false;
    let chunk = event.target.chunk;
    if (!chunk) return;
    // topmost map (at chunk.height) == map #0.
    let relativeIndex =
        Math.round(event.layerY / event.target.offsetHeight * chunk.size());
    let map = chunk.at(relativeIndex);
    this.state.map = map;
  }

  handleChunkClick(event) {
    this.isLocked = !this.isLocked;
  }

  handleChunkDoubleClick(event) {
    this.isLocked = true;
    let chunk = event.target.chunk;
    if (!chunk) return;
    this.transitionView.showMaps(chunk.getUniqueTransitions());
  }

  setTimelineChunkBackground(chunk, node) {
    // Render the types of transitions as bar charts
    const kHeight = chunk.height;
    const kWidth = 1;
    this.backgroundCanvas.width = kWidth;
    this.backgroundCanvas.height = kHeight;
    let ctx = this.backgroundCanvas.getContext("2d");
    ctx.clearRect(0, 0, kWidth, kHeight);
    let y = 0;
    let total = chunk.size();
    let type, count;
    if (true) {
      for ([type, count] of chunk.getTransitionBreakdown()) {
          ctx.fillStyle = transitionTypeToColor(type);
          let height = count / total * kHeight;
          ctx.fillRect(0, y, kWidth, y + height);
          y += height;
      }
    } else {
      for (let map of chunk.items) {
        ctx.fillStyle = transitionTypeToColor(map.getType());
        let y = chunk.yOffset(map);
        ctx.fillRect(0, y, kWidth, y + 1);
      }
    }

    let imageData = this.backgroundCanvas.toDataURL("image/png");
    node.style.backgroundImage = "url(" + imageData + ")";
  }

  updateOverviewWindow() {
    let indicator = $("timelineOverviewIndicator");
    let totalIndicatorWidth = $("timelineOverview").offsetWidth;
    let div = $("timeline");
    let timelineTotalWidth = $("timelineCanvas").offsetWidth;
    let factor = $("timelineOverview").offsetWidth / timelineTotalWidth;
    let width = div.offsetWidth * factor;
    let left = div.scrollLeft * factor;
    indicator.style.width = width + "px";
    indicator.style.left = left + "px";
  }

  drawOverview() {
    const height = 50;
    const kFactor = 2;
    let canvas =  this.backgroundCanvas;
    canvas.height = height;
    canvas.width = window.innerWidth;
    let ctx = canvas.getContext("2d");

    let chunks = this.state.timeline.chunkSizes(canvas.width * kFactor);
    let max = chunks.max();

    ctx.clearRect(0, 0, canvas.width, height);
    ctx.strokeStyle = "black";
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.moveTo(0,height);
    for (let i = 0; i < chunks.length; i++) {
      ctx.lineTo(i/kFactor, height - chunks[i]/max * height);
    }
    ctx.lineTo(chunks.length, height);
    ctx.stroke();
    ctx.closePath();
    ctx.fill();
    let imageData = canvas.toDataURL("image/png");
    $("timelineOverview").style.backgroundImage = "url(" + imageData + ")";
  }

  drawHistograms() {
    $("mapsDepthHistogram").histogram = this.timeline.depthHistogram();
    $("mapsFanOutHistogram").histogram = this.timeline.fanOutHistogram();
  }

  drawMapsDepthHistogram() {
    let canvas = $("mapsDepthCanvas");
    let histogram = this.timeline.depthHistogram();
    this.drawHistogram(canvas, histogram, true);
  }

  drawMapsFanOutHistogram() {
    let canvas = $("mapsFanOutCanvas");
    let histogram = this.timeline.fanOutHistogram();
    this.drawHistogram(canvas, histogram, true, true);
  }

  drawHistogram(canvas, histogram, logScaleX=false, logScaleY=false) {
    let ctx = canvas.getContext("2d");
    let yMax = histogram.max(each => each.length);
    if (logScaleY) yMax = Math.log(yMax);
    let xMax = histogram.length;
    if (logScaleX) xMax = Math.log(xMax);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    ctx.moveTo(0,canvas.height);
    for (let i = 0; i < histogram.length; i++) {
      let x = i;
      if (logScaleX) x = Math.log(x);
      x = x / xMax * canvas.width;
      let bucketLength = histogram[i].length;
      if (logScaleY) bucketLength = Math.log(bucketLength);
      let y = (1 - bucketLength / yMax) * canvas.height;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath;
    ctx.stroke();
    ctx.fill();
  }

  redraw() {
    let canvas= $("timelineCanvas");
    canvas.width = (this.chunks.length+1) * kChunkWidth;
    canvas.height = kChunkHeight;
    let ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, kChunkHeight);
    if (!this.state.map) return;
    this.drawEdges(ctx);
  }

  markMap(ctx, map) {
    let [x, y] = map.position(this.state.chunks);
    ctx.beginPath();
    map.setStyle(ctx);
    ctx.arc(x, y, 3, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = "white";
    ctx.arc(x, y, 2, 0, 2 * Math.PI);
    ctx.fill();
  }

  markSelectedMap(ctx, map) {
    let [x, y] = map.position(this.state.chunks);
    ctx.beginPath();
    map.setStyle(ctx);
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.stroke();
  }

  drawEdges(ctx) {
    // Draw the trace of maps in reverse order to make sure the outgoing
    // transitions of previous maps aren't drawn over.
    const kMaxOutgoingEdges = 100;
    let nofEdges = 0;
    let stack = [];
    let current = this.state.map;
    while (current && nofEdges < kMaxOutgoingEdges) {
      nofEdges += current.children.length;
      stack.push(current);
      current = current.parent();
    }
    ctx.save();
    this.drawOutgoingEdges(ctx, this.state.map, 3);
    ctx.restore();

    let labelOffset = 15;
    let xPrev = 0;
    while (current = stack.pop()) {
      if (current.edge) {
        current.edge.setStyle(ctx);
        let [xTo, yTo] = this.drawEdge(ctx, current.edge, true, labelOffset);
        if (xTo == xPrev) {
          labelOffset += 8;
        } else {
          labelOffset = 15
        }
        xPrev = xTo;
      }
      this.markMap(ctx, current);
      current = current.parent();
      ctx.save();
      // this.drawOutgoingEdges(ctx, current, 1);
      ctx.restore();
    }
    // Mark selected map
    this.markSelectedMap(ctx, this.state.map);
  }

  drawEdge(ctx, edge, showLabel=true, labelOffset=20) {
    if (!edge.from || !edge.to) return [-1, -1];
    let [xFrom, yFrom] = edge.from.position(this.chunks);
    let [xTo, yTo] = edge.to.position(this.chunks);
    let sameChunk = xTo == xFrom;
    if (sameChunk) labelOffset += 8;

    ctx.beginPath();
    ctx.moveTo(xFrom, yFrom);
    let offsetX = 20;
    let offsetY = 20;
    let midX = xFrom + (xTo- xFrom) / 2;
    let midY = (yFrom + yTo) / 2 - 100;
    if (!sameChunk) {
      ctx.quadraticCurveTo(midX, midY, xTo, yTo);
    } else {
      ctx.lineTo(xTo, yTo);
    }
    if (!showLabel) {
      ctx.stroke();
    } else {
      let centerX, centerY;
      if (!sameChunk) {
      centerX = (xFrom/2 + midX + xTo/2)/2;
      centerY = (yFrom/2 + midY + yTo/2)/2;
      } else {
        centerX = xTo;
        centerY = yTo;
      }
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + offsetX, centerY - labelOffset);
      ctx.stroke();
      ctx.textAlign = "left";
      ctx.fillText(edge.toString(), centerX + offsetX + 2, centerY - labelOffset)
    }
    return [xTo, yTo];
  }

  drawOutgoingEdges(ctx, map, max=10, depth=0) {
    if (!map) return;
    if (depth >= max) return;
    ctx.globalAlpha = 0.5 - depth * (0.3/max);
    ctx.strokeStyle = "#666";

    const limit = Math.min(map.children.length, 100)
    for (let i = 0; i < limit; i++) {
      let edge = map.children[i];
      this.drawEdge(ctx, edge, true);
      this.drawOutgoingEdges(ctx, edge.to, max, depth+1);
    }
  }
}


class TransitionView {
  constructor(state, node) {
    this.state = state;
    this.container = node;
    this.currentNode = node;
    this.currentMap = undefined;
  }

  selectMap(map) {
    this.currentMap = map;
    this.state.map = map;
  }

  showMap(map) {
    if (this.currentMap === map) return;
    this.currentMap = map;
    this._showMaps([map]);
  }

  showMaps(list, name) {
    this.state.view.isLocked = true;
    this._showMaps(list);
  }

 _showMaps(list, name) {
    // Hide the container to avoid any layouts.
    this.container.style.display = "none";
    removeAllChildren(this.container);
    list.forEach(map => this.addMapAndParentTransitions(map));
    this.container.style.display = ""
  }

  addMapAndParentTransitions(map) {
    if (map === void 0) return;
    this.currentNode = this.container;
    let parents = map.getParents();
    if (parents.length > 0) {
      this.addTransitionTo(parents.pop());
      parents.reverse().forEach(each => this.addTransitionTo(each));
    }
    let mapNode = this.addSubtransitions(map);
    // Mark and show the selected map.
    mapNode.classList.add("selected");
    if (this.selectedMap == map) {
      setTimeout(() => mapNode.scrollIntoView({
        behavior: "smooth", block: "nearest", inline: "nearest"
      }), 1);
    }
  }

  addMapNode(map) {
    let node = div("map");
    if (map.edge) node.classList.add(map.edge.getColor());
    node.map = map;
    node.addEventListener("click", () => this.selectMap(map));
    if (map.children.length > 1) {
      node.innerText = map.children.length;
      let showSubtree = div("showSubtransitions");
      showSubtree.addEventListener("click", (e) => this.toggleSubtree(e, node));
      node.appendChild(showSubtree);
    } else if (map.children.length == 0) {
      node.innerHTML = "&#x25CF;"
    }
    this.currentNode.appendChild(node);
    return node;
  }

  addSubtransitions(map) {
    let mapNode = this.addTransitionTo(map);
    // Draw outgoing linear transition line.
    let current = map;
    while (current.children.length == 1) {
      current = current.children[0].to;
      this.addTransitionTo(current);
    }
    return mapNode;
  }

 addTransitionEdge(map) {
    let classes = ["transitionEdge", map.edge.getColor()];
    let edge = div(classes);
    let labelNode = div("transitionLabel");
    labelNode.innerText = map.edge.toString();
    edge.appendChild(labelNode);
    return edge;
  }

  addTransitionTo(map) {
    // transition[ transitions[ transition[...], transition[...], ...]];

    let transition = div("transition");
    if (map.isDeprecated()) transition.classList.add("deprecated");
    if (map.edge) {
      transition.appendChild(this.addTransitionEdge(map));
    }
    let mapNode = this.addMapNode(map);
    transition.appendChild(mapNode);

    let subtree = div("transitions");
    transition.appendChild(subtree);

    this.currentNode.appendChild(transition);
    this.currentNode = subtree;

    return mapNode;

  }

  toggleSubtree(event, node) {
    let map = node.map;
    event.target.classList.toggle("opened");
    let transitionsNode = node.parentElement.querySelector(".transitions");
    let subtransitionNodes  =  transitionsNode.children;
    if (subtransitionNodes.length <= 1) {
      // Add subtransitions excepth the one that's already shown.
      let visibleTransitionMap = subtransitionNodes.length == 1 ?
            transitionsNode.querySelector(".map").map : void 0;
      map.children.forEach(edge => {
        if (edge.to != visibleTransitionMap) {
          this.currentNode = transitionsNode;
          this.addSubtransitions(edge.to);
        }
      });
    } else {
      // remove all but the first (currently selected) subtransition
      for (let i = subtransitionNodes.length-1; i > 0; i--) {
        transitionsNode.removeChild(subtransitionNodes[i]);
      }
    }
  }
}

class StatsView {
  constructor(state, node) {
    this.state = state;
    this.node = node;
  }
  get timeline() { return this.state.timeline }
  get transitionView() { return this.state.view.transitionView; }
  update() {
    removeAllChildren(this.node);
    this.updateGeneralStats();
    this.updateNamedTransitionsStats();
  }
  updateGeneralStats() {
    let pairs = [
      ["Maps", e => true],
      ["Transitions", e => e.edge && e.edge.isTransition()],
      ["Fast to Slow", e => e.edge && e.edge.isFastToSlow()],
      ["Slow to Fast", e => e.edge && e.edge.isSlowToFast()],
      ["Initial Map", e => e.edge && e.edge.isInitial()],
      ["Replace Descriptors", e => e.edge && e.edge.isReplaceDescriptors()],
      ["Copy as Prototype", e => e.edge && e.edge.isCopyAsPrototype()],
      ["Optimize as Prototype", e => e.edge && e.edge.isOptimizeAsPrototype()],
      ["Deprecated", e => e.isDeprecated()],
    ];

    let text = "";
    let tableNode = table();
    let name, filter;
    let total = this.timeline.size();
    for (name, filter of pairs) {
      let row = tr();
      row.maps = this.timeline.filterUniqueTransitions(filter);
      row.addEventListener("click",
          e => this.transitionView.showMaps(e.target.parentNode.maps));
      row.appendChild(td(name));
      let count = this.timeline.count(filter);
      row.appendChild(td(count));
      let percent = Math.round(count / total * 1000) / 10;
      row.appendChild(td(percent + "%"));
      tableNode.appendChild(row);
    }
    this.node.appendChild(tableNode);
  }
  updateNamedTransitionsStats() {
    let tableNode = table("transitionTable");
    let nameMapPairs = Array.from(this.timeline.transitions.entries());
    nameMapPairs.sort((a,b) => b[1].length - a[1].length)
    for (let i = 0; i < nameMapPairs.length; i++) {
      let [name, maps] = nameMapPairs[i];
      let row = tr();
      row.maps = maps;
      row.addEventListener("click",
          e => this.transitionView.showMaps(e.target.parentNode.maps.map(e => e.to)));
      row.appendChild(td(name));
      row.appendChild(td(maps.length));
      tableNode.appendChild(row);
    }
    this.node.appendChild(tableNode);
  }
}

// =========================================================================
// Classes
class InputReader {
  constructor(text) {
    this.lines = text.split("\n");
    this.index = 0;
    this.timeline = new Timeline();
  }
  hasMore() { return this.index < this.lines.length }
  next() { this.index++ }
  current() { return this.lines[this.index] }
  lineMatches(suffix) { return this.lineStartsWith("[TraceMaps: " + suffix); }
  lineStartsWith(prefix) {  return this.current().startsWith(prefix); }
  read() {
    try {
      while(this.hasMore()) {
        if (this.lineMatches("MapDetailsBegin")) {
          this.readMapDetails();
        } else if (this.lineMatches("Deprecate")) {
          this.readDeprecation();
        } else if (this.lineMatches("")) {
          this.readEdge();
        } else if (this.lineStartsWith("[PerformanceMarker ")) {
          this.readMarker();
        }
        this.next();
      }
    } catch(e) {
      // Support partial input files which might break parsing at any
      // point.
      console.log(e);
    }
    this.finalize();
    return this.timeline;
  }

  extractValue(prefix) {
    let line = this.current();
    let start = line.indexOf(prefix);
    if (start < 0) throw "Could not find token";
    let end = line.indexOf(" ", start+1);
    return line.substring(start+prefix.length, end);
  }

  extractUpTo(suffix) {
    let line = this.current();
    let end = line.indexOf(suffix);
    return line.substring(0, end);
  }

  readDeprecation() {
    let line = this.current().split(" ");
    let mapId = line[2].split("=")[1];
    V8Map.get(mapId).deprecate();
  }

  readMapDetails() {
    let time = Number(this.extractValue("time="));
    this.next();
    const id = this.extractUpTo(":");
    this.next();
    const start = this.index;
    let details = [];
    while (!this.lineMatches("MapDetailsEnd")) {
      let line = this.current();
      details.push(line);
      this.next();
    };
    const end = this.index;
    let map = new V8Map(id, time, details);
    this.timeline.push(map);
  }

  readEdge() {
    let line = this.current().split(" ");
    let edge = new Edge();
    edge.type = line[1];
    for (let i = 2; i < line.length-1; i++) {
      let pair = line[i].split("=");
      let key = pair[0];
      if (key == "map") {
        key = "to";
      } else if (key == "SFI") {
       let parts = pair[1].split("_");
       edge.SFI = parts[0];
       edge.reason = parts.slice(1).join("_");
       continue;
      }
      edge[key] = pair[1];
    }
    edge.time = Number(edge.time);
    edge.finishSetup();
  }

  readMarker() {
    let line = this.current().split(" ");
    let time = Number(line[1].split("=")[1]);
    let message = line.slice(2, -1).join(" ");
    this.timeline.addMarker(time, message);
  }

  finalize() {
   this.timeline.finalize();
  }
}

class V8Map {
  constructor(id, time, description) {
    if (!id) throw Errror("Invalid ID");
    this.id = id;
    this.time = time;
    if (!(time > 0)) throw Error("Invalid time");
    this.description = description;
    this.edge = void 0;
    this.children = [];
    this.depth = 0;
    this._isDeprecated = false;
    this.deprecationTargets = null;
    V8Map.set(id, this);
    this.leftId = 0;
    this.rightId = 0;
  }
  finalize(id) {
    // Initialize preorder tree traversal Ids for fast subtree inclusion checks
    let currentId = id;
    this.leftId = currentId;
    this.children.forEach(edge => {
      let map = edge.to;
      currentId = map.finalize(currentId+1);
    });
    this.rightId = currentId + 1;
    return currentId + 1;
  }
  parent() {
    if (this.edge === void 0) return void 0;
    return this.edge.from;
  }
  isDeprecated() { return this._isDeprecated; }
  deprecate() { this._isDeprecated = true; }
  isRoot() {
    return this.edge == void 0  || this.edge.from == void 0;
  }
  contains(map) {
    return this.leftId < map.leftId && map.rightId < this.rightId;
  }
  edgeTo(to, reason, time, data) {
    new Edge(from, to, reason, time, data);
  }
  addEdge(edge) {
    this.children.push(edge);
  }
  setStyle(ctx) {
    ctx.fillStyle = this.edge && this.edge.from  ? "black" : "green";
  }
  chunkIndex(chunks) {
    // Did anybody say O(n)?
    for (let i = 0; i < chunks.length; i++) {
      let chunk = chunks[i];
      if (chunk.isEmpty()) continue;
      if (chunk.last().time < this.time) continue;
      return i;
    }
    return -1;
  }
  position(chunks) {
    let index = this.chunkIndex(chunks);
    let xFrom = (index + 0.5) * kChunkWidth;
    let yFrom = kChunkHeight - chunks[index].yOffset(this);
    return [xFrom, yFrom];
  }
  transitions() {
    let transitions = Object.create(null);
    let current = this;
    while (current) {
      let edge = current.edge;
      if (edge && edge.isTransition()) {
        transitions[edge.name] =  edge;
      }
      current = current.parent()
    }
    return transitions;
  }
  getType() {
    return this.edge === void 0 ? "new" : this.edge.type;
  }
  getParents() {
    let parents = [];
    let current = this.parent();
    while (current) {
      parents.push(current);
      current = current.parent();
    }
    return parents;
  }
}

V8Map.get = function(id) {
  if (!this.cache) {
    this.cache = new Map();
  }
  return this.cache.get(id);
}

V8Map.set = function(id, map) {
  if (!this.cache) {
    this.cache = new Map();
  }
  // if (this.get(id)) console.log("Overriding Map: "+id);
  this.cache.set(id, map);
}

class Edge {
  constructor() {
    this.type = "";
    this.name = "";
    this.reason = undefined;
    this.time = undefined;
    this.from = undefined;
    this.to = undefined;
  }
  finishSetup() {
    if (this.from) {
      this.from = V8Map.get(this.from);
      if (this.from) this.from.addEdge(this);
    }
    if (this.to) {
      this.to = V8Map.get(this.to);
      if (this.to) {
        this.to.edge = this;
        if (this.from) this.to.depth = this.from.depth + 1;
      }
    }
  }
  chunkIndex(chunks) {
    // Did anybody say O(n)?
    for (let i = 0; i < chunks.length; i++) {
      let chunk = chunks[i];
      if (chunk.isEmpty()) continue;
      if (chunk.last().time < this.time) continue;
      return i;
    }
    return -1;
  }
  parentEdge() {
    if (!this.from) return undefined;
    return this.from.edge;
  }
  chainLength() {
    let length = 0;
    let prev = this;
    while (prev) {
      prev = this.parent;
      length++;
    }
    return length;
  }
  isTransition() { return this.type == "Transition" }
  isFastToSlow() { return this.type == "Normalize" }
  isSlowToFast() { return this.type == "SlowToFast" }
  isInitial() { return this.type == "InitialMap" }
  isReplaceDescriptors() { return this.type == "ReplaceDescriptors" }
  isCopyAsPrototype() { return this.reason == "CopyAsPrototype" }
  isOptimizeAsPrototype() { return this.reason == "OptimizeAsPrototype" }
  setStyle(ctx) {
    let color = this.getColor();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
  }
  getColor() {
    return transitionTypeToColor(this.type);
  }
  symbol() {
    if (this.isTransition()) return "+";
    if (this.isFastToSlow()) return "⊡";
    if (this.isSlowToFast()) return "⊛";
    if (this.isReplaceDescriptors()) {
      if (this.name) return "+";
      return "∥";
    }
    return "";
  }
  toString() {
    let s = this.symbol();
    if (this.isTransition()) return s + this.name;
    if (this.isFastToSlow()) return s + this.reason;
    if (this.isCopyAsPrototype()) return s + "Copy as Prototype";
    if (this.isOptimizeAsPrototype()) {
      return s + "Optimize as Prototype";
    }
    if (this.isReplaceDescriptors() && this.name) {
      return this.type + " " + this.symbol() + this.name;
    }
    return this.type + " " + (this.reason ? this.reason : "") + " "
        + (this.name ? this.name : "")
  }
}

function transitionTypeToColor(type) {
  switch(type) {
    case "new": return "green";
    case "Normalize": return "violet";
    case "map=SlowToFast": return "orange";
    case "InitialMap": return "yellow";
    case "Transition": return "black";
    case "ReplaceDescriptors": return "red";
  }
  return "black";
}


class Marker {
  constructor(time, name) {
    this.time = Number(time);
    this.name = name;
  }
}

class Timeline {
  constructor() {
    this.values = [];
    this.transitions = new Map();
    this.markers = [];
    this.startTime = 0;
    this.endTime = 0;
  }
  push(map) {
    let time = map.time;
    if (!this.isEmpty() && this.last().time > time) {
      // Invalid insertion order, might happen without --single-process,
      // finding insertion point.
      let insertionPoint = this.find(time);
      this.values.splice(insertionPoint, map);
    } else {
      this.values.push(map);
    }
    if (time > 0) {
      this.endTime = Math.max(this.endTime, time);
      if (this.startTime === 0) {
        this.startTime = time;
      } else {
        this.startTime = Math.min(this.startTime, time);
      }
    }
  }
  addMarker(time, message) {
    this.markers.push(new Marker(time, message));
  }
  finalize() {
    let id = 0;
    this.forEach(map =>  {
      if (map.isRoot()) id = map.finalize(id+1);
      if (map.edge && map.edge.name) {
        let edge = map.edge;
        let list = this.transitions.get(edge.name);
        if (list === undefined) {
          this.transitions.set(edge.name, [edge]);
        } else {
          list.push(edge);
        }
     }});
    this.markers.sort((a, b) => b.time - a.time);
  }
  at(index) { return this.values[index] }
  isEmpty() { return this.size() == 0 }
  size() { return this.values.length }
  first() { return this.values.first() }
  last() { return this.values.last() }
  duration() { return this.last().time - this.first().time }
  forEachChunkSize(count, fn) {
    const increment = this.duration() / count;
    let currentTime = this.first().time + increment;
    let index = 0;
    for (let i = 0; i < count; i++) {
      let nextIndex = this.find(currentTime, index);
      let nextTime = currentTime + increment;
      fn(index, nextIndex, currentTime, nextTime);
      index = nextIndex
      currentTime = nextTime;
    }
  }
  chunkSizes(count) {
    let chunks = [];
    this.forEachChunkSize(count, (start, end) => chunks.push(end-start));
    return chunks;
  }
  chunks(count) {
    let chunks = [];
    let emptyMarkers = [];
    this.forEachChunkSize(count, (start, end, startTime, endTime) => {
      let items =  this.values.slice(start, end);
      let markers = this.markersAt(startTime, endTime);
      chunks.push(new Chunk(chunks.length, startTime, endTime, items, markers));
    });
    return chunks;
  }
  range(start, end) {
    const first = this.find(start);
    if (first < 0) return [];
    const last = this.find(end, first);
    return this.values.slice(first, last);
  }
  find(time, offset=0) {
    return this.basicFind(this.values, each => each.time - time, offset);
  }
  markersAt(startTime, endTime) {
    let start = this.basicFind(this.markers, each => each.time - startTime);
    let end= this.basicFind(this.markers, each => each.time - endTime, start);
    return this.markers.slice(start, end);
  }
  basicFind(array, cmp, offset=0) {
    let min = offset;
    let max = array.length;
    while (min < max) {
      let mid = min + Math.floor((max - min) / 2);
      let result = cmp(array[mid]);
      if (result > 0) {
        max = mid-1;
      } else {
        min = mid+1;
      }
    }
    return min;
  }
  count(filter) {
    return this.values.reduce((sum, each) => {
      return sum + (filter(each) ? 1 : 0);
    }, 0);
  }
  filter(predicate) {
    return this.values.filter(predicate);
  }
  filterUniqueTransitions(filter) {
    // Returns a list of Maps whose parent is not in the list.
    return this.values.filter(map => {
      if (!filter(map)) return false;
      let parent = map.parent();
      if (!parent) return true;
      return !filter(parent);
    });
  }
  depthHistogram() {
    return this.values.histogram(each => each.depth);
  }
  fanOutHistogram() {
    return this.values.histogram(each => each.children.length);
  }
  forEach(fn) { return this.values.forEach(fn) }
}


class Chunk {
  constructor(index, start, end, items, markers) {
    this.index = index;
    this.start = start;
    this.end = end;
    this.items = items;
    this.markers = markers
    this.height = 0;
  }
  isEmpty() { return this.items.length == 0; }
  last() { return this.at(this.size()-1); }
  first() { return this.at(0); }
  at(index) { return this.items[index]; }
  size() { return this.items.length; }
  yOffset(map) {
    // items[0]   == oldest map, displayed at the top of the chunk
    // items[n-1] == youngest map, displayed at the bottom of the chunk
    return (1 - (this.indexOf(map) + 0.5) / this.size()) * this.height;
  }
  indexOf(map) { return this.items.indexOf(map); }
  has(map) {
    if (this.isEmpty()) return false;
    return this.first().time <= map.time && map.time <= this.last().time;
  }

  next(chunks) {
    return this.findChunk(chunks, 1);
  }

  prev(chunks) {
    return this.findChunk(chunks, -1);
  }

  findChunk(chunks, delta) {
    let i = this.index + delta;
    let chunk = chunks[i];
    while (chunk && chunk.size() == 0) {
      i += delta;
      chunk = chunks[i]
    }
    return chunk;
  }

  getTransitionBreakdown() {
    return BreakDown(this.items, map => map.getType())
  }

  getUniqueTransitions() {
    // Filter out all the maps that have parents within the same chunk.
    return this.items.filter(map => !map.parent() || !this.has(map.parent()));
  }
}

function BreakDown(list, map_fn) {
  if (map_fn === void 0) {
    map_fn = each => each;
  }
  let breakdown = {__proto__:null};
  list.forEach(each=> {
    let type = map_fn(each);
    let v = breakdown[type];
    breakdown[type] = (v | 0) + 1
  });
  return Object.entries(breakdown)
    .sort((a,b) => a[1] - b[1]);
}

// ShadowDom elements =========================================================
customElements.define('x-histogram', class extends HTMLElement {
  constructor() {
    super();
    let shadowRoot = this.attachShadow({mode: 'open'});
    const t = document.querySelector('#x-histogram-template');
    const instance = t.content.cloneNode(true);
    shadowRoot.appendChild(instance);
    this._histogram = undefined;
    this.mouseX = 0;
    this.mouseY = 0;
    this.canvas.addEventListener('mousemove', event => this.handleCanvasMove(event));
  }
  setBoolAttribute(name, value) {
    if (value) {
      this.setAttribute(name, "");
    } else {
      this.deleteAttribute(name);
    }
  }
  static get observedAttributes() {
    return ['title', 'xlog', 'ylog', 'xlabel', 'ylabel'];
  }
  $(query) { return this.shadowRoot.querySelector(query) }
  get h1() { return this.$("h2") }
  get canvas() { return this.$("canvas") }
  get xLabelDiv() { return this.$("#xLabel") }
  get yLabelDiv() { return this.$("#yLabel") }

  get histogram() {
    return this._histogram;
  }
  set histogram(array) {
    this._histogram = array;
    if (this._histogram) {
      this.yMax = this._histogram.max(each => each.length);
      this.xMax = this._histogram.length;
    }
    this.draw();
  }

  get title() { return this.getAttribute("title") }
  set title(string) { this.setAttribute("title", string) }
  get xLabel() { return this.getAttribute("xlabel") }
  set xLabel(string) { this.setAttribute("xlabel", string)}
  get yLabel() { return this.getAttribute("ylabel") }
  set yLabel(string) { this.setAttribute("ylabel", string)}
  get xLog() { return this.hasAttribute("xlog") }
  set xLog(value) { this.setBoolAttribute("xlog", value) }
  get yLog() { return this.hasAttribute("ylog") }
  set yLog(value) { this.setBoolAttribute("ylog", value) }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name == "title") {
      this.h1.innerText = newValue;
      return;
    }
    if (name == "ylabel") {
      this.yLabelDiv.innerText = newValue;
      return;
    }
    if (name == "xlabel") {
      this.xLabelDiv.innerText = newValue;
      return;
    }
    this.draw();
  }

  handleCanvasMove(event) {
    this.mouseX = event.offsetX;
    this.mouseY = event.offsetY;
    this.draw();
  }
  xPosition(i) {
    let x = i;
    if (this.xLog) x = Math.log(x);
    return x / this.xMax * this.canvas.width;
  }
  yPosition(i) {
    let bucketLength = this.histogram[i].length;
    if (this.yLog) {
      return (1 - Math.log(bucketLength) / Math.log(this.yMax)) * this.drawHeight + 10;
    } else {
     return (1 - bucketLength / this.yMax) * this.drawHeight + 10;
    }
  }

  get drawHeight() { return this.canvas.height - 10 }

  draw() {
    if (!this.histogram) return;
    let width = this.canvas.width;
    let height = this.drawHeight;
    let ctx = this.canvas.getContext("2d");
    if (this.xLog) yMax = Math.log(yMax);
    let xMax = this.histogram.length;
    if (this.yLog) xMax = Math.log(xMax);
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.beginPath();
    ctx.moveTo(0, height);
    for (let i = 0; i < this.histogram.length; i++) {
      ctx.lineTo(this.xPosition(i), this.yPosition(i));
    }
    ctx.lineTo(width, height);
    ctx.closePath;
    ctx.stroke();
    ctx.fill();
    if (!this.mouseX) return;
    ctx.beginPath();
    let index = Math.round(this.mouseX);
    let yBucket = this.histogram[index];
    let y = this.yPosition(index);
    if (this.yLog) y = Math.log(y);
    ctx.moveTo(0, y);
    ctx.lineTo(width-40, y);
    ctx.moveTo(this.mouseX, 0);
    ctx.lineTo(this.mouseX, height);
    ctx.stroke();
    ctx.textAlign = "left";
    ctx.fillText(yBucket.length, width-30, y);
  }
});

</script>
</head>
<template id="x-histogram-template">
  <style>
    #yLabel {
      transform: rotate(90deg);
    }
    canvas, #yLabel, #info { float: left; }
    #xLabel { clear: both }
  </style>
  <h2></h2>
  <div id="yLabel"></div>
  <canvas height=50></canvas>
  <div id="info">
  </div>
  <div id="xLabel"></div>
</template>

<body onload="handleBodyLoad(event)" onkeypress="handleKeyDown(event)">
  <h2>Data</h2>
  <section>
    <form name="fileForm">
      <p>
        <input id="uploadInput" type="file" name="files"  onchange="handleLoadFile();">
      </p>
    </form>
  </section>

  <h2>Stats</h2>
  <section id="stats"></section>

  <h2>Timeline</h2>
  <div id="timeline">
    <div id=timelineChunks></div>
    <canvas id="timelineCanvas" ></canvas>
  </div>
  <div id="timelineOverview"
      onmousemove="handleTimelineIndicatorMove(event)" >
    <div id="timelineOverviewIndicator">
      <div class="leftMask"></div>
      <div class="rightMask"></div>
    </div>
  </div>

  <h2>Transitions</h2>
  <section id="transitionView"></section>
  <br/>

  <h2>Selected Map</h2>
  <section id="mapDetails"></section>

  <x-histogram id="mapsDepthHistogram"
      title="Maps Depth" xlabel="depth" ylabel="nof"></x-histogram>
  <x-histogram id="mapsFanOutHistogram" xlabel="fan-out"
      title="Maps Fan-out" ylabel="nof"></x-histogram>

  <div id="tooltip">
    <div id="tooltipContents"></div>
  </div>
</body>
</html>
