{
  "comments": [
    {
      "key": {
        "uuid": "f16edaf1_5408c902",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-09-30T12:59:41Z",
      "side": 1,
      "message": "ptal.\n\nThis is the direction I want to go now for the external \"marking\" of in construction objects.\nPlease note that the object don\u0027t actually need to marked. Any mechanism that prevents us from pushing the same object multiple times to the worklist would suffice to prevent bloating the worklist (in this CL the Contains method is meant as that CL).\n\nWhatever mechanism we go with needs to work both the mutator thread and on concurrent threads. I started with having a standalone std::unordered_set that is accessed directly and is guarded by a lock. Wanting to avoid obtaining the lock for each object, lead me back to our worklist design.\n\nRight now I\u0027m using std::unordered_set in the Segments instead of the array we usually have. I see this as a trade-off between cost of insertion and cost of querying. Querying will happen for every in construction object, possibly multiple times although probably not often, while insertion should happen at most once per thread. Thus I think we need to prioritize faster querying.\nWe could also use a std::vector or the arrays we currently have which would mean faster insertion but would require iterating over the array for querying.\n(if we decide that the in-construction worklist is expected to remain small enough, it might be acceptable to use the existing arrays and add the Contains method to all worklists).",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cc388084_5e383d73",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-09-30T13:03:01Z",
      "side": 1,
      "message": "Why no side data structure that is a plain std::unordered_set guarded by a lock for the whole thing? I don\u0027t see why we need to integrate this into Worklist.",
      "parentUuid": "f16edaf1_5408c902",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8980cbdc_93d82cc6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002405
      },
      "writtenOn": "2020-09-30T13:27:53Z",
      "side": 1,
      "message": "+1 I was wondering the same.",
      "parentUuid": "cc388084_5e383d73",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9a2bc4a_095aa521",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-09-30T13:30:17Z",
      "side": 1,
      "message": "I started with a side data structure with a lock like you describe. Then I realized that the data structure with the lock holds the exact same data as the worklist we have for in-construction objects.\nThat meant that we can drop the worklist.\nThen I became concerned that we need to get the lock for each in-construction object we encounter and wanted to use some local cache, which led me back to our worklist design.\nIntegrating it into the worklist also simplifies flushing the objects to the previously_not_fully_constructed worklist, assuming we do drop the regular not_fully_constructed worklist since all the data is already stored in the side data structure. You can see what that looked like here:\nhttps://chromium-review.googlesource.com/c/v8/v8/+/2437388",
      "parentUuid": "cc388084_5e383d73",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb9987b6_7da5f4a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-09-30T13:45:32Z",
      "side": 1,
      "message": "Except for our degenerate corner cases we hardly encounter such objects in practice. [citation needed: last time I measured was some time ago]\n\nCases:\n- If we have few in-construction objects then the separate data structure keeps complexity where it is (in construction objects).\n- If we have many such in-construction objects, then the query becomes an issue because we have linear complexity for Contains().\n\nMoving over to a processable worklist is a bit slower with just having a std::unordered_set at the same time, we initially do not need to care about segments.\n\nI\u0027d generally say that we should go with the side data structure unless we have data showing otherwise to avoid blowing up Worklist.",
      "parentUuid": "c9a2bc4a_095aa521",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "daceba54_21e911c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-09-30T13:57:27Z",
      "side": 1,
      "message": "Another observation: We bound the duplicates by #tasks, because of the local segments, right? That means live bytes accounting can be off at some point.",
      "parentUuid": "eb9987b6_7da5f4a1",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb9f8b7e_ee2d4114",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1356087
      },
      "writtenOn": "2020-09-30T14:11:42Z",
      "side": 1,
      "message": "If we assume very few in-construction objects, then I would actually recommend adding a Contains method to the regular worklist implementation. The cost of querying by iterating over all items in a segment should be negligible if there are very few objects.\n\nYes, we bound by number of duplicates the amount of times an object can be pushed to the worklist, but since we actually mark it after popping from the worklist I think the live bytes accounting is safe.",
      "parentUuid": "daceba54_21e911c2",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "971f3960_e130db29",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1131764
      },
      "writtenOn": "2020-09-30T14:26:46Z",
      "side": 1,
      "message": "Why are we optimizing this case?\n\nI think we should either\na. accept dupes during regular marking until it becomes a problem. I was wrong there in the initial review on the other CL because I didn\u0027t see that the write barrier (which is likely creates to create dupes) does use the regular markbit; or\nb. go with something really simple that doesn\u0027t blow up to O(n) in a worst case. I think we can even get away with sequentially processing \"previously in construction\" objects without seeing any difference.\n\nWe should have data for anything more complex ðŸ˜Š\n\n\u003e If we assume very few in-construction objects, then I would actually recommend adding a Contains method to the regular worklist implementation. The cost of querying by iterating over all items in a segment should be negligible if there are very few objects.\n\nHaving O(n) contains is always scary in corner cases.\n\n\u003e Yes, we bound by number of duplicates the amount of times an object can be pushed to the worklist, but since we actually mark it after popping from the worklist I think the live bytes accounting is safe.\n\nTrue!",
      "parentUuid": "eb9f8b7e_ee2d4114",
      "revId": "2bdc49f36f7cc3246ba8a0cfcc2a6c62ff41e930",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}