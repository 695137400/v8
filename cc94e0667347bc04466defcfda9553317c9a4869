{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "651636f6_bee64024",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2023-04-18T12:16:11Z",
      "side": 1,
      "message": "Scrolling over this CL, I feel like I totally miss the context here. Is there a tracking bug or a design doc that describes what this CL is trying to achieve?\n\nI\u0027ll move myself to CC for now as TurboFan is not my area of expertise anyway :)",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c023d196_093149d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1500921
      },
      "writtenOn": "2023-04-18T12:32:33Z",
      "side": 1,
      "message": "There is neither of those, I was hoping that the comment in the main file would be enough to explain what\u0027s going on, but admittedly there\u0027s nothing wasm specific there... For a general context, it seems it can be hard to use immediate indexes in wasm memory operations but, I believe, once we get to this stage in TurboFan we should be able to modify them to use immediate indexes.\n\nDoes this make any more sense? Do you have any there any particular questions?",
      "parentUuid": "651636f6_bee64024",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f27b76e_e7ddaf85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1500921
      },
      "writtenOn": "2023-04-18T12:40:54Z",
      "side": 1,
      "message": "Something that isn\u0027t currently in this patch, but something that I have been wondering about, is whether this transformation should only be applied for wasm32 on a 64-bit host.",
      "parentUuid": "c023d196_093149d1",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a562bec_b6e02abb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2023-04-18T12:45:17Z",
      "side": 1,
      "message": "Ah, missed that comment in `address-reassociation.cc`. The optimization seems to generally make sense, why do we limit it to wasm and to protected loads? And why is it behind a flag? Do you expect this to regress code in certain places?",
      "parentUuid": "3f27b76e_e7ddaf85",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c90fd802_e5684bd6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1500921
      },
      "writtenOn": "2023-04-18T13:18:05Z",
      "side": 1,
      "message": "We limit to wasm because this seems to be a very wasm-shaped problem, I will update the comment to explain the wasm context which gives rise to it. I\u0027ve tried it in the JS pipeline and it triggered very rarely. And it\u0027s for ProtectedLoads only for legacy reasons, that\u0027s what I\u0027ve been benchmarking on arm64, for a while... :)\nMy downstream patch adds ProtectedStore support, I just need to run the benchmarks on my x64 machine and then I\u0027ll push it.\n\nAs for the flag, there is a chance it could cause regressions, but I think I\u0027ve tweaked the heuristics enough that it is good the vast majority of time.",
      "parentUuid": "5a562bec_b6e02abb",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d1a256d0_562cfde7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1345975
      },
      "writtenOn": "2023-04-18T13:54:55Z",
      "side": 1,
      "message": "A couple of comments already, mostly superficial. I\u0027m also not a TurboFan expert, but that looks relatively self-explanatory.\nI haven\u0027t looked at the test yet.",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e07e274_3e0278a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1177599
      },
      "writtenOn": "2023-04-18T15:21:25Z",
      "side": 1,
      "message": "Is there a downside to trying to normalize all memory accesses to `(base + reg) + imm`? I don\u0027t get why this needs to be so specific, and why we only change nodes if there are \u003e\u003d 2 occurrences.",
      "parentUuid": "c90fd802_e5684bd6",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22b76f4e_42cdb3a1",
        "filename": "src/compiler/address-reassociation.cc",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 1345975
      },
      "writtenOn": "2023-04-18T13:54:55Z",
      "side": 1,
      "message": "Do I understand correctly from the code that you also match this pattern?\n\n    ProtectedLoad (base_reg, IntPtrAdd(register_offset, immediate_offset))\n\nFollow-up question, why not also:\n\n    ProtectedLoad (base_reg, IntPtrAdd(immediate_offset, register_offset))\n\n?",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c205a7d_43dd35c2",
        "filename": "src/compiler/address-reassociation.cc",
        "patchSetId": 3
      },
      "lineNbr": 147,
      "author": {
        "id": 1345975
      },
      "writtenOn": "2023-04-18T13:54:55Z",
      "side": 1,
      "message": "`DCHECK_EQ(load-\u003eopcode(), IrOpcode::kProtectedLoad);`",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd7dc61e_570e7779",
        "filename": "src/compiler/address-reassociation.cc",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1345975
      },
      "writtenOn": "2023-04-18T13:54:55Z",
      "side": 1,
      "message": "This should not be needed, there is already an assert in std::vector::operator[].",
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de6fd4a6_8dac9d13",
        "filename": "src/compiler/address-reassociation.h",
        "patchSetId": 3
      },
      "lineNbr": 30,
      "author": {
        "id": 1345975
      },
      "writtenOn": "2023-04-18T13:54:55Z",
      "side": 1,
      "message": "\"Object\" is a bit confusing, protected loads are used to load values from the wasm linear memory, not heap objects. Maybe something like \"CandidateLoadBase\"?\nSame thing in other places where \"object\" refers to the factorized base + register offset.\nBut feel free to ignore if you disagree, it\u0027s not worth bikeshedding.",
      "range": {
        "startLine": 30,
        "startChar": 17,
        "endLine": 30,
        "endChar": 23
      },
      "revId": "cc94e0667347bc04466defcfda9553317c9a4869",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}